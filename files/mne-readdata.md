\newpage

## データの読み込みとフィルタリング・リサンプル(公式サイト版)

ついに　MNEを使い始めます。まずは下記リンクを開けてください。
[http://martinos.org/mne/stable/auto_tutorials/plot_artifacts_correction_filtering.html](http://martinos.org/mne/stable/python_reference.html
)
ちょっと小難しい文法を使っているように見えます。
小難しい部分は初心者は混乱するだけなので無視してください。
難しいなら読み飛ばして、次に移ってください。簡単にまとめています。
公式サイトでは脳磁図前提としていますが、ここではついでに脳波の読み込みの解説もやります。
是非脳波、脳磁図のファイルを手元において、読み込んだり
フィルタを掛けてみてください。(でないと、覚えられません)


ここでは

- データの読み込み
- パワースペクトル密度のプロット(以下psd)[^psd]
- notch filterとlow pass filterを使って要らない波を除去する
- サンプリングレートを下げて処理を軽くする

をしています。

[^psd]:各周波数ごとの波の強さをあらわしたもの。フーリエ変換の結果算出されるものの1つ。

はじめのパラグラフ[^cell]で大事な関数は以下です。

[^cell]:ipython/jupyter独自の単位でcellといいます。通常のプログラミングでは行ごと、関数ごとですが、jupyterでは数行をひと塊りにしてプログラムを書きます。色々悪いところもありますが、解説用コードを書けるのがjupyterの強みです。

- mne.io.read_raw_fif:脳磁図のデータを読み込みます。
 ここではつけていませんが、通常preload=Trueをつけた方がいいです。
 preloadをつけると、メモリ上に脳磁図データを読み込み、
 色々と処理ができるようになります。(付けないと処理できないです…)
 脳波を解析するなら下記公式サイトの**Reading raw data**セクションに
 各種形式に対応した読み込み関数が書いてありますから、読み替えてください。
 [http://martinos.org/mne/stable/python_reference.html]( http://martinos.org/mne/stable/python_reference.html)

 読み込みの詳細は後で書きます。
- mne.read_selection:脳磁図の一部を取り出しています。
- mne.pick_types:データの中から欲しいデータだけ取り出します。
- plot.psd:psdプロットを行います。

基本は体で慣れるしかありませんが、大抵のエディタでは
tabキーとかを押せば補完してくれるので、入力自体は楽です。
例えば「raw.」と書いてtabを押せば、plot関数だけでも色々出てきます。
だから、色々プロットして遊んでみてください。

次のcellではnotch filterをかけています。

- notch_filter
これは特定の周波数を削除するフィルタです。
何故それをするかというと、送電線の周波数が影響するからです。
西日本では60Hz、東日本では50Hzです。それを除去できます。[^ham]
関数内にnp.arangeと書いてあるのはnumpyの関数。
60から241までの間で60ごとの等差数列を返すものです。
つまり、ここでは60Hzを除去しています。

[^ham]:敢えて除去しない研究者もいます。notchfilterによって、除去する周波数の周辺の信頼性が失われるとのことです。

次にlow pass filterをかけます。

- filter
これは分かりやすいでしょう。ある周波数以上、以下の波を除去します。
バンドパスフィルタと言います。
ERPをする時は遅い周波数成分を除去するときは注意が必要です。
その場合は0.1Hz未満でするのがいいのかもしれません。
また、ICAでノイズ除去する時は1Hzくらいでかけるといいです。

最後にサンプリングレートを変えています。
理由は今後処理がかなりのものになるので負担を軽くしたいからです。

- resample
ここでは100Hzまで下げていますが、最低見たい周波数の2〜3倍以上の周波数が必要です。
また、周波数は元の周波数の約数である必要があります。
というか、普通resampleとか必要ないんですが、何かここではやっていますね。

以上…MNEの公式サイトは一寸詳しいです。初心者にはちょっとつらかったですね…。
よしよし。

## データの読み込みとfilter,resample(僕の解説)

公式サイトはpythonをバリバリ書ける上に生理学をきちんと理解できている人向けに感じます。
本書はあくまで初心者向けです。
先ずは大雑把に理解して体を動かすべきと思うので、以下は極めて乱暴な僕なりのまとめです。
大まかに理解した上で公式サイトに取り組めば良いのではないでしょうか？

極めて乱暴にまとめると、ノイズ取りの第一段階はこうです。
```{frame=single}
raw = mne.io.read_raw_fif('hoge',preload=True)    #読み込み
raw.filter(1,100)    #0.1~100Hzの波だけ残すバンドパスフィルタ
raw.notch_filter([60,100])    #この場合、60と100Hzを消してる
raw.save('fuga')
```

...ていうか、このくらい雑な例のほうが良いと思う。

ちなみに、第0段階があります。それはbadchannnelの指定、interpolation、maxfilter等ですが、
とりあえず読めなきゃ話にならないので。

- 1行目で読み込みます。脳波と脳磁図では読み込み方が違うので、次セクションを参照。
 preloadをTrueにしてください。そうしないとメモリ上に読み込んでくれません。[^preload]
 fifというのは適当に読み替えて下さい。
- 2行目でバンドパスフィルタかけてます。1Hz未満の波と、100Hz以上の波を消しています。[^bandpass]
- 3行目で送電線のハムノイズを取っています。[^notch]
- 4行目でデータを間引いて処理を軽くしています。必ず元データの約数に設定し、
 wavelet変換するならばwavelet変換の最高の周波数の2〜3倍以上の周波数にしてください。
 というか、僕ならresampleはしません。データが荒くなるからです。
- 5行目で掃除した結果を'fuga'という名前で保存しています。

[^bandpass]:バンドパスフィルタについては賛否両論と思います。何故なら、時間周波数解析をすると要らない周波数は消えちゃうので、意味が無いという考えがあるからです。詳しくは参考文献のanalyzing neural ...を読んで下さい。個人的にはソースレベル解析の場合はした方がいいと思います。
[^notch]:notchフィルタもバンドパスフィルタ同様賛否両論です。
[^preload]:preloadしないと各種処理が出来ないので、ほぼ必須です。何故preloadが標準でFalseなのかはよくわかりませんが、Falseも使いみちがあります。例えば生波形を素早く表示するだけならばpreloadはFalseが軽いです。

あとは、plotを色々してみてください。

以下、本書ではこのような乱暴な解説をしてとりあえず手で覚えた後、
理屈を覚えていくスタイルにしていきます。

## 脳波読み込みの問題

脳波はすんなり読み込めたでしょうか？そうでもないかもしれないですね。
なにしろ、脳磁図と違って脳波は沢山の形式があるのです。
例えば、ヘッダーファイルを要求する形式があったりもしますし、
モンタージュや眼球運動チャンネルの設定を追加せねばならぬ場合もあります。
このセクションは試行錯誤が要求されます。

ちなみに、mneはmne.io.read_raw_hogeって感じで色々なデータに対応しています。
やたら対応できるのは多いので適当に見て下さい。

さて…脳波は色々な企業が参入していますが、
脳波のファイルには以下の情報が入ってたり入ってなかったりです。

- 波形データ
- チャンネル名と空間データ
- 測定条件

このあたりは脳波計のユーザーが設定できる所もあったりするので、
脳波計の管理者に聞いたりするのが早いかもしれません。
また、モンタージュ(センサーの空間情報)を指定せねばならぬ事もあります。
例えばbiosemiの場合は下記のように書きます。

```{frame=single}
raw = mne.io.read_raw_edf(
    filename,
    preload=True,
    montage='biosemi64',
    eog=['eye-l','eye-r'],
    exclude=['X1','X2','X3','X4']
)
```

解説します…。

- filename
 これは問題ないですね
- preload
 これも問題ないです。前のセクションを御覧ください。
- montage
 これは場合によっては問題ありですのであとで解説します。
- eog
 これは、眼球運動は何番目のチャンネルだよ、というやつですね。単純。
- exclude
 これは、このチャンネルはいらないよ、というやつです。
 余りチャンネルが有ることは日常茶飯事です。数字で指定もできます。

### 日本光電
最近mneでは日本光電の形式を読めるようになりました。
これで病院づとめの人も脳波解析が出来ますね！
mne.io.read_nihon関数です。
なんか、日本国を呼んでいる感じがして名前がデカいですね！

### EDFでevent情報が読み込めない場合
EDF形式はかなりメジャーな脳波の形式です。
event情報が文字列として入ってたりします。
そんな時はMNEpythonでは読めません。なので、別のソフトを使います。
使うソフトはpyedflibです。インストールしましょう。
```{frame=single}
pip install pyedflib
```
そして、コードを書くのですが、たいへん面倒いです。
```{frame=single}
import pyedflib
edf = pyedflib.EdfReader('hoge.edf')
annot = edf.read_annotation()
```

これでannot(list形式)にイベント情報が入ります。
しかし、annotの中を覗くと分かると思いますが、たまーにこのannotの中に
2行で1つのイベントとかが入ってたりして、そいつを1つのイベントとして
書き直すスクリプトを書かないといけなかったりするので面倒臭いです。
頑張って書いて下さい。

### EDFが少しも読み込めない場合
EDF形式はメジャーなのですが、そんな中にも色々な形式があります。
EDF+CだとかEDF+Dだとか。EDF+Dは凄く読み込みにくいです。
pyedflibはEDF+Dを読めません。しかし、万事休すではありません。
open sourceのいいソフトがあります。edfbrowserというソフトです。

[https://www.teuniz.net/edfbrowser/](https://www.teuniz.net/edfbrowser/)

このサイトにはwindows版が公開されていますね。
このソフトはtoolsメニューからEDF+DをEDF+Cに変換する事ができます。

macやlinuxの人はコンパイルしてください。
このサイトにはmacのコンパイルの仕方が書いてありませんが、
それはこのようにします。
まず、xcodeをapp_storeからインストールします。
そして、homebrewをインストールします。ググってください。
その上で、下記のようにしてgitとqtをインストールします。
```{frame=single}
brew install qt
brew install git
```
そして、ソースコードをダウンロードします。
ソースコードのフォルダの中で、
```{frame=single}
qmake
make
```
とすると、バイナリが出来上がります。

### 脳波のセンサーの位置が変則的な場合
さて…montageの話をします。montageは要するにセンサーの空間情報です。
この世には色々な脳波の取り付け方があります。「は？10-20法しかねえよ！」
と言われそうですが、あるものは仕方ないのです。センサーの数の違いもありますし。

MNEpythonでは出来合いのモンタージュセットがあります。
10-20法ならだいたいセンサーはこの辺だよ、というやつですね。
それは上記のように文字列で指定できます。大抵はこれで事足ります。
しかし、時々凄くニッチなセンサー配置の脳波計があったりします。
そういうのはMNEpythonで対応できないこともしばしばです。
そんな時には文字列じゃなくてモンタージュ情報を別途読み込んで、
montage変数に入れなきゃなりません。めんどいです。
詳しくはmne.ioの解説記事をみて下さい。形式ごとの解説記事があります。

ちなみに下記のようにrawを読み込んだ後で指定する事も可能です。
```{frame=single}
from mne.channels import read_montage
mont = read_montage('standard_1020')
raw.set_montage(mont)
```

### 脳波のセンサーからソースベース出来んの？

これについては大きな声では言いたくないのですが、出来ます。
ちょっと捻ったやり方が必要です。
ただし、脳波のセンサーを位置情報としたソースベース解析が
どの程度の精度を持っているかは…お察しください。

まず、上記のraw.set_montage(mont)に一つオプションを入れます。

```{frame=single}
raw.set_montage(mont, set_dig=True)
```

これをすると、raw.infoの中にraw.info['dig']という項目が入ります。
このdigの中に位置情報が入りますから、これを使って位置合わせが出来ます。

さて、これを僕がやってみた時に、
どういうわけかmegのmontage情報に比べて縮尺がやたら大きかったです。
僕がやったときはなんと千倍のサイズでした()
この大きさになると無理感が出てくるので、ちっちゃくしちゃいました。

```{frame=single}
for n in raw.info['dig']:
    n['r']=n['r']/1000
```

無理矢理感あふれるやり方ですね…。
こうすることにより、MEGと同じ様にmne coregが出来るようになりました。
皆さんは皆さんの条件に合わせて格闘して下さい。
mne coregについては後述します。ソースベース解析の所を御覧ください。

### 脳波のセンサーの名前が変則的な場合

もう一つかなり面倒くさい問題があります。
MNEpythonはチャンネルの位置情報を自動で設定する時に
ファイルの中に記述されているチャンネルの名前を参照して
位置情報を当てはめていきます。これの何が困るのでしょうか？

脳波計がmontageの'Fp1'という風な普通の名前で出力してたら良いのですが、
例えば'EEG-Fp1'という風な名前だったら名前を変えてあげないと読めないのです。
名前は大事なのです。

変える方法としては、raw.rename_channels関数を使う方法があります。
[mne.channels.read_montage](https://mne-tools.github.io/stable/generated/mne.channels.read_montage.html#mne.channels.read_montage)の解説記事を開いてみて下さい。

まず、チャンネルの名前を表示しましょう。
いっぱいモンタージュ情報が書いてありますが、ここでは10-20法を見てみます。
```{frame=single}
mont = mne.channels.read_montage('standard_1020')
print(mont.ch_names)
mont.plot()
```
凄くたくさんのチャンネル名と図が出てきましたね？
次に、読み込んだ脳波のチャンネルリストを見てみましょう。
```{frame=single}
print(raw.ch_names)
```
チャンネル名が同じ名前になっているでしょうか？
なっていなかったら書き換えていかねばなりません。
書き換えるには、pythonの辞書形式を利用します。
2つのチャンネル名をよーく見比べて変えていって下さい。
下記のような辞書を作っていきます。

```{frame=single}
channel_list = {
    "EEG Fp1-Ref": "Fp1", "EEG Fp2-Ref": "Fp2",
    "EEG F3-Ref": "F3", "EEG F4-Ref": "F4",
    "EEG C3-Ref": "C3", "EEG C4-Ref": "C4",
    "EEG P3-Ref": "P3", "EEG P4-Ref": "P4",
    "EEG O1-Ref": "O1", "EEG O2-Ref": "O2",
    "EEG F7-Ref": "F7", "EEG F8-Ref": "F8",
    "EEG T3-Ref": "T3", "EEG T4-Ref": "T4",
    "EEG T5-Ref": "T5", "EEG T6-Ref": "T6",
    "EEG Fz-Ref": "Fz", "EEG Cz-Ref": "Cz",
    "EEG Pz-Ref": "Pz","EEG A1-Ref":"A1",
    "EEG A2-Ref":"A2"}
```
脳波の基準電極や眼球運動や心電図もこんな風に辞書にして下さい。
では、この辞書を使ってチャンネル名を変えましょう。

```{frame=single}
raw.rename_channels(channel_list)
```
これで、脳波のチャンネルの名前を変え終わりました。
最後に、用意したmontageと脳波をくっつけます。

```{frame=single}
mont=mne.channels.read_montage('standard_1020')
raw.set_montage(mont)
```
これで上手くいけば普通にMNEpythonで解析できます。

### 基準電極
基準電極の設定は下記のような感じでできます。
```{frame=single}
raw = mne.set_eeg_reference(
  raw, ref_channels=['LMASTOID'])[0]
```
が、普通脳は研究では全体の平均で設定することが多いようですから、下記のようなのが普通でしょうか。

```{frame=single}
raw2=mne.set_eeg_reference(raw)[0]
```
ちなみに、初期設定では全体の平均を基準電極としていますから、この設定は実は不要です。

末尾の[0]はこの関数がlist形式で結果を出してくるから必要です。
詳細は
http://martinos.org/mne/stable/python_reference.html
を見て、各自読み替えてください。

このようなスクリプトははじめは面倒ですが、
一度書いてしまえば後は使いまわしたり自動化出来ます。

### トリガーチャンネル
もう一つの鬼門がトリガーチャンネルです。つまり、刺激提示の時刻を記録したものです。
これは通常下記で表示できます。
```{frame=single}
mne.find_events(raw)
```
rawの中の刺激提示チャンネルが読めない場合はどうにかしてテキスト形式とかで書き出してください。
そこからは…貴方はもちろんpythonistaなので書けるはずです。
例えば、pandasを使って
```{frame=single}
import pandas as pd
shigeki=pd.read_csv('hoge.csv')
```
後はゴリゴリスクリプト書いてください。

僕もこのようなトリガーチャンネルについて苦労しました。
僕の場合はトリガーが脳波と同じように波形として記録されていたのです。脳波の波形は
```{frame=single}
raw.get_data()
```
で出力することが出来ます。内容はチャンネルごとのnumpy形式の数列です。
サンプリング周波数を鑑みてがんばってください。
トリガーチャンネルは信号が入ったら波形が跳ね上がっていたので、
僕はその跳ね上がりを検知するようなスクリプトを書くことで解決しました。

