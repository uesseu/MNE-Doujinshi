<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>MNE同人誌 – introduction</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="github.css" />
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#紹介編">紹介編</a><ul>
<li><a href="#本書の構成">本書の構成</a></li>
<li><a href="#はじめに">はじめに</a></li>
<li><a href="#本書の目的限界対象者使い方">本書の目的・限界・対象者・使い方</a></li>
<li><a href="#センサーベースソースベース解析とはなんぞや">センサーベース/ソースベース解析とはなんぞや</a></li>
<li><a href="#スラングや用語の説明とunix系のお約束">スラングや用語の説明とunix系のお約束</a></li>
<li><a href="#それぞれの研究に必要な環境特色のまとめ">それぞれの研究に必要な環境・特色のまとめ</a><ul>
<li><a href="#脳波センサーレベル研究">脳波センサーレベル研究</a></li>
<li><a href="#megセンサーレベル研究">MEGセンサーレベル研究</a></li>
<li><a href="#mri研究">MRI研究</a></li>
<li><a href="#megmriソースレベル研究">MEG+MRIソースレベル研究</a></li>
<li><a href="#eegmri同時計測研究">EEG/MRI同時計測研究</a></li>
</ul></li>
<li><a href="#mne-pythonとは">MNE-pythonとは</a></li>
<li><a href="#freesurferとは">freesurferとは</a></li>
<li><a href="#それぞれのソフトの関係性それofficeに例えるとどうなの">それぞれのソフトの関係性〜それofficeに例えるとどうなの？〜</a></li>
<li><a href="#脳の研究">脳の研究</a><ul>
<li><a href="#γオシレーション">γオシレーション</a></li>
<li><a href="#何故皮質はγなん">何故皮質はγなん？</a></li>
<li><a href="#どんな事をする">どんな事をする？</a></li>
<li><a href="#じゃあ統合失調症にどんな異常があるって">じゃあ統合失調症にどんな異常があるって？</a></li>
<li><a href="#診断ツール">診断ツール</a></li>
<li><a href="#つまり">つまり？</a></li>
</ul></li>
</ul></li>
<li><a href="#実験編">実験編</a><ul>
<li><a href="#実験をしよう">実験をしよう！</a><ul>
<li><a href="#被験者の非協力の苦しみ">被験者の非協力の苦しみ</a></li>
<li><a href="#外来のノイズの苦しみ">外来のノイズの苦しみ</a></li>
<li><a href="#体の動きによる苦しみ">体の動きによる苦しみ</a></li>
<li><a href="#眼球による苦しみ">眼球による苦しみ</a></li>
<li><a href="#視覚実験の苦しみ視線">視覚実験の苦しみ(視線)</a></li>
<li><a href="#視覚実験の苦しみメガネ">視覚実験の苦しみ(メガネ)</a></li>
<li><a href="#視覚実験の苦しみ画面との距離">視覚実験の苦しみ(画面との距離)</a></li>
<li><a href="#mri同時計測の苦しみ">MRI同時計測の苦しみ</a></li>
<li><a href="#聴覚実験の苦しみ">聴覚実験の苦しみ</a></li>
<li><a href="#resting実験の苦しみ">Resting実験の苦しみ</a></li>
<li><a href="#汗と凍えの苦しみ">汗と凍えの苦しみ</a></li>
<li><a href="#震えの問題の苦しみ">震えの問題の苦しみ</a></li>
<li><a href="#ハゲの苦しみ">ハゲの苦しみ</a></li>
<li><a href="#デブと心電図の苦しみ">デブと心電図の苦しみ</a></li>
<li><a href="#青筋の苦しみ">青筋の苦しみ</a></li>
<li><a href="#青二才と老人の苦しみ">青二才と老人の苦しみ</a></li>
<li><a href="#苦しすぎて死にたくなった">苦しすぎて死にたくなった?</a></li>
</ul></li>
<li><a href="#実験のディレイの測定">実験のディレイの測定</a><ul>
<li><a href="#必要物品">必要物品</a></li>
<li><a href="#mriと脳磁計の準備">MRIと脳磁計の準備</a></li>
<li><a href="#脳波計の準備">脳波計の準備</a></li>
<li><a href="#コンピュータの準備">コンピュータの準備</a></li>
</ul></li>
</ul></li>
<li><a href="#導入編">導入編</a><ul>
<li><a href="#osの準備">OSの準備</a><ul>
<li><a href="#windows">Windows</a></li>
<li><a href="#macos">MacOS</a></li>
<li><a href="#linuxオススメ">Linux(オススメ)</a></li>
</ul></li>
<li><a href="#開発環境の準備脳波脳磁図の場合出来るだけリッチに">開発環境の準備（脳波、脳磁図の場合。出来るだけリッチに。）</a><ul>
<li><a href="#それぞれの使用感">それぞれの使用感</a></li>
<li><a href="#僕の今のおすすめは">僕の今のおすすめは?</a></li>
<li><a href="#逆にお勧めしないもの">逆にお勧めしないもの</a></li>
<li><a href="#構築">構築</a></li>
<li><a href="#jupyterの起動">Jupyterの起動</a></li>
<li><a href="#jupyterでのplot">jupyterでのplot</a></li>
<li><a href="#anaconda仮想環境">anaconda仮想環境</a></li>
<li><a href="#rをjupyterで動かすために">Rをjupyterで動かすために</a></li>
<li><a href="#cuda">CUDA</a></li>
<li><a href="#バージョン管理git">バージョン管理git</a></li>
<li><a href="#gitサーバー">gitサーバー</a></li>
<li><a href="#jupyterで作ったスクリプトのバージョン管理小技">jupyterで作ったスクリプトのバージョン管理(小技)</a></li>
</ul></li>
<li><a href="#maxfilterelektaのやつ">maxfilter(elektaのやつ)</a></li>
<li><a href="#freesurferのインストール">freesurferのインストール</a></li>
<li><a href="#mnepythonのインストール脳波脳磁図をする場合">MNE/pythonのインストール(脳波、脳磁図をする場合)</a><ul>
<li><a href="#公式のインストール方法">公式のインストール方法</a></li>
<li><a href="#mayaviがインストール出来ない">MAYAVIがインストール出来ない</a></li>
<li><a href="#hf5をインストールしたい">HF5をインストールしたい</a></li>
<li><a href="#jupyter-kernel">jupyter kernel</a></li>
<li><a href="#cuda-1">CUDA</a></li>
<li><a href="#mnecのインストール">MNE/Cのインストール</a></li>
<li><a href="#コラム1-snsの活用"><em>コラム1-SNSの活用</em></a></li>
</ul></li>
<li><a href="#freesurferを使うmri">freesurferを使う(MRI)</a><ul>
<li><a href="#recon-all同時掛けfreesurfer">recon-all同時掛け(freesurfer)</a></li>
<li><a href="#freesurferの解析結果の表示">freesurferの解析結果の表示</a></li>
<li><a href="#解析結果のまとめ">解析結果のまとめ</a></li>
<li><a href="#画像解析の修正">画像解析の修正</a></li>
</ul></li>
<li><a href="#mricroncroglmriを使う場合">mricron/crogl(MRIを使う場合)</a><ul>
<li><a href="#mriのファイルの変換">MRIのファイルの変換</a></li>
</ul></li>
</ul></li>
<li><a href="#解析編">解析編</a><ul>
<li><a href="#肩慣らし">肩慣らし</a><ul>
<li><a href="#mnepythonを使う前に学んでおくべきパッケージ">MNEpythonを使う前に学んでおくべきパッケージ</a></li>
<li><a href="#pythonを綺麗に書くために">pythonを綺麗に書くために</a></li>
<li><a href="#numpyで遊ぼう">numpyで遊ぼう</a></li>
<li><a href="#解析を始める前のwarning">解析を始める前のwarning!</a></li>
<li><a href="#jupyter用作図用おまじないセット">jupyter用作図用おまじないセット</a></li>
</ul></li>
<li><a href="#データの読み込みとフィルタリングリサンプル公式サイト版">データの読み込みとフィルタリング・リサンプル(公式サイト版)</a></li>
<li><a href="#データの読み込みとfilterresample僕の解説">データの読み込みとfilter,resample(僕の解説)</a></li>
<li><a href="#脳波読み込みの問題">脳波読み込みの問題</a><ul>
<li><a href="#日本光電">日本光電</a></li>
<li><a href="#edfでevent情報が読み込めない場合">EDFでevent情報が読み込めない場合</a></li>
<li><a href="#edfが少しも読み込めない場合">EDFが少しも読み込めない場合</a></li>
<li><a href="#脳波のセンサーの位置が変則的な場合">脳波のセンサーの位置が変則的な場合</a></li>
<li><a href="#脳波のセンサーからソースベース出来んの">脳波のセンサーからソースベース出来んの？</a></li>
<li><a href="#脳波のセンサーの名前が変則的な場合">脳波のセンサーの名前が変則的な場合</a></li>
<li><a href="#基準電極">基準電極</a></li>
<li><a href="#トリガーチャンネル">トリガーチャンネル</a></li>
</ul></li>
<li><a href="#bad-channelの設定">bad channelの設定</a><ul>
<li><a href="#やり方1">やり方1</a></li>
<li><a href="#やり方2おすすめ">やり方2(おすすめ)　</a></li>
<li><a href="#interpolation">interpolation</a></li>
<li><a href="#maxfilter">maxfilter</a></li>
</ul></li>
<li><a href="#icaでノイズを取ろう">ICAでノイズを取ろう</a></li>
<li><a href="#icaコンポーネントのより良い取り除き方">ICAコンポーネントのより良い取り除き方</a><ul>
<li><a href="#自動判定">自動判定</a></li>
<li><a href="#半自動判定">半自動判定</a></li>
</ul></li>
<li><a href="#epochとevoked">EpochとEvoked</a></li>
<li><a href="#データのplot">データのplot</a><ul>
<li><a href="#jupyterの場合">jupyterの場合</a></li>
<li><a href="#pysurfer">pysurfer</a></li>
</ul></li>
<li><a href="#numpyのplot">numpyのplot</a></li>
<li><a href="#多チャンネル抜き出し">多チャンネル抜き出し</a></li>
<li><a href="#センサーレベルwavelet変換">センサーレベルwavelet変換</a><ul>
<li><a href="#そもそもwavelet変換とは何なのか">そもそもwavelet変換とは何なのか</a></li>
<li><a href="#wavelet変換にまつわる臨床的な単語">wavelet変換にまつわる臨床的な単語</a></li>
<li><a href="#つの流儀とmne">2つの流儀とMNE</a></li>
<li><a href="#wavelet変換の実際">wavelet変換の実際</a></li>
</ul></li>
<li><a href="#データの集計について">データの集計について</a></li>
<li><a href="#jupyterでのrとpadasの連携">jupyterでのRとpadasの連携</a></li>
<li><a href="#rでのanovaについて">RでのANOVAについて</a></li>
<li><a href="#connectivity">Connectivity</a><ul>
<li><a href="#fouriermultitaperモード">fourier/multitaperモード</a></li>
<li><a href="#waveletモード">waveletモード</a></li>
<li><a href="#plot">plot</a></li>
<li><a href="#indicesモード">indicesモード</a></li>
</ul></li>
<li><a href="#ソースレベルmeg解析">ソースレベルMEG解析</a><ul>
<li><a href="#掛け算を作る">掛け算を作る</a></li>
<li><a href="#割り算を作る">割り算を作る</a></li>
<li><a href="#その後のストーリー">その後のストーリー</a></li>
<li><a href="#手順0freesurfer">手順0、freesurfer</a></li>
<li><a href="#手順1trans">手順1、trans</a></li>
<li><a href="#手順2bem作成">手順2、BEM作成</a></li>
<li><a href="#手順3ソーススペース作成">手順3、ソーススペース作成</a></li>
<li><a href="#手順4順問題">手順4、順問題</a></li>
<li><a href="#手順5コヴァリアンスマトリックス関連">手順5、コヴァリアンスマトリックス関連</a></li>
<li><a href="#手順6逆問題">手順6、逆問題</a></li>
<li><a href="#手順7-ソース推定">手順7 ソース推定</a></li>
<li><a href="#手順8前半ラベル付け">手順8、前半ラベル付け</a></li>
<li><a href="#手順8後半label当てはめ">手順8後半、label当てはめ</a></li>
<li><a href="#三次元plot">三次元plot</a></li>
<li><a href="#三次元movie">三次元movie</a></li>
<li><a href="#その後のお楽しみ1ソースベースwavelet">その後のお楽しみ1、ソースベースwavelet</a></li>
<li><a href="#その後のお楽しみ2ソースベースconnectivity">その後のお楽しみ2、ソースベースconnectivity</a></li>
</ul></li>
<li><a href="#コラム3-markdownで同人誌を書こう"><em>コラム3-markdownで同人誌を書こう！</em></a></li>
</ul></li>
<li><a href="#理論編">理論編</a><ul>
<li><a href="#初心者のための波形解析">初心者のための波形解析</a><ul>
<li><a href="#波形解析で得たいものと必要な変換">波形解析で得たいものと、必要な変換</a></li>
<li><a href="#フーリエ変換とは">フーリエ変換とは</a></li>
<li><a href="#shorttimeフーリエ変換">ShortTimeフーリエ変換</a></li>
<li><a href="#wavelet変換とは">Wavelet変換とは</a></li>
<li><a href="#ヒルベルト変換">ヒルベルト変換</a></li>
<li><a href="#フーリエ級数">フーリエ級数</a></li>
<li><a href="#複素フーリエ級数">複素フーリエ級数</a></li>
<li><a href="#結局何をしているのか">結局何をしているのか</a></li>
<li><a href="#スペクトル解析">スペクトル解析</a></li>
<li><a href="#そしてwavelet変換へ">そしてwavelet変換へ</a></li>
<li><a href="#wavelet逆変換とbandpass-filter">wavelet逆変換とbandpass filter</a></li>
<li><a href="#morletwaveletとは">MorletWaveletとは</a></li>
<li><a href="#気持ち悪さ対策">気持ち悪さ対策</a></li>
<li><a href="#フーリエ逆変換を使って算出するwavelet">フーリエ逆変換を使って算出するWavelet</a></li>
</ul></li>
<li><a href="#直交wavelet">直交Wavelet</a></li>
<li><a href="#ヒルベルト変換-1">ヒルベルト変換</a><ul>
<li><a href="#複素フーリエ級数とフーリエ逆変換の復習">複素フーリエ級数とフーリエ逆変換の復習</a></li>
<li><a href="#フーリエ変換の負の位相の性質">フーリエ変換の負の位相の性質</a></li>
<li><a href="#相方の波を求める">相方の波を求める</a></li>
<li><a href="#式の形にする">式の形にする</a></li>
<li><a href="#さらに形を整える">さらに形を整える</a></li>
<li><a href="#畳み込み定理">畳み込み定理</a></li>
<li><a href="#よく見るヒルベルト変換の式の導出">よく見るヒルベルト変換の式の導出</a></li>
</ul></li>
<li><a href="#コネクティビティ各論">コネクティビティ各論</a><ul>
<li><a href="#plvとcoherenceの問題点">PLVとCoherenceの問題点</a></li>
</ul></li>
<li><a href="#plvやcoherenceの欠点の克服">PLVやCoherenceの欠点の克服</a><ul>
<li><a href="#拡散する前の電流">拡散する前の電流</a></li>
<li><a href="#plvの発展系">PLVの発展系</a></li>
<li><a href="#coherenceの発展系">Coherenceの発展系</a></li>
<li><a href="#でこういうのってロバストなの">で、こういうのってロバストなの？</a></li>
<li><a href="#グラフ理論">グラフ理論</a></li>
</ul></li>
<li><a href="#ソースベース解析の理屈">ソースベース解析の理屈</a><ul>
<li><a href="#もう一寸ちゃんと">もう一寸ちゃんと</a></li>
<li><a href="#もっと良くする">もっと良くする</a></li>
<li><a href="#白色化">白色化</a></li>
<li><a href="#map推定">MAP推定</a></li>
<li><a href="#dspmの理屈">dSPMの理屈</a></li>
<li><a href="#sloretaの理屈">sLORETAの理屈</a></li>
<li><a href="#eloretaの理屈">eLORETAの理屈</a></li>
<li><a href="#eloretaの実行">eLORETAの実行</a></li>
</ul></li>
<li><a href="#割り算を極める">割り算を極める➗</a><ul>
<li><a href="#鶴亀算とは連立一次方程式である">鶴亀算とは連立一次方程式である🐦🐢</a></li>
<li><a href="#連立一次方程式とは行列の割り算である">連立一次方程式とは行列の割り算である➗</a></li>
<li><a href="#鶴亀算の高級な解き方">鶴亀算の高級な解き方🚗</a></li>
<li><a href="#実装python">実装(python🐍)</a></li>
<li><a href="#鶴亀てんとう虫算">鶴亀てんとう虫算🐤🐢🐞</a></li>
<li><a href="#無限個の解とその解決策">無限個の解とその解決策∞</a></li>
<li><a href="#逆行列は作れないこともある">逆行列は作れないこともある🐍</a></li>
<li><a href="#疑似逆行列">疑似逆行列👻</a></li>
</ul></li>
<li><a href="#ここまでで学んだ割り算の応用">ここまでで学んだ割り算の応用✏</a><ul>
<li><a href="#具体的な応用-多変量解析入門">具体的な応用 多変量解析入門</a></li>
<li><a href="#まとめ">まとめ</a></li>
<li><a href="#さいごに">さいごに</a></li>
</ul></li>
</ul></li>
<li><a href="#補講">補講</a><ul>
<li><a href="#pythonでの高速化のあれこれ">pythonでの高速化のあれこれ</a><ul>
<li><a href="#for文とリスト内包表記とmap">for文とリスト内包表記とmap</a></li>
<li><a href="#numpy独自のメソッドを実装するときとか">numpy(独自のメソッドを実装するときとか)</a></li>
<li><a href="#並列化これがやりたかった">並列化(これがやりたかった！)</a></li>
<li><a href="#openmpのオーバーヘッド対策">OPENMPのオーバーヘッド対策</a></li>
<li><a href="#mnepythonの並列化">MNEpythonの並列化</a></li>
<li><a href="#graph">graph</a></li>
</ul></li>
<li><a href="#おすすめの参考書">おすすめの参考書</a></li>
<li><a href="#おすすめサイト">おすすめサイト</a></li>
<li><a href="#おすすめsns">おすすめSNS</a></li>
<li><a href="#おすすめソフト">おすすめソフト</a></li>
<li><a href="#mnepython実装時の小技">MNEpython実装時の小技</a><ul>
<li><a href="#メソッドチェーン">メソッド・チェーン</a></li>
<li><a href="#変数を減らしてみる">変数を減らしてみる</a></li>
<li><a href="#mneのapi引数多すぎだろ死ね">MNEのAPI引数多すぎだろ死ね！</a></li>
<li><a href="#ここまでのまとめ">ここまでのまとめ</a></li>
<li><a href="#解析失敗したやつをスキップしたいんだが">解析失敗したやつをスキップしたいんだが</a></li>
<li><a href="#file名じゃなくてフォルダ名が欲しいん">file名じゃなくてフォルダ名が欲しいん</a></li>
</ul></li>
</ul></li>
<li><a href="#あとがきとお願い">あとがきとお願い</a><ul>
<li><a href="#令和2年2月時点のあとがきだ">令和2年2月時点のあとがきだ</a></li>
<li><a href="#令和3年5月時点のあとがきだ">令和3年5月時点のあとがきだ</a></li>
<li><a href="#令和5年6月時点のあとがき">令和5年6月時点のあとがき</a></li>
</ul></li>
</ul>
</nav>

<h1 id="紹介編">紹介編</h1>
<p>紹介編ではこれから何をしていくのか、何が出来るのかを語ります。<br />
まぁ、適当です。</p>
<h2 id="本書の構成">本書の構成</h2>
<ul>
<li>紹介編</li>
<li>実験編</li>
<li>導入編</li>
<li>解析編</li>
<li>理論編</li>
<li>補講</li>
</ul>
<h2 id="はじめに">はじめに</h2>
<p>現代では脳は電気で動いている、と信じられています。<br />
しかし、どのような挙動なのかはまだまだ分かっていません。<br />
だから、貴方は研究をしたくなります。(それは火を見るより明らかです)<br />
しかし、脳の解析は難しく、技術的な入門書、特に和書に乏しい現状があります。<br />
だから同人誌を書くことにしました。<br />
本書では脳磁図、脳波、MRI解析を「体で覚える」べく実践していきます。<br />
さぁ、MNE/python、freesurferの世界で良い生活を送りましょう！</p>
<h2 id="本書の目的限界対象者使い方">本書の目的・限界・対象者・使い方</h2>
<p>MNE/python<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>やfreesurfer<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>を用いて脳内の電源推定…特にソースベース解析を行うための<br />
解析環境の構築と解析の基礎を概説します。可能な限り効率的な解析環境を構築し、楽をします。<br />
僕が個人的に考えている事もちょくちょく書きます。<br />
僕は脳波計も脳磁計も使用経験があるのですが、脳磁計はレアです。<br />
僕はelekta社のMEGを使っていたので脳磁計はelekta前提で書きますが、<br />
MNE-pythonは大抵の脳波計に対応しているので、<br />
実験用脳波計さえあればなんとかなるでしょう。</p>
<p>本書の限界は僕のリソース不足<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>と、これが同人誌であること、<br />
MNE自体の進化のスピードが光の速さであることです。<br />
不確実なものとして、疑って読んで下さい。<br />
この同人誌は不完全なため、更新があります。<br />
内容は結構多いので、辞書的に使うのもいいでしょう。</p>
<p>本書の対象者は以下のとおりです</p>
<ul>
<li>脳波/脳磁図計を使って研究をしたい初心者</li>
<li>脳磁図計を使って研究しているけれど、コーディングが苦手な中級者</li>
<li>頭部MRI研究でfreesurferを使いたい初心者</li>
</ul>
<p>また、前提条件としてターミナルやプログラミングを怖がらないことがあります。<br />
黒い画面を見たら怯える君！君は本書の対象外だから出ていきなさい！<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a><br />
黒い画面を触ったことないけど、やる気はある君！君は歓迎します。<br />
プログラミング未経験者の質問にも出来るだけ答えたいと思います。</p>
<p>脳研究の経験者は<a href="#MNEpythonとは">MNE/pythonとは</a>から読んでいけばいいです。<br />
MNE/freesurfer経験者なら<a href="#OSの準備">OSの準備</a>から読めばいいです。<br />
コンピュータは自転車みたいなもので、基本は体で覚えていくしかないと思っています。<br />
分からなければググることが大事です。qiita<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>等で検索するのも良いでしょう。</p>
<h2 id="センサーベースソースベース解析とはなんぞや">センサーベース/ソースベース解析とはなんぞや</h2>
<p>脳の中の電気信号を調べる方法としては脳波や脳磁図<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>が有名です。<br />
脳波や脳磁図のセンサーで捉えた信号を直接解析する方法を<br />
センサーレベルの解析と言います。これは伝統的なやり方であり、<br />
今でも多くの論文がこの方法で出ている確実な方法です。</p>
<p>しかし、脳波や脳磁図は頭蓋骨を外して直接電極をつけないと<br />
発生源(僕達はソースと呼びます)での電気活動はわかりません<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>。<br />
普段計測している脳波・脳磁図は所詮は<br />
「神経から頭蓋骨を通り抜けて漏れでた信号」に過ぎないのです。<br />
では、一体どうすれば脳内の電気信号を非侵襲的に観察できるのでしょうか？<br />
方法は残念ながら<strong>ない</strong><a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>のですが、推定する方法ならあります。<br />
その中の一つの方法として、脳磁図とMRIを組み合わせ、<br />
MNEというpythonパッケージを使って自ら解析用スクリプトを実装する方法があります。<br />
ソースベース解析というのはあくまで推定であり、<br />
先進的である一方でまだまだ確実性には劣るやり方との指摘もあります。</p>
<p>ちなみに、脳波のソースベース解析はあるにはあるのですが、<br />
脳波は電流であるため磁力と違って抵抗を避けて流れます。<br />
実際、脳波でのソースベース解析とセンサーベース解析の結果が<br />
不一致であったという研究が発表されています。<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a><br />
脳波でやるならば、40チャンネル以上の脳波計を用意しましょう！<br />
まぁ、後述しますが、脳波と脳磁計じゃ他にも得意分野の違いがあります。</p>
<h2 id="スラングや用語の説明とunix系のお約束">スラングや用語の説明とunix系のお約束</h2>
<p>本書では下記の言葉を使っています。伝統的なスラングを含みます。<br />
適宜読み替えていってください。それ以外にも色々スラングあるかもです…。<br />
何故スラングをそのまま書いているかって？<br />
お前は同人誌にまで正しい日本語を求めるのですか？そういう人は回れ右。<br />
僕は怖いおじさんなのです。</p>
<ul>
<li>hoge:貴方の環境に応じて読み替えてください、という意味のスラング<br />
fuga,piyoも同じ意味です。ちなみにこれは<strong>日本語</strong>です。<br />
英語が好きな方はfooとかbarとかになりますね。</li>
<li>叩く:(コマンドをターミナルから)実行するという意味の他動詞</li>
<li>回す、走らせる:重い処理を実行するという意味の他動詞</li>
<li>ターミナル:いわゆる「黒い画面」のこと。Macならユーティリティフォルダにある。</li>
<li>.bash_profile:ホームディレクトリにある隠し設定ファイルです。<br />
環境によって.bashrcだったりしますし、両方あることもあります。<br />
貴方の環境でどちらが動いているか(両方のこともある)確認して設定してください。</li>
<li>実装:プログラミングのことです。プログラムを書くことです。</li>
</ul>
<p>本書で「インストールにはこうします」とか言ってコマンドを示した場合は<br />
文脈上特に何もない場合、ターミナルでそれを叩いてくださいという意味です。<br />
pythonの文脈になったらpythonです。この辺りは見慣れれば判別できます。</p>
<h2 id="それぞれの研究に必要な環境特色のまとめ">それぞれの研究に必要な環境・特色のまとめ</h2>
<p>それぞれの研究の、僕の感想を述べます。</p>
<h3 id="脳波センサーレベル研究">脳波センサーレベル研究</h3>
<ul>
<li>時間解像度: ミリ秒単位</li>
<li>空間解像度: 10cm単位</li>
<li>見ているもの: 神経活動</li>
<li>必要物品: MNE-python</li>
</ul>
<p>安価で普及していますが、まだ多くの謎が眠っている分野です。<br />
脳回や深部の信号に強いですが、脳脊髄液や頭蓋骨を伝わって行くうちに<br />
信号が拡散してしまうため、空間分解能が低いです。<br />
ポータブル脳波計とかあって、BMIとか出来る夢のある分野ですね。</p>
<h3 id="megセンサーレベル研究">MEGセンサーレベル研究</h3>
<ul>
<li>時間解像度: ミリ秒単位</li>
<li>空間解像度: cm単位</li>
<li>見ているもの: 神経活動</li>
<li>必要物品: MNE-python</li>
</ul>
<p>ノイズに弱く、脳の深部に弱く、莫大な資金が必要な希少な機器です。<br />
ソース推定しないならあまり面白みはないかな。<br />
まず、脳波と違って脳溝・浅い部分をよく見れるという特徴があります。</p>
<h3 id="mri研究">MRI研究</h3>
<ul>
<li>時間解像度: 分単位</li>
<li>空間解像度: mm単位</li>
<li>見ているもの: 血流や水分</li>
<li>必要物品: freesurfer、mricrogl</li>
</ul>
<p>脳内の水分子に磁場を与えて画像化する凄い機械です。<br />
画像なのでゆるふわかと思いきや、量子力学の知識を要求します。<br />
莫大な資金が必要ですが、それなりに普及しています。<br />
血流を見ることが出来るので「脳機能」というか<br />
「血が流れているから働いてるんじゃね？」的な事も大まかに見れます。<br />
ネタが尽きようとも、新たな理論を持ち出してくる根性の分野です。</p>
<h3 id="megmriソースレベル研究">MEG+MRIソースレベル研究</h3>
<ul>
<li>時間解像度: ミリ秒単位</li>
<li>空間解像度: 1~数cm単位</li>
<li>見ているもの: 神経活動</li>
</ul>
<p>MEGとMRIを組み合わせて脳の電気活動を見るやつです。<br />
本書の本題です。MRIの空間分解能と脳磁図の時間分解能を備えた<br />
まさに <strong>†最強の解析†</strong> …のはずなんですが、どうなんでしょうね？<br />
脳波の場合はそこまで空間分解能は高くないっす。モワッとしてます。<br />
脳磁計を使った場合は空間分解能と時間分解能が合わさり、なかなか凄いです。</p>
<h3 id="eegmri同時計測研究">EEG/MRI同時計測研究</h3>
<ul>
<li>時間解像度: ミリ秒単位</li>
<li>空間解像度: 数cm単位</li>
<li>見ているもの: 神経活動</li>
</ul>
<p>EEGとMRIを同時に計測するという究極の方法です。<br />
ただし、MRIのノイズは凄まじく、ノイズを取るのが困難です。<br />
専門家でなくては施行できず、本書では取り扱いません。</p>
<h2 id="mne-pythonとは">MNE-pythonとは</h2>
<p>脳磁図を解析するためのpython<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a>用numpy,scipyベースのパッケージです。<br />
自由度が非常に高いです。(引き換えに難易度が高いです。)<br />
ソース推定をするためのパッケージなのですが、<br />
Wavelet変換とかICAとかPermutation検定とか、その他あらゆる事が出来ます。<br />
出来るのですが…使いこなすためには生理学、数学、工学の知識が必要です。<br />
ちなみに元来脳磁図用なのですが、脳波を解析することも出来ます。<br />
というか、脳磁計なんて値段がおかしい割に使い道が狭いので、実質脳波用。<br />
C言語で実装されたMNE/Cというのもありますが、古いバージョンと考えていいです。<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a><br />
開発は活発で、最近新バージョンは<a href="http://martinos.org/mne/stable/index.html">MNE/python 0.16.1</a>です。<br />
freesurferは<a href="https://surfer.nmr.mgh.harvard.edu/">6.0</a>が、pythonはpython3.9が最新です。<br />
導入と紹介を書いていこうと思います。<br />
python2はマジでオワコンなので特別な理由がない限り使わないように。いいね？</p>
<figure>
<img src="img/wavelet.png" alt="wavelet変換の出力例" style="width:14cm" /><figcaption>wavelet変換の出力例</figcaption>
</figure>
<h2 id="freesurferとは">freesurferとは</h2>
<p>頭部MRIを解析する為のソフトです。自動で皮質の厚さやボリュームを測れるだけでなく最近は<br />
fMRIでコネクティビティの算出が出来るようになるなど、かなり賢いです。特に厚さに強いです。<br />
反面、計算激重な上にサイズが大きくターミナル使う必要があります。<br />
Unix系OSじゃないと動きません。<br />
その上、違うCPU使ったら結果が変わる仕様があり、正しく扱わないとジャジャ馬と化します。<br />
最近頭部MRI研究で勢力を伸ばしつつあり、最早スタンダードの一つだそうです。フリーウェアです。</p>

<h2 id="それぞれのソフトの関係性それofficeに例えるとどうなの">それぞれのソフトの関係性〜それofficeに例えるとどうなの？〜</h2>
<p>実は、以前人に教えようとした時、<br />
いきなりMNEpythonと言われても初心者にはよくわからないと言われました。<br />
unix系もコンピュータ言語も触ったことない人には例え話のほうが良いかもしれないので、<br />
初心者のために、登場するソフトの名前を例え話で話してみます。<br />
凄く乱暴な例えではあります。</p>
<table>
<thead>
<tr class="header">
<th>MNE</th>
<th>役割</th>
<th>オフィスに例えると？</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>anaconda,pip,homebrew</td>
<td>ソフトをインストールするソフト</td>
<td>app store, google play, 人事部</td>
</tr>
<tr class="even">
<td>spyder,jupyter</td>
<td>実際に色々書いたりするソフト</td>
<td>word, excel, 筆記用具</td>
</tr>
<tr class="odd">
<td>python</td>
<td>言語</td>
<td>日本語, 命令書の書式, 社内文書</td>
</tr>
<tr class="even">
<td>MNE</td>
<td>言語で動く命令セット</td>
<td>excelの関数, 社内文書に従って動く部下</td>
</tr>
<tr class="odd">
<td>mricron/mricrogl</td>
<td>変換・表示用ソフト</td>
<td>画像変換ソフト, 通訳</td>
</tr>
<tr class="even">
<td>freefurfer/freeview</td>
<td>MRI画像処理ソフト</td>
<td>Photoshop, 絵の具, MNEと違う部署の部下</td>
</tr>
</tbody>
</table>

<h2 id="脳の研究">脳の研究</h2>
<p>君は、ここまで読んで「何やら難しそうだが、それで何かできるん？」<br />
と思ったかも知れない。なので、ここで超簡単なレビューを書いてみます。<br />
僕は精神病の脳の生理学が専門なので、精神病の誘発γ波についてすごーく簡単に書いてみます。<br />
もちろん、他にもMMNとかrestingとか色々あるんですが、とりあえず雰囲気だけね。<br />
参考になれば。</p>
<h3 id="γオシレーション">γオシレーション</h3>
<p>脳には実際に演算をする装置である灰白質と、演算結果を伝える白質という部分があって、<br />
脳の表が灰白質、内側が白質であります。で、今回は灰白質の方を見たいと思います。<br />
理由ですか？脳の電気活動を見るときは表面のほうが見やすいのです！<br />
で、γ波(30Hz以上)を見ます。<br />
理由ですか？皮質活動で発生する波はγだからです！<br />
このγ波の事をカッコつけてγオシレーションとか言ったりします。</p>
<h3 id="何故皮質はγなん">何故皮質はγなん？</h3>
<p>脳内には以下の細胞があるのです。</p>
<ul>
<li>興奮性の神経細胞(錐体細胞)</li>
<li>抑制性の神経細胞(介在細胞)</li>
</ul>
<p>興奮性のやつはグルタミン酸[^ajinomoto]を放出するし、抑制性のやつはGABAを放出します。<br />
興奮細胞と抑制細胞は互いに接続しています。<br />
図に示すと、下記の様な感じです。<br />
で、細胞の興奮というのは一度「ピコーン！」と興奮すると暫く休む性質があります。<br />
暫く休む性質があるために、神経細胞は興奮の頻度が決まってきます。<br />
そのピコピコ神経細胞が興奮する速度がだいたい30Hz以上ってわけです。</p>
<p><img src="img/nuron.png" alt="γ波のしくみ" /><br />
![^ajinomoto]: これは味の素です！</p>
<h3 id="どんな事をする">どんな事をする？</h3>
<p>統合失調症を見てみましょう。理由ですか？<br />
その分野はいっぱい研究されてて同人誌を書くのに都合が良いからです！</p>
<p>さて、顕微鏡を使った研究があります。<br />
- 聴覚野(脳において聴覚を司る部位)の錐体細胞に異常がある<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a><br />
- 軸索(神経細胞から伸びる枝)の密度が低い<a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a><br />
等が統合失調症で報告されています。</p>
<p>実際は神経の密度とかより先にγ波のおかしさのほうが発見されたんです。<br />
そして、この神経細胞の異常がγ波のおかしさの原因だろうと言われています。</p>
<h3 id="じゃあ統合失調症にどんな異常があるって">じゃあ統合失調症にどんな異常があるって？</h3>
<p>挙げるの？数限りないぞ！</p>
<ul>
<li>計算中に前頭葉のγ振動が減弱している<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a></li>
<li>特定の模様を見せた時のγ振動が健常者と違う<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a></li>
<li>40Hzの音を聞かせた時のγ波が減弱している<a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a></li>
</ul>
<p>面倒だからもう書かないけど、実は凄くいっぱいある。<a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a></p>
<p>で、先のリストを見て君はあることに気づいたはずだ。γ波は誘発できる。<br />
って事は、いろんな刺激をして、その刺激中の脳波を見れば<br />
それで論文書けるんじゃねえの？ヒャッホウ！博士号ゲットだぜ！<br />
(言うほど簡単じゃないけどな…)</p>
<p>というわけで、顕微鏡を見るだけが能じゃなくて、<br />
生きている人間の脳活動を直に見ることが出来るということです。</p>
<h3 id="診断ツール">診断ツール</h3>
<p>さて、40Hzの音を聞かせた時に40Hzの脳波が出るとか、結構ずるい感じがしますが、<br />
不思議なことにもっと低い周波数ではあまり差が出なかったり、<br />
健常者やうつ病では差が出なかったり<a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a>と、確かにそういうのあるらしい。<br />
おっ、統合失調症と鬱を分けられる…って思うじゃん？<br />
躁鬱病でも差が出るらしい<a href="#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a>。チッ、特異的じゃないじゃん。<br />
でもまぁ、医者<a href="#fn21" class="footnote-ref" id="fnref21"><sup>21</sup></a>としては考える材料が増えるのは嬉しいんですよね。</p>
<h3 id="つまり">つまり？</h3>
<p>ま、そういう風な分野のことが出来ます。<br />
他にも色々出来るでしょうね。</p>

<h1 id="実験編">実験編</h1>
<h2 id="実験をしよう">実験をしよう！</h2>
<p>では、実験について色々書こうと思います。<br />
研究するならもちろん厳密な実験が良いに決まっています。<br />
というか、最低限の実験の綺麗さを担保しなければ成立しません。<br />
しかし、実験というものは苦しみに満ちています。<br />
実験を立ち上げる時に考慮すべき苦しみを<br />
出来れば対処法とともに順不同で列挙します。<br />
言い過ぎに見える所もあるかも知れませんが、マジで苦しみに満ちています。</p>
<p>君は生き残ることができるか？</p>
<h3 id="被験者の非協力の苦しみ">被験者の非協力の苦しみ</h3>
<p>被験者が実験に参加しているのは当たり前だと思われるでしょうが、<br />
そんなことはないです。<br />
「目をつぶって音を聞く実験」に参加した被験者が<br />
居眠りをしていないと誰が言えましょうか？<br />
「画像をみる実験」でちゃんと画像を見ていると保証できますか？<br />
まずは、その辺りをちゃんと説明して、協力できないと駄目です。<br />
そのあたりの協力関係を築く事がとても大事です。</p>
<p>「は？そんな事が問題になる事があるのか？」って<br />
貴方はなったかも知れませんが、あるんだなこれが。</p>
<h3 id="外来のノイズの苦しみ">外来のノイズの苦しみ</h3>
<p>MEGもEEGもノイズに弱いです。</p>
<p>どこからノイズが飛んできているのかちっともわからないことがあります。<br />
Wifiが電子レンジに弱いなんてやわなもんじゃない。<br />
もっと深刻なものを体験できます。<br />
そんな時はEEG用のシールドルームを用いますが…<br />
シールドによって得意なノイズが違っていたり、<br />
シールドルーム自体がやはり高額だったりします。</p>
<p>EEGに比べてMEGだと自体は深刻です。<br />
地球の核から飛んでくる磁場は人間の頭から放出される磁場の1000倍程度。<br />
シールドルームは必須です。<br />
近くに地下鉄が通っているとそこから出る強力な磁場は<br />
シールドを一部貫通します。</p>
<p>当然のことながら、MEGのシールドルームに<br />
視覚刺激提示用の画面を置くと物凄いノイズが乗って酷くなります。<br />
視覚実験苦しい！<br />
ノイズの出にくい画面というのがあるのですが、これがまたお高いです。<br />
というか、ノイズの出にくい画面からもノイズでます！<br />
音の場合はMEGの部屋の外からパイプで伝える事でなんとかなりはします。</p>
<p>あと、単に金属が近くにあるだけでノイズになったりします。<br />
ベルトは外して貰いましょう。<br />
メガネは視覚実験の場合は検討が必要ですので後述します。</p>
<p>色々外しますが、どうあがいても銀歯はとれません。<br />
この場合、金属に強力な磁場を当てることでノイズを散らす方法も<br />
MEGの場合にはあるのですが、どちらにしろ辛いです。</p>
<h3 id="体の動きによる苦しみ">体の動きによる苦しみ</h3>
<p>被験者は、実験以上に拘束時間が長いです。<br />
なぜかって？EEGやMEGを装着する時間はそれなりに掛かるからです。<br />
お爺さんとかなら「腰が痛い、動いていいかの？」ってなりますよね。<br />
体が動くと、ものすごいノイズになります。<br />
被験者に耐えられるような実験を組まねばなりません。</p>
<h3 id="眼球による苦しみ">眼球による苦しみ</h3>
<p>眼球が動くと脳波・脳磁図に大きな影響が出ます。<br />
眼球運動のノイズは脳波などよりずっと大きいです。<br />
眼球自体が強く帯電していて、目自体が結構ピクピク動くからです。<br />
本来は、瞼なんか全部切り取って、片目を潰して、<br />
眼球運動の筋肉を全て切除して、視神経の一部も一部切除したいくらいです。<a href="#fn22" class="footnote-ref" id="fnref22"><sup>22</sup></a></p>
<p>ほぼ全ての脳波・脳磁図実験に於いて眼球運動は大敵です。<br />
実はそれをソフトウェアによって取り除くことは出来るのですが、<br />
そもそもノイズいっぱいのデータは良くないです。<br />
データは確実に劣化するでしょう。</p>
<p>被験者には出来るだけ視線を動かさないように教示しましょう。<br />
あとはfixationを使う方法があります。<br />
fixationは「実験中はここを注目しておいてね！」という小さな印です。<br />
色んな実験の前に、そこに視点を合わせておいて、消してから刺激提示です。<br />
問題点としては、その印自体が脳に影響するかもということ、<br />
本当にそれを見ているかも保証できない事、<br />
視覚実験の最中は出来ないこと…つまり、端的に言うとショボいです。<br />
しかし、デメリットの少ない方法で有力なので、よく使われる方法ですね。</p>
<h3 id="視覚実験の苦しみ視線">視覚実験の苦しみ(視線)</h3>
<p>貴方は被検者さんに画像とかを見せることになりますが<br />
貴方の提示した画面を被験者さんは本当に見ているでしょうか？<br />
見ているとして、本当に真正面から見ているんでしょうか？<br />
視野が少しでもずれたら大きく結果が変わるんじゃないかと厳しい人は言います。<a href="#fn23" class="footnote-ref" id="fnref23"><sup>23</sup></a><br />
視覚実験の場合は眼球運動に加えて<br />
「この人はちゃんと画像を見ているのか」が問題になります。<br />
サボって目を閉じて眠っているかも知れない。<br />
刺激が眩しかったり、嫌な画像から目をそらすかも知れない。<br />
そこで、下記の二つが有力な方法です。</p>
<ul>
<li>Web Camera</li>
<li>Eye Tracker</li>
</ul>
<p>Web Cameraは要するにWeb Cameraで被験者の顔を観察して、<br />
目で見て「お前目をそらしただろ！不合格！」と判定するやり方です。<br />
しかし、どうでしょうか？「貴方はWeb Camera越しにその人の見ている物が<br />
分かるのですか？恣意的な要素が入っていませんか？」<br />
というツッコミが来たらの終わりです。要するにショボいです。</p>
<p>もう一つは眼球運動を監視する為の専用のカメラで眼球を監視して、<br />
ちゃんと使えるデータだけ使うというやり方です。<br />
なんと、こいつぁショボくないのです！やったね！<br />
トビーとかが販売していますが、実験用は値段が高いです。</p>
<h3 id="視覚実験の苦しみメガネ">視覚実験の苦しみ(メガネ)</h3>
<p>もちろんですが、目の悪い人は視覚実験は辛いです。<br />
メガネをつける事になりますが、MEGの場合は眼鏡の金具が<br />
ノイズ源になりますので、木のメガネをかけさせてあげる必要があります。<br />
EEGの場合はそこまで酷くはないですが、それでも金属は帯電するので<br />
気にはなりますね。<br />
Eye Trackerを併用する時にメガネって気になりませんか？</p>
<h3 id="視覚実験の苦しみ画面との距離">視覚実験の苦しみ(画面との距離)</h3>
<p>下記を気にする必要があります。</p>
<ul>
<li>画面の大きさ</li>
<li>画面からの距離</li>
<li>画面の明るさ</li>
<li>画面のディレイ</li>
<li>画面のジッター</li>
</ul>
<p>前半3つは巻き尺とかを駆使する必要があります。<br />
後半二つは光センサー等を駆使する必要があります。<br />
あとでオシロスコープを使ってそれらを測定する方法を書きます。</p>
<h3 id="mri同時計測の苦しみ">MRI同時計測の苦しみ</h3>
<p>MRIと脳波の同時測定ですか？<br />
そりゃ、やっている人は居るけれど、本書の著者には無理です。<br />
MRIの磁力と人間の脳から出る磁力は、だいたい10の15乗以上の差があります。<br />
MRIの部屋は磁気カードは壊れるし、ボールペンは空を舞う世界です。<br />
そんな酷い環境で脳波を測定するのは…まさに深淵です。<br />
専門知識が必要です。</p>
<h3 id="聴覚実験の苦しみ">聴覚実験の苦しみ</h3>
<p>まず初めに、辛いことを言います。<strong>ヘッドホンではダメです。</strong></p>
<p>聴覚実験の場合、音の大きさが重要になるからです。<br />
音の大きさは音圧計という機械で測ります。<br />
音の大きさが不揃いだと実験になりませんが、<br />
音は反射したり、干渉したりする性質があることはご存知でしょう。<br />
そして、耳の形は人によって全然違います！<br />
ヘッドホンを付けたときのズレも毎回変わります！</p>
<p>耳の形やズレを無視できるデバイスが求められますね。<br />
耳の中に入れるタイプのインサートイヤホンが最適解です。<br />
インサートイヤホンの先っぽを鼓膜の所まで差し込むのです。<br />
これならズレとか耳の形には関係ないですね！</p>
<p>それから、音の大きさはきちんと測っておく必要があります。<br />
音圧計でインサートイヤホンから出る音の大きさを<br />
測定する必要があります。</p>
<p>インサートイヤホンはビニールのケーブルで音を伝えるのですが、<br />
でもインサートイヤホンってゴムのチューブみたいなもので出来ています。<br />
つまり、途中がビヨンビヨンです。<br />
なんと、このケーブルを通すことで音が劣化するのです！</p>
<p>さらに、イヤホンから出た音の大きさを、耳の中と同じ条件で<br />
測ることって出来るでしょうか？これ、超絶難しい問題です。<br />
耳の中にインサートイヤホンとマイクを一緒に入れるなんて出来ません。</p>
<p>実は無理じゃないらしいんですが、かなり値の張る音圧測定器が<br />
必要になります。<br />
この世は苦しみに満ちています。</p>
<h3 id="resting実験の苦しみ">Resting実験の苦しみ</h3>
<p>何も刺激をせずにすればいいじゃないかとなりそうですが、<br />
これもこれで色々考える所があります。<br />
まず、MRIのRestingはRestingじゃないと僕は思っています。<br />
(MRIのResting研究の人にブチ殺される発言)<br />
MRIなんか、ガンガン音がするんだから絶対純粋なrestingじゃないですよね…<br />
閉所恐怖症の人なら変な感じの脳活動が出てるかも知れません。</p>
<p>なら、脳波って結構Resting出来るんじゃね？って思いますよね？<br />
ですが、問います。貴方は心を無にすることが出来ますか？<br />
脳波をつけられて、何も考えるなと言われてじっとしている時、<br />
貴方は今日の献立や彼氏との喧嘩が頭に浮かんだりしているかもしれない。<br />
「いけないわ！私は今、彼氏との喧嘩を思い出しちゃいけない！」<br />
そう必死になって心を「無」にしようと足掻く。<br />
その時に出ている脳波は「無」ではなく「足掻く」脳波かも知れない。</p>
<p>ま、それは実験的には仕方ないのですけれども、<br />
気に留める必要はあるのではないでしょうか？</p>
<h3 id="汗と凍えの苦しみ">汗と凍えの苦しみ</h3>
<p>汗はノイズになります。震えもノイズになります。<br />
空調がちゃんとなっていないと難しいのです。<br />
それだけではなく、湿度の管理も大事ですね。</p>
<p>というわけで、温度と湿度の管理をしましょう！</p>
<h3 id="震えの問題の苦しみ">震えの問題の苦しみ</h3>
<p>パーキンソン病の人の実験をする場合、<br />
体が震えるため、脳波が揺れ動くように見えることがあります。<br />
そんなの止めることはできないので<br />
この手の人は限界がありますね。</p>
<h3 id="ハゲの苦しみ">ハゲの苦しみ</h3>
<p>ハゲは脳波用のゲルが流れていきやすい性質があります。<br />
それによって、脳波計によっては短絡のリスクがつきまといます。<br />
さらに、ハゲ頭は皮が分厚いです。<br />
だから、電流が通りにくいです。脳波的には不利です。<br />
キャップ型とかだと中々しんどいです。</p>
<h3 id="デブと心電図の苦しみ">デブと心電図の苦しみ</h3>
<p>デブは首もデブです。<br />
心臓は心電図が出ますが、首が細ければ＋とーがぶつかりあってノイズが消えます。<br />
デブの場合は心電図のノイズが消えないのです！<br />
心電図はソフトウェアによってあとで取り除くことは出来ますが、<br />
それでもノイズが入ること自体が罪です。</p>
<h3 id="青筋の苦しみ">青筋の苦しみ</h3>
<p>頭の血管もまた、脈打ちます。<br />
この、血管にセンサーがちょうど当たったらノイズになります。<br />
この脈波は心電図に比べてソフトで外しにくいです。</p>
<h3 id="青二才と老人の苦しみ">青二才と老人の苦しみ</h3>
<p>歳をとると脳波は変化します。若い人も脳波が幼いです。<br />
20歳とかでも幼い脳波が出る人は居るし、歳をとるだけで<br />
脳波のα波は遅くなります。<br />
だから、実験の時点で年齢をある程度合わせねばなりません。<br />
永遠の18歳？関係ないね！</p>
<h3 id="苦しすぎて死にたくなった">苦しすぎて死にたくなった?</h3>
<p>確かに全部致命的だけれど避けにくいのはある。<br />
そういうのがあるって事を理解した上で、説得力を出すことが大事なんだよ。</p>
<p><del>厳格すぎる実験で結果が出ても</del><br />
<del>そんな厳格な実験でしか出ない結果なんて微々たる差だし臨床応用できなくね？</del></p>
<p>私からは以上です。</p>

<h2 id="実験のディレイの測定">実験のディレイの測定</h2>
<p>被験者に何かを見せたり聞かせたりしてその反応を脳波や脳磁図で拾ってくる実験をしたいとします。<br />
脳はかなりの性能なので、30ms後には反応が始まります。<br />
さて…ここで困ったことが起こります。実はコンピュータから画面やスピーカへ信号を送る時、<br />
一瞬で届いてくれないことがあります。理由は、現代的なコンピュータは様々なタスクを<br />
同時進行でやっていたり、性能を確保するために様々な工夫をしますが、それが仇になるのです。<br />
実験中に他の処理が割って入ってきたり、刺激に沢山の演算が必要だったりして<br />
時間を取られたりすると信号が一瞬で届きません。<br />
なので、どのくらいの時間で出来るかを測定しておく必要があります。</p>
<p>ここでは僕がどうやったかを書いておきます。<br />
僕がやったのは被験者の目の前の画面に図が表示されるまでと、<br />
「画面提示」の信号が脳磁図計に届くまでの差を調べることです。</p>
<h3 id="必要物品">必要物品</h3>
<ul>
<li><p>オシロスコープ本体<br />
picoscope2000というのを使いました。windowsで動きます。かなり可愛いオシロスコープですが、<br />
入力2チャンネル、トリガー出力1チャンネル、μs単位の反応速度を持っています。<br />
25000円くらいですが、家電量販店には売ってないです。</p></li>
<li><p>センサー<br />
これは明るくなると抵抗が減るダイオードです。<br />
光センサがRPM22PBで200円くらいです。amazonで買ったあと品切れになりました。<br />
今買うならRPT-37PB3Fのほうが在庫が多そうです。頑張って探しましょう。<br />
スペック上10μs前後の反応速度のようです。</p></li>
<li><p>乾電池<br />
上記センサは5Vくらいの電圧では全然問題ないため、<br />
乾電池二本直列程度なら回路の途中に抵抗は要らないようでした。<br />
ていうか、2本じゃ足りないかも。3本あったがいいかも。<br />
この辺りは、スペック表とにらめっこして下さい。</p></li>
<li><p>ヒートシュリンクチューブ<br />
ドライヤーを当てると縮むチューブです。<br />
光センサーが壊れたら嫌なのでヒートシュリンクチューブで守りました。</p></li>
</ul>
<p>あとはジャンパー線、鰐口クリップ付BNC同軸ケーブル、<br />
半田と半田ごて、電池入れが必要でした。BNC同軸ケーブル周りはやや入手難度が高かった印象です。</p>
<p>どのようにしたかというと、光センサーを電池につなげてオシロスコープに繋ぎます。<br />
オシロスコープには2つの入力チャンネルがあるので、もう一方を刺激提示用コンピュータに繋ぎます。<br />
さらに、ディレイ測定用コンピュータにも繋ぎます。<br />
それで、刺激提示させた刺激を光センサーで捉え、差分を測定用コンピュータで受け取ります。</p>
<p>図にするとこうでしょうか…</p>
<p>もちろん、聴覚実験のときはまた違うと思います。<br />
先輩と協力して聴覚実験のディレイを測ったときは、<br />
直接イヤホンジャックからの信号をオシロスコープにブチ込んで測りました。<br />
音の種類にもよりますが、聴覚実験の方が少し簡単かもです？</p>
<figure>
<img src="img/diag.png" alt="オシロスコープ図" style="width:14cm" /><figcaption>オシロスコープ図</figcaption>
</figure>
<figure>
<img src="img/photo.jpg" alt="光センサー＋オシロスコープセット。総額3万円くらいしました。半田ごてを使わないといけないので、やけどに注意する必要があります。手前の小さな箱がオシロスコープ、左にあるのが電池、オシロスコープと電池の間にあるのが光センサーを回路にはんだ付けしたものをヒートシュリンクチューブで保護したもの、奥にあるのはコンピュータです。" style="width:14cm" /><figcaption>光センサー＋オシロスコープセット。総額3万円くらいしました。半田ごてを使わないといけないので、やけどに注意する必要があります。手前の小さな箱がオシロスコープ、左にあるのが電池、オシロスコープと電池の間にあるのが光センサーを回路にはんだ付けしたものをヒートシュリンクチューブで保護したもの、奥にあるのはコンピュータです。</figcaption>
</figure>

<h3 id="mriと脳磁計の準備">MRIと脳磁計の準備</h3>
<p>必要ですが　<strong>†億単位の金†</strong>　が必要なので本書では割愛します。<br />
読者の中で個人的に買える人が居るなら買うと良いんじゃないかな。</p>
<h3 id="脳波計の準備">脳波計の準備</h3>
<p>脳波研究は気軽で良いですね。これは脳磁図研究ほどお金はかかりません。<br />
臨床応用されている脳波計は <strong>†千万単位の金†</strong> くらいしか要りません。<br />
もしお金がなくても、病院にはそれなりにある機械です。<br />
読者の中で個人的に買える人が居るなら買うと良いんじゃないかな。<br />
あと、最近は10万円くらいで買える脳波計もありますね。openBCI<a href="#fn24" class="footnote-ref" id="fnref24"><sup>24</sup></a>とか。<br />
性能はまぁ…？</p>
<h3 id="コンピュータの準備">コンピュータの準備</h3>
<p>必要な性能はどこまでやるかにもよります。<br />
センサーベース脳波解析なら普通の市販のノートでも十分です。<br />
MRIやソースベース解析やるなら高性能なのがいいです。</p>
<p>また、高性能でも24時間計算し続けるような場合ノートではダメです。<br />
ゲーミングノートで数時間の処理とかならありかな、とは思います。<br />
一日以上やる場合は…小さくてもデスクトップ機を使って下さい。<br />
ノートは性能に限界があるだけでなく、排熱機構が弱いので<br />
数日計算し続けると火災が発生する可能性があります。<a href="#fn25" class="footnote-ref" id="fnref25"><sup>25</sup></a><br />
メモリいっぱい、CPUは多コアがいいです。今時ブランド選ばなければ割と安いです。<br />
どの程度のものが必要かは実験系によります。</p>
<p>GPUは基本「あまり効かない」と思っていて下さい。(効く場面もありますが限定的です。)<br />
入れるならnVidia製にして下さい。AMDも頑張ってますが、まだまだ科学計算に弱いです。<br />
メモリが大量に必要で、GPUよりCPU使う場面が多いです。<br />
freesurferはOSやCPUが変わったら結果が変わるという仕様がありますから<br />
「このコンピュータを使う」と固定する必要があります。</p>

<h1 id="導入編">導入編</h1>
<h2 id="osの準備">OSの準備</h2>
<p>OSというか、コンピュータ自体ですけれども。<br />
OSはLinux, MAC OS, Windowsどれでもいけます。<br />
MRIをいじるならばUnix系が必要になります。<br />
それぞれ各論を言いますが、僕個人としてはUbuntu linuxが好みです。</p>
<h3 id="windows">Windows</h3>
<p>Windowsを知らない人はいないでしょう。<br />
昔はWindowsは辛かったのですが、最近はWSLというWindows上でLinuxを<br />
動かす仕組みが整っていて、一応こなせます。<br />
MRIをやる時には性能面では劣るかも？<br />
機種を選べば諭吉が減りにくいというメリットがあります。</p>
<h3 id="macos">MacOS</h3>
<p>言わずと知れたオシャレ系OSです。<br />
何かとお財布に優しくないのが玉に瑕。<br />
こいつはUnix系の中でもBSDの系譜であり、<br />
MRI研究に素の状態で使用できるのです。</p>
<h3 id="linuxオススメ">Linux(オススメ)</h3>
<p>Unix系の中でもLinuxの系譜に当たるLinuxです。<br />
無料なのでWindows機を買ってきて両方使えるようにしちゃうと<br />
ひと粒で二度美味しいです。(デメリットもあります)<br />
さらに、割と素直に全てのソフトが動くのがLinuxです。<br />
さて、Linuxは単体では使用できません。<br />
Linux単体だと、マジで黒い画面が表示されるだけで何も出来ません。<br />
なので、ソフトの寄せ集めであるディストリビューションが必要です。<br />
生肉に対する定食みたいなものですね。<br />
この定食的なものが無料で配布されていたりします。<br />
この中でも王手としてDebian系とRedhat系があります。<br />
Redhat系は最近CentOS事件もあって、今はDebian系が無難と思います。</p>
<p>というわけで、僕は新しめのdebian系linuxディストリビューションである<br />
UBUNTU<a href="#fn26" class="footnote-ref" id="fnref26"><sup>26</sup></a>を使います。</p>
<p>Linuxでも新しめのメジャーなLinuxディストリビューションがいいです。<br />
CUDA等の技術に対応していたり、ユーザーが難しいことを考えなくて良いことが多いからです。<br />
debian系を使う理由はパッケージ管理ソフトのaptが優秀でユーザーが多いことです。<br />
MACの場合はaptの代わりに <a href="https://brew.sh/index_ja.html">homebrew https://brew.sh/index_ja.html</a> を用いることになります。<br />
以下、UBUNTU16.04LTS以上かmacos10.12を想定して書いていきます。<br />
UBUNTUは下記サイトから無料でダウンロードできます。</p>
<p><a href="https://www.ubuntulinux.jp/ubuntu">Ubuntu https://www.ubuntulinux.jp/ubuntu</a></p>
<p>僕自身は少しでも速く処理して欲しいので、誤差範囲かもですがlinuxでは軽量デスクトップ環境に<br />
変えています…ここは任意です。</p>

<h2 id="開発環境の準備脳波脳磁図の場合出来るだけリッチに">開発環境の準備（脳波、脳磁図の場合。出来るだけリッチに。）</h2>
<ul>
<li>freesurferだけ使う人は開発環境は要りません。読み飛ばして下さい。</li>
<li>試すだけだとか、質素な開発環境でいい人も読み飛ばして下さい。</li>
<li>玄人も読み飛ばして下さい。</li>
</ul>
<p>プログラミング得意な人はこのセクションは見なくていいです。</p>
<p>開発環境はMNE使うなら必要です。<br />
MNEはpythonで動くため、まずはpythonの環境を用意してあげないといけないのです。<br />
pythonの環境は構築の方法がいくらでもあるのですが、それぞれ一長一短です。</p>
<p>詳しい人からは「docker<a href="#fn27" class="footnote-ref" id="fnref27"><sup>27</sup></a>じゃダメなん？」という質問が<br />
来そうですが、セットアップは自分でできなければ困ることもありましょう。<br />
普通はanaconda<a href="#fn28" class="footnote-ref" id="fnref28"><sup>28</sup></a>を使います。何故ならMNE公式がanaconda推しだからです。<br />
anacondaもいい所悪い所色々あってエンジニアの中には毛嫌いする向きもあります。<br />
僕はよりpythonistaっぽくvenv<a href="#fn29" class="footnote-ref" id="fnref29"><sup>29</sup></a>を使っています。<br />
pipenv<a href="#fn30" class="footnote-ref" id="fnref30"><sup>30</sup></a>やpoetry<a href="#fn31" class="footnote-ref" id="fnref31"><sup>31</sup></a>を使う方法もあります。<br />
venvとpoetryはpython本体までは用意してくれないので、<br />
pyenvと併用する必要があります。</p>
<p><a href="https://www.continuum.io/downloads">Anaconda https://www.continuum.io/downloads</a></p>
<p>このサイトからインストールプログラムをダウンロードします。<br />
anacondaにjupyterというrepl<a href="#fn32" class="footnote-ref" id="fnref32"><sup>32</sup></a>とspyderというIDE<a href="#fn33" class="footnote-ref" id="fnref33"><sup>33</sup></a>が付いてきます。<br />
これらを使うのもまたいいと思います。</p>
<h3 id="それぞれの使用感">それぞれの使用感</h3>
<p>あとは、自分の好きな開発環境を調達するといいでしょう。<br />
開発環境は色々あるので軽く紹介します。</p>
<h4 id="vscode">vscode</h4>
<p>vscodeは現代的なテキストエディタです。<br />
python用ではありませんが、プラグインを入れてpythonのIDEとして使うことが出来ます。<br />
Microsoft製ですので圧倒的な安心感があります。</p>
<h4 id="spyder">spyder</h4>
<p>とても素直な挙動のIDEでipythonの補完機能も手伝って使いやすいです。<br />
ただし、動作が重めなのと、企業のバックアップがなくなって今後が辛いかもです。<br />
オススメ度は将来性を考慮するとやや低いです。</p>
<h4 id="jupyter-ipython">jupyter, ipython</h4>
<p>replというか、shellと言うかちょっと珍しい開発環境です。<br />
これだけで完結することも出来なくはないレベルの開発環境です。強みとしては</p>
<ul>
<li>webベースなので遠隔操作可能</li>
<li>cythonやRといった他言語との連携が容易</li>
<li>対話的インターフェイスがメイン</li>
</ul>
<p>弱みもあります</p>
<ul>
<li>厳格なコーディングに不向き</li>
<li>バージョン管理できない</li>
<li>気をつけてないと散らかり過ぎて崩壊する</li>
<li>処理速度が遅くなる</li>
</ul>
<p>これだけでやろうとするのはやめたほうが良いです。<br />
弱みが割と致命的になりがちで、初学者がこれだけに慣れると<br />
コーディング技術が伸び悩みます。<br />
使うなら、必ず他のテキストエディタと併用しましょう。</p>
<h3 id="僕の今のおすすめは">僕の今のおすすめは?</h3>
<p>初心者の場合<br />
- anaconda<br />
- vscode<br />
- jupyter<br />
という組み合わせです。mneのインストールはanacondaに任せちゃいます。<br />
基本はvscodeでスクリプトを書きますが、状況に応じてjupyterでチェックしたりします。</p>
<p>pythonを書いたことは無いけれど他の言語の玄人の人にはこうです。<br />
- venvまたはpoetryとpyenv<br />
- 好みのテキストエディタ</p>
<p>え？僕ですか？僕はvenvとvim<a href="#fn34" class="footnote-ref" id="fnref34"><sup>34</sup></a>とipythonのCUIでやっています。</p>
<h3 id="逆にお勧めしないもの">逆にお勧めしないもの</h3>
<p>Windowsのnotepad.exeはお勧めしません！<br />
力不足です！</p>
<p>Macのテキストエディットは最悪です！<br />
勝手に貴方の書いた文字列を書き換えてしまいます！</p>
<p>jupyter一本で挑むのはやめて下さい！<br />
初心者はjupyter依存症になって伸び悩みます！</p>
<h3 id="構築">構築</h3>
<p>では、上記の初心者用環境を整える為の準備をしていきましょう。<br />
vscodeはまぁ、導入するのは楽勝なのでググって下さい。</p>
<figure>
<img src="img/jupyter.jpg" alt="jupyterの画面。webベースでインタラクティブにコーディング・共有できる。まぁ、触ってみればわかります。" style="width:14cm" /><figcaption>jupyterの画面。webベースでインタラクティブにコーディング・共有できる。まぁ、触ってみればわかります。</figcaption>
</figure>
<figure>
<img src="img/spyder.jpg" alt="spyderの画面。ごく普通の素直な挙動のIDE。" style="width:14cm" /><figcaption>spyderの画面。ごく普通の素直な挙動のIDE。</figcaption>
</figure>
<p>MACはanacondaのインストーラーをダウンロードしてクリックしていけばどうにかなります。<br />
linuxではanacondaはダウンロード後、ターミナルで以下のようにコマンドを叩いて<br />
インストールします。bashです。ただのshじゃインストールできません。</p>
<pre data-frame="single"><code>bash Anaconda3-hoge-Linux-x86_64.sh</code></pre>
<p>インストール先はホームフォルダでいいかとか、色々質問が出てきますが、<br />
そのままホームフォルダにインストールするのが<del>気持ち悪くても</del>スムーズに行くかと思います。<br />
気持ち悪くて死ぬ人はpipenvでも使って下さい。</p>
<h3 id="jupyterの起動">Jupyterの起動</h3>
<pre data-frame="single"><code>jupyter notebook</code></pre>
<p>すると、ブラウザが起動し、画面が表示されるはずです。<br />
起動しなければ、下記URLにアクセスしてください。<br />
http://localhost:8888<br />
jupyterはブラウザで動かすものですが、別にネットに繋がるものじゃないです。<br />
ちなみに、下記の様にして起動すると、lan内で別のjupyterに接続できます。</p>
<pre data-frame="single"><code>jupyter notebook --ip hoge</code></pre>
<p>ipは、多分ターミナルに表示されていると思います。<br />
そうじゃないなら、例えばUbuntuなら</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="ex">ip</span> addr</a></code></pre></div>
<p>で表示されます。<br />
jupyterはターミナルでctr-cを二回叩けば終了できます。<br />
では、左上のnewボタンからpythonを起動しましょう。<br />
### jupyterの設定<br />
jupyterを使うなら、折角なので拡張しておきましょう。ターミナルで下記を叩いてください。</p>
<pre data-frame="single"><code>conda install -c conda-forge jupyter_contrib_nbextensions
jupyter contrib nbextension install --user
ipcluster nbextension enable --user</code></pre>
<p>これでextensionが使えるようになります。</p>
<h3 id="jupyterでのplot">jupyterでのplot</h3>
<p>jupyterはplotの方法を指定できます。<br />
表示したい場合は、予め下記コードをjupyter上に書いておいてください。</p>
<p>jupyter上に直接出力したい時</p>
<pre data-frame="single"><code>%matplotlib inline</code></pre>
<p>python3環境下で別ウィンドウで表示したい時python3とpython2は使うqtのバージョンが違うので<br />
qt5が必要になります。</p>
<pre data-frame="single"><code>%matplotlib qt5</code></pre>
<p>三次元画像をグリグリ動かしながら見たい時<br />
(mayavi使用)</p>
<pre data-frame="single"><code>%gui qt</code></pre>
<p>これについては後でまた詳しく記載します。</p>
<h3 id="anaconda仮想環境">anaconda仮想環境</h3>
<p>anacondaは仮想環境を作れます。仮想環境はガンガン使いましょう。<br />
何故かって？mneのバージョンが上がることがあります。<br />
バージョンが上がるときに困るのは、バージョンを上げると<br />
過去の解析環境が失われてしまい、再現性が損なわれることです。<br />
そこで、大事なのは仮想環境を作り、その環境の中でやっていくことです。<br />
MNEはanacondaを推奨しています。<br />
anacondaはpythonの仮想環境<a href="#fn35" class="footnote-ref" id="fnref35"><sup>35</sup></a>を作ることが出来ますのでそれを利用するのが楽です。</p>
<p>では、ipythonからやっていきましょう。<br />
ここでは、hogeという名前のpython3.6環境をjupyter上に作ってみましょう。</p>
<pre data-frame="single"><code>ipython kernel install --user --name py3
conda create -n hoge python=3.6 anaconda
conda activate hoge
ipython kernel install --user --name hoge
conda info -e</code></pre>
<p>1行目から順に何をやっているか述べます。</p>
<ol type="1">
<li>今のpythonの環境をjupyterに「py3」という名前で載せておく</li>
<li>condaで別バージョンのpython環境を作る</li>
<li>切り替える</li>
<li>jupyterに「hoge」という名前で組み込む</li>
<li>確認</li>
</ol>
<p>conda activateコマンドでpythonの環境を切り替えられます。<br />
これでjupyterで色んな環境を切り替えられると思います。<br />
ちなみに間違って環境を作った場合は以下のコマンドで消せます。</p>
<pre data-frame="single"><code>conda remove -n python3 --all</code></pre>
<h3 id="rをjupyterで動かすために">Rをjupyterで動かすために</h3>
<p>anacondaを使っているなら下記でRがインストールできます。</p>
<pre data-frame="single"><code>conda install libiconv
conda install -c r r-essentials
conda install -c r rpy2</code></pre>
<p>これによりRが動くようになり、貴方は少しだけ楽になります。<br />
何故なら、実験結果を同じ環境で動くRに吸い込ませられるので、<br />
「実験結果を入力するだけでワンクリックで統計解析結果まで出る」<a href="#fn36" class="footnote-ref" id="fnref36"><sup>36</sup></a>ような<br />
スクリプトが実現できるからです。具体的にはjupyter上で</p>
<pre data-frame="single"><code>%load_ext rpy2.ipython</code></pre>
<p>とした後</p>
<pre data-frame="single"><code>%%R -i input -o output
hogehoge</code></pre>
<p>という風に記述すればhogehogeがRとして動きます。plotも出来るし、引数、返り値も<br />
上述のとおり直感的です。さて、この-iですが、通常の数字や一次元配列は普通に入りますが、<br />
Rならデータフレームからやりたいものです。その場合はpandasというモジュールを使って<br />
受け渡しをします。例えばこのような感じです。</p>
<pre data-frame="single"><code>import pandas as pd
data=pd.Dataframe([二次元配列])</code></pre>
<pre data-frame="single"><code>%%R -i data
print(summary(data))</code></pre>
<p>pythonとRをシームレスに使いこなすことがこれで出来るようになります。</p>

<h3 id="cuda">CUDA</h3>
<p>CUDAをご存知でしょうか？<br />
GPUを科学計算に用いる方法の1つで、Nvidia社が開発しているものです。<br />
GPGPUと呼ばれる技術の一種ですね。これはMNEpythonでも使うことが出来るので、やってみましょう。<br />
つっても、今の所フィルター関連だけなんですけどね…<br />
しかもあまり速くない上に、ドライバ入れるのが結構面倒いとか<br />
そういうツラミが出てきていてあまりおすすめではないです。<br />
あと、ついにMacでNvidiaがサポートされなくなったりしています。</p>
<p>これのインストールも詰まるとそれなりに面倒です。<br />
結構環境によるので「頑張ってね」としか…。<br />
まずは、Nvidiaのサイトからインストーラーをダウンロードします。</p>
<p><a href="https://developer.nvidia.com/cuda-downloads">Nvidia https://developer.nvidia.com/cuda-downloads</a></p>
<p>このサイトには色々なOSに対応したCUDAが置いてあります。<br />
僕はubuntuならdeb(network)をお勧めします。面倒臭さが低いです。<br />
インストーラーをダウンロードしてダブルクリックするだけではダメで、<br />
ダウンロードのリンクの下にある説明文を刮目して読みましょう。<br />
こんな感じに書いてあります(バージョンによって違います)</p>
<pre data-frame="single"><code>sudo dpkg -i cuda-repo-ubuntu1604_9.1.85-1_amd64.deb
sudo apt-key adv --fetch-keys http://hogehoge.pub
sudo apt-get update
sudo apt-get install cuda</code></pre>
<p>こんな感じのがあるはずなので、実行して下さい。もちろん、バージョンとかは読み替えるべし。<br />
そして、これが大事なのですが、bashrcにパスを通す必要があります。<br />
これはCUDAのインストールガイドに書いてあります。<br />
インストールガイドへのリンクは先程の説明の下に小さく書いてあります。<br />
具体的には下記のような感じです。</p>
<pre data-frame="single"><code>export PATH=/usr/local/cuda-9.1/bin${PATH:+:${PATH}}
export LD_LIBRARY_PATH=/usr/local/cuda-9.1/lib64\
      ${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}</code></pre>
<p>これでCUDAへのリンクが貼れたはずです。bashを再起動しましょう。<br />
MNEpythonのCUDAインストールのページに従ってコマンドを叩きます。<br />
http://martinos.org/mne/stable/advanced_setup.html#advanced-setup</p>
<pre data-frame="single"><code>sudo apt-get install nvidia-cuda-dev nvidia-modprobe
git clone http://git.tiker.net/trees/pycuda.git
cd pycuda
./configure.py --cuda-enable-gl
git submodule update --init
make -j 4
python setup.py install
cd ..
git clone https://github.com/lebedov/scikit-cuda.git
cd scikit-cuda
python setup.py install</code></pre>
<p>これでインストールできてたら成功です。pythonで</p>
<pre data-frame="single"><code>import mne
mne.cuda.init_cuda()</code></pre>
<p>としたらEnabling CUDA with 1.55 GB available memory…<br />
的なメッセージが出たりします。そして、一番確実なのはMNEpythonに付属した<br />
テストツールを回してみることです。</p>
<pre data-frame="single"><code>pytest test_filter.py</code></pre>
<p>このテストツールはMNEpythonの中にあります。<br />
場所的にはanacondaの中のlib/python3/site-package/mne/tests<br />
的な場所にあると思うのですが、環境によって違うかもです。<br />
このテストがエラーを吐かなければ…おめでとうございます！<br />
貴方はMNEpythonをCUDAで回すことが出来ます！つっても、今の所フィルター関連だけなんですけどね…</p>

<h3 id="バージョン管理git">バージョン管理git</h3>
<p>バージョン管理を知っているでしょうか？<br />
貴方はスクリプトを書くことになるのですが、ちょっとしたミスでスクリプトは動かなくなります。<br />
そんなリスクを軽減するために、貴方はスクリプトのコピーを取ります。<br />
コピーを取り続けるうちに、貴方のコンピュータはスクリプトで埋め尽くされ、収集つかなくなります。<br />
さらに、他の人がスクリプトを手直しする時、引き継ぎとかも大変です。<br />
そんな貴方はgitを使うと幸せに成れます。<br />
gitを知らない人は、とりあえずgithub desktopとかsource treeをダウンロードして<br />
体でそれを知ってください。詳しくはgitでググってください。<br />
こことか参考になります。<br />
<a href="http://www.backlog.jp/git-guide/">git-guide http://www.backlog.jp/git-guide/</a></p>
<h3 id="gitサーバー">gitサーバー</h3>
<p>git単体でもいけるのですが、gitサーバーというのもあります。<br />
最近Microsoftが気前よくgithubのプライベートリポジトリを無料化したので、<br />
それを使うのもいいでしょうね。<br />
自分の研究用スクリプトをアップしたくないなら自前で鯖立てするのもいいし、<br />
そもそも鯖立てなくても十分便利です。<br />
ただ、一つ言えるのは、これ間違ってpublicとして個人情報を<br />
githubに上げちゃったりすると捕まりますので、これだけは注意しましょう。<br />
普段はgitサーバーは要らないと思うよ。</p>
<h3 id="jupyterで作ったスクリプトのバージョン管理小技">jupyterで作ったスクリプトのバージョン管理(小技)</h3>
<p>jupyterのファイルはgitしにくい上にすっごい散らかるので<br />
きちんとコーディングする場合はオススメしません。<br />
普通にテキストエディタ使いましょう。</p>
<p>あくまでサブとして使う事をおすすめします。<br />
重いしね…</p>
<h4 id="方法1超面倒くさい">方法1(超面倒くさい)</h4>
<pre data-frame="single"><code>jupyter notebook --generate-config</code></pre>
<p>このコマンドでjupyterのコンフィグファイルが作成されます。<br />
場所は/home/user/.jupyterです。<br />
その上で、下記URLに記載されている通りに書き加えます。<br />
http://jupyter-notebook.readthedocs.io/en/latest/extending/savehooks.html<br />
すると、jupyterで編集したファイルがpythonのスクリプトとしても保存されます。<br />
あとはgit<a href="#fn37" class="footnote-ref" id="fnref37"><sup>37</sup></a>などで管理すればいいです。<br />
ただし、この方法は計算結果がファイル内に残りません。<br />
しかも散らかりますし、面倒くさいです。</p>
<h4 id="方法2あまりおすすめしない">方法2(あまりおすすめしない)</h4>
<p>gitを使いますが、git側の設定だけでもどうにかなります。<br />
まず、jqをインストールします。.gitattibuteに書きを書き加えます。無ければ作ってください。</p>
<pre data-frame="single"><code>*.ipynb diff=ipynb</code></pre>
<p>そして、下記を.git/configに</p>
<pre data-frame="single"><code>[diff &quot;ipynb&quot;]
textconv=jq -r .cells[] |{source,cell_type}
prompt = false</code></pre>
<p>下記を.gitignoreに</p>
<pre data-frame="single"><code>.ipynb_checkpoints/</code></pre>
<p>これでjupyter notebookのファイルをgitで管理しやすくなります。<br />
色んな理由でおすすめはしませんけどね…</p>

<h2 id="maxfilterelektaのやつ">maxfilter(elektaのやつ)</h2>
<p>maxfilterというフィルタがMEG研究ではほぼ必須です。<br />
これは外から飛んでくるノイズを数学的に除去するフィルタです。</p>
<p>これについてはMNEpythonにもあるのですが、elekta社のmaxfilterもあります。<br />
一長一短ですが、何も考えずに使うならelekta社でしょうか…。<br />
僕は以前はelektaのを使っていましたが、最近MNEに移行しました。MNEのは後で解説します。</p>
<p>それぞれの特徴としては<br />
Elekta版</p>
<ul>
<li>Elekta社のMEG部門が売却されたよ…将来性どうなん？</li>
<li>Redhat系linuxでないと動かないのがクソ(Docker使うところかな？)</li>
<li>自動でbadチャンネル見つけてくれるのが超最高</li>
</ul>
<p>MNE版</p>
<ul>
<li>臨床には使っちゃいけないという縛りあり</li>
<li>使用環境を選ばないのが超最高</li>
<li>まだ改良中？？？</li>
</ul>
<p>ELEKTA社のを使いたい場合はDANAというソフトと<br />
maxfilterというソフトをELEKTA社から貰う必要があります。<br />
また、環境はRedhat5またはCentOs5の64bit版を使うことになっています。<br />
えっ、linuxはUbuntuを使うんじゃなかったの？と思ったでしょう？<br />
ELEKTA社のソフトはredhat linux系が前提なのです。</p>
<p>あとは企業の人に聞いたほうが良いです。細則があります。</p>
<p>…正直、よく分かんないし、あんまり語れないんですよね、<br />
オープンソースじゃないものですしね。</p>

<h2 id="freesurferのインストール">freesurferのインストール</h2>
<p>freesurferをインストールしましょう。<br />
下記のurlからダウンロードできます。<br />
<a href="https://surfer.nmr.mgh.harvard.edu/fswiki/rel7downloads">https://surfer.nmr.mgh.harvard.edu/fswiki/rel7downloads</a><br />
Ubuntu、CentOS、MACOSがありますね！<br />
Windows版？ハッw そんなものはない。<br />
もしどうしても君がWindowsを使わねばならぬなら<br />
WSL(Windows Subsystem for Linux)を使えばいいかもしれないです。<br />
というか、僕の手元では動いたので動くと思います。<br />
Macなら下記のソフトも必要です。Xwindowシステムですね。<br />
<a href="https://www.xquartz.org/">https://www.xquartz.org/</a><br />
素でXwindowシステムが動くのがLinuxディストリビューションなので、<br />
ここが僕がLinuxディストリビューションを気に入っている理由です。</p>
<p>Ubuntuなら</p>
<pre data-frame="single"><code>sudo dpkg -i hoge</code></pre>
<p>でパッケージをインストールできます。</p>
<p>MacならGUIのインストーラーあります！<br />
ね、簡単でしょう？でも、まだ終わっていません。このままでは動きません。</p>
<p>もしかすると、追加で下記が必要かも分かりません。Ubuntuなら</p>
<pre data-frame="single"><code>sudo apt install tcsh csh</code></pre>
<p>Macなら</p>
<pre data-frame="single"><code>sudo brew install tcsh csh</code></pre>
<p>あとは、設定をしないといけないのです。<br />
設定ファイルはホームディレクトリにある隠しファイルです。</p>
<p>テキストエディタは何でも良いですが、とにかく編集しましょう。<br />
「隠しファイルなにそれ」な人は、unix系の勉強をしましょう！<br />
僕はとても優しいので教えますが、「.」で始まるファイル名は隠しファイルになります。</p>
<p>freesurferのダウンロードページに、Setup &amp; Configurationという所があります。<br />
四角で囲んである部分をコピーして、隠しファイルの.bash_profileに追記しましょう。<br />
場合によっては.bashrcのこともあるかも知れませんね。</p>
<p>貴方が使っているシェルに応じてどれをどんな風にコピペするかが決まるのですが<br />
大抵はbashかzshと思います。<br />
linuxなら<br />
<a href="https://surfer.nmr.mgh.harvard.edu/fswiki//FS7_linux">https://surfer.nmr.mgh.harvard.edu/fswiki//FS7_linux</a><br />
Macなら<br />
<a href="https://surfer.nmr.mgh.harvard.edu/fswiki//FS7_mac">https://surfer.nmr.mgh.harvard.edu/fswiki//FS7_mac</a><br />
を見て下さい。</p>
<p>要するにこんなふうなのを設定ファイルに書き加えるんですね。</p>
<pre data-frame="single"><code>export FREESURFER_HOME=$HOME/hoge
source $FREESURFER_HOME/SetUpFreeSurfer.sh</code></pre>
<p>1行目を見て下さい。<br />
これはFreesurferがホームディレクトリの’hoge’にインストール<br />
されている場合ですね。</p>
<p>で、コピペし終わったら、保存して閉じるんですが、MRIの解析結果の<br />
保存先(subject_dir)を決めてあげたい場合は下記のようにします。</p>
<pre data-frame="single"><code>export SUBJECTS_DIR=fuga</code></pre>
<p>これは決めてあげたほうが良いです。何故なら、標準のsubject_dirは<br />
読み書きに管理者権限が必要だったりするからです。<br />
あと、毎回同じMRI研究をするわけでもないので、プロトコルが変わるなら<br />
場所も変えてあげたいですよね！</p>
<p>最後にライセンスキーを入れましょう。<br />
freesurferの公式サイトに登録して、ライセンスキーをメールでもらい、<br />
freesurferのディレクトリに突っ込みます。</p>
<p>面倒いので、あとはfreesurferのサイトを読んで下さい。</p>

<h2 id="mnepythonのインストール脳波脳磁図をする場合">MNE/pythonのインストール(脳波、脳磁図をする場合)</h2>
<p>こちらはMNEの公式ではanacondaの存在下でやるようになっています。<br />
anacondaが嫌いな人(結構いらっしゃるかと思います)は既に十分な<br />
知識をお持ちのことと思います。</p>
<p>例えば、下記の意味が分かる人にはこのセクションは不要です。<br />
あとはその都度必要になったものを適当に入れます。</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb30-1" title="1"><span class="ex">python</span> -m venv env</a>
<a class="sourceLine" id="cb30-2" title="2"><span class="bu">source</span> env/bin/activate</a>
<a class="sourceLine" id="cb30-3" title="3"><span class="ex">pip</span> install mne h5io matplotlib numpy mne-connectivity</a></code></pre></div>
<p>ちなみに、意味的には<br />
「envって名前の仮想環境を作って、その仮想環境に行って、<br />
色々インストールするよー」という意味です。<br />
実は僕はいつもこの方法をとっています。<br />
ま、pythonは何通りも導入方法あるので。</p>
<p>あと、最近mneからコネクティビティ解析関連が<br />
mne-connectivityとして独立したので、<br />
使いたいならば入れて下さい。　</p>
<h3 id="公式のインストール方法">公式のインストール方法</h3>
<p>長くmne-pythonをヲチしているけれど、<br />
mne-pythonのインストール方法、変わりすぎて草。<br />
バージョン変わる毎にインストール方法変わるので注意です。<br />
現行バージョンは1.4。</p>
<p>現時点で公式サイトではanacondaを使うことになっています。<br />
理由は…よく分かりませんが、多分「どこでも動くから説明が楽」なんだと思います。<br />
インストール方法はここにあります。<br />
<a href="https://mne.tools/stable/install/manual_install.html">https://mne.tools/stable/install/manual_install.html</a></p>
<p>ちなみにこういうゆるふわ簡易版なのもあります。<br />
<a href="https://mne.tools/stable/install/installers.html#installers">https://mne.tools/stable/install/installers.html#installers</a></p>
<p>さて、上記の簡単版を使わないなら、下記のようにします。</p>
<pre data-frame="single"><code>conda install --channel=conda-forge --name=base mamba
mamba create --override-channels --channel=conda-forge --name=mne mne</code></pre>
<p>これで新しい’mne’という仮想環境が出来るようです。</p>
<p>そう、仮想環境で構築することになります。<br />
このやり方のメリットは、いつでも同じ環境を整える事ができるので、<br />
ソフトのバージョンが変わっても対応しやすいということです。<br />
反面、毎回仮想環境に入らないといけないという小さなデメリットがあります。<br />
だけど、バージョン揃えるのは貴方の責任です。<br />
つまり、使いましょう。(圧力)</p>
<p>公式サイトをみながら頑張りましょう。</p>
<pre data-frame="single"><code>conda create\
    --strict-channel-priority\
    --channel=conda-forge\
    --name=mne\
    mne-base h5io h5py pymatreader</code></pre>
<p>–name=mneってありますよね？<br />
これでmneという名前の仮想環境が整います。<br />
下記のコマンドでmneの環境に入れます。</p>
<pre data-frame="single"><code>conda activate mne</code></pre>
<p>今後はmneを使うときは必ず上記のコマンドを打って下さい。<a href="#fn38" class="footnote-ref" id="fnref38"><sup>38</sup></a><br />
面倒くさい？どうしても打ちたくないです？<br />
それならば、.bashrcや.bash_profileに下記を追記してください。</p>
<pre data-frame="single"><code>conda activate mne</code></pre>
<p>大まかにはこれで完結です。<br />
仮想環境は複数作っておくほうが良いと思います。<br />
hogeって環境作りますね。</p>
<pre data-frame="single"><code>conda create\
    --strict-channel-priority\
    --channel=conda-forge\
    --name=hoge\
    mne-base h5io h5py pymatreader</code></pre>
<p>hogeの環境に入るには</p>
<pre data-frame="single"><code>conda activate hoge</code></pre>
<p>です。ちなみに、出るのは</p>
<pre data-frame="single"><code>conda deactivate</code></pre>
<p>macなら下記も必要です。</p>
<h3 id="mayaviがインストール出来ない">MAYAVIがインストール出来ない</h3>
<p>mayaviはmne-pythonのインストールの鬼門です。<br />
僕はしばしばmayaviをインストールすることに失敗します。<br />
mayaviのドキュメントに「mayavi」のインストールなんて簡単とか書いてありますが<br />
騙して悪いがあれは嘘である。<br />
pipでインストールできないときのとっておきをお伝えします。<br />
ようこそ、UNIXの世界へ。</p>
<p>まずは、gitをインストールします。<br />
gitのインストールはmacなら</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb38-1" title="1"><span class="ex">brew</span> install git</a></code></pre></div>
<p>ubuntuなら</p>
<pre><code>sudo apt install git</code></pre>
<p>で簡単です。そのうえで、mayaviのソースコードを貰ってきます。</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb40-1" title="1"><span class="fu">git</span> clone https://github.com/enthought/mayavi.git</a></code></pre></div>
<p>で、この中のsetup.pyを走らせましょう。</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb41-1" title="1"><span class="bu">cd</span> mayavi</a>
<a class="sourceLine" id="cb41-2" title="2"><span class="ex">python</span> setup.py install</a></code></pre></div>
<p>ご注意ください。問答無用で今使っているpythonの中に入ってしまいます。<br />
もし、これでうまく行かないならば、なにかコンパイラとかが欠けているはずです。<br />
例えばubuntuなら</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb42-1" title="1"><span class="fu">sudo</span> apt install build-essentioal</a></code></pre></div>
<p>とかやれば入るかも？(検証してません)</p>
<h3 id="hf5をインストールしたい">HF5をインストールしたい</h3>
<p>時間周波数解析をする場合は、<br />
HF5をインストールする必要が出ることがあります。<br />
上記のanacondaの方法なら全部入りますが、pipとかでやると<br />
入らないので一応言います。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb43-1" title="1"><span class="ex">pip</span> install h5io</a></code></pre></div>
<p>でおｋです。</p>
<h3 id="jupyter-kernel">jupyter kernel</h3>
<p>jupyterを使うのであれば、上記の環境をjupyterに登録する必要があります。<br />
まずは、仮想環境に入って下さい。</p>
<pre data-frame="single"><code>conda activate mne</code></pre>
<p>では、登録しましょう。下記は「今いる環境をjupyterに登録する」やつです。<br />
userというのは「コンピュータ全体向けじゃなくて、僕向けにやるよ」<br />
nameは仮想環境の名前ですね。</p>
<pre data-frame="single"><code>jupyter kernel install --user --name hoge</code></pre>
<p>もし、要らなくなったら</p>
<pre data-frame="single"><code>jupyter kernelspec uninstall hoge</code></pre>
<p>ですね。</p>
<h3 id="cuda-1">CUDA</h3>
<p>CUDA<a href="#fn39" class="footnote-ref" id="fnref39"><sup>39</sup></a>(GPGPU)についてもそのサイトに記載があります。<br />
CUDAはnvidiaのGPUしか動きません。インストールについてはnvidiaのサイトも参照して下さい。<br />
まぁ、各種波形フィルタでしか使えない上にさほど性能よくないです。<br />
正直、<strong>CPUだけで十分です。</strong><a href="#fn40" class="footnote-ref" id="fnref40"><sup>40</sup></a></p>
<p>僕の環境では下記二行のコマンドを予め入れていないと動かないです。<br />
.bash_profileや.bashrcに書き加えておけばいいでしょう。</p>
<pre data-frame="single"><code>export LD_PRELOAD=&#39;/usr/$LIB/libstdc++.so.6&#39;
export DISPLAY=:0</code></pre>
<p>さらに、jupyter内で下記を実行しないといけません。</p>
<pre data-frame="single"><code>%gui qt</code></pre>
<h3 id="mnecのインストール">MNE/Cのインストール</h3>
<p>これはmne-pythonを普通に使うなら不要です。<br />
つまり、レガシィな物を使いたい人が使うやつです。<br />
<strong>要するに不要です。</strong><br />
残念ながらMNE/Cを使ったことがないので僕には何もわからないのです…。<br />
下記サイトにメールアドレスを登録し、ダウンロードさせていただきましょう。<br />
<a href="http://www.nmr.mgh.harvard.edu/martinos/userInfo/data/MNE_register/index.php">MNE-C http://www.nmr.mgh.harvard.edu/martinos/userInfo/data/MNE_register/index.php</a><br />
ダウンロードしたものについてはこのサイトの通りにすればインストールできます。<br />
<a href="http://martinos.org/mne/stable/install_mne_c.html">MNE-C http://martinos.org/mne/stable/install_mne_c.html</a><br />
僕はホームディレクトリに入れました。</p>
<pre data-frame="single"><code>tar zxvf MNE-hogehoge
mv MNE-hogehoge MNE-C
cd MNE-C
export MNE_ROOT=/home/fuga/MNE-C
. $MNE_ROOT/bin/mne_setup_sh</code></pre>
<p>これでMNE-Cも動くようになるはずです。</p>
<h3 id="コラム1-snsの活用"><em>コラム1-SNSの活用</em></h3>
<pre data-basicstyle="\normalfont" data-frame="shadowbox"><code>皆さんはSNSはしていますか？SNSには様々な効能と副作用があります。
時に炎上する人だって居ます。廃人になる人も居ます。
しかし、最先端の科学にとって、SNSは大変有用なのです。
twitterでMEGやMRIの研究者をフォローしてみてください。
いい情報、最新の情報がピックアップされ、エキサイティングです。
僕は新着情報はtwitterで研究者、開発者、有名科学雑誌のアカウントを
フォローしてアンテナはってたこともありました。
(筆者の脳の疾患が増悪して今はしてない)
ちなみに、若いエンジニアはよくするらしいです。</code></pre>

<h2 id="freesurferを使うmri">freesurferを使う(MRI)</h2>
<p>ターミナル使える人のためのTLDR;</p>
<p>インストールしたら以下で終わり。</p>
<pre data-frame="single"><code>recon-all -i ./hoge.nii -subject (被験者番号) -all</code></pre>
<p>ちなみに、recon-allというのは複数のコマンドを束ねたコマンドです。<br />
その複数のコマンド群は下記に記載されています。<br />
<a href="https://surfer.nmr.mgh.harvard.edu/fswiki/ReconAllDevTable">https://surfer.nmr.mgh.harvard.edu/fswiki/ReconAllDevTable</a></p>
<p>つまり、上記の細かいやつを参照すれば自分が何をしているのか分かるのですが、<br />
ユーザーが難しいことを考えなくてもソフトの作者が<br />
「デフォルトではこうだから全部並べとくね」ってやって下さってる。<br />
昔だったら自分でこれを実装しないといけなかったらしい。<br />
凄い親切！recon-allってなんて楽ちんなコマンドなんだ！<br />
圧倒的感謝！謝々！カムサハムニダ！現場からは以上です。</p>
<p>とはいえ、ソフト自体はものすごく正確というわけではありません。<br />
塗り損ないが出来ることがあります。トラブルシュートは後で書きます。<br />
ちなみに、並列計算出来るんですが、公式曰く「バグがあるから使うな」とのこと。<br />
(なのに何故か無効化されていない。何故だ…)</p>
<p>さて、俺は優しいのでターミナル使ったことのない人への解説も書きます。<br />
下記はターミナルを操るための必要最低限のbashのコマンドです。</p>
<ul>
<li>cd :閲覧するフォルダへ移動する</li>
<li>ls :今開いているフォルダの内容を確認する</li>
</ul>
<p>まず、ターミナルを開きMRIの画像データがある場所まで移動します。<br />
例えばフォルダの名前がDATAなら下記のようにします。</p>
<pre data-frame="single"><code>cd DATA</code></pre>
<p>辿っていって、目的のファイルを見つけたならば、freesurferで解析します。<br />
例えばファイルの名前がhoge.niiなら下記です。</p>
<pre data-frame="single"><code>recon-all -i ./hoge.nii -subject (患者番号) -all</code></pre>
<p>このコマンドを走らせると、完遂するのにおよそ丸１日かかります。</p>
<p>で、やっている事は、頭蓋骨を取り除き、皮質の厚さやボリュームの測定、標準脳への置き換え、<br />
皮質の機能別の色分け等、色々な事をしてます。詳しくはfreesurferのサイトを見て下さい。</p>
<h3 id="recon-all同時掛けfreesurfer">recon-all同時掛け(freesurfer)</h3>
<p>recon-allはマルチスレッドで処理をすることができます。<br />
しかし、効率はあまり良くないし<a href="#fn41" class="footnote-ref" id="fnref41"><sup>41</sup></a>、公式が使うなって言っています。<br />
つまり、マルチコア機なら一例ずつマルチスレッドでかけるより、<br />
同時多数症例をシングルプロセスで掛かける方が速く済みます。<br />
ターミナルを沢山開いて処理させたりすると速いですが煩雑です。<br />
なので、スクリプトを書いて自動化することをおすすめします。</p>
<p>MNEpythonを使う人はプログラミングの習得は必須なので良いとして、<br />
freesurferしか使わない人でもスクリプトは書けるようになる方が便利です。<br />
僕のおすすめはpython、shのいずれかです。<a href="#fn42" class="footnote-ref" id="fnref42"><sup>42</sup></a><br />
下記はshの一例です。</p>
<pre data-frame="single"><code>recon-all -i ./hoge1.nii -subject hoge1 -all &amp;
recon-all -i ./hoge2.nii -subject hoge2 -all &amp;
recon-all -i ./hoge3.nii -subject hoge3 -all &amp;
recon-all -i ./hoge4.nii -subject hoge4 -all </code></pre>
<p>こんな感じでテキストファイルにして、’hoge.sh’とでも名付けます。<br />
で、以下のとおりです。</p>
<pre data-frame="single"><code>sh hoge.sh</code></pre>
<p>「シェルで並列するならxargsコマンドを使えよ」という声が<br />
聞こえてきそうですが、本当はそれが王道です。<br />
やりましょうか。</p>
<pre data-frame="single"><code>SUBJECTS=&#39;1
2
3
4&#39;

echo &quot;$SUBJECTS&quot; |\
    xargs -P 4 -I{} recon-all ./hoge{}1.nii -subject hoge{} -all</code></pre>
<p>これで、CPU4つを使って同時に解析できます。</p>
<h3 id="freesurferの解析結果の表示">freesurferの解析結果の表示</h3>
<p>freeviewというコマンドで解析済みの画像を表示できます。<br />
上から解剖的に分けたデータを乗せることで部位別の表示ができます。</p>
<p>コマンドラインでは以下のようにすればいいですが、freeviewと叩いてから<br />
画面上からやっていってもいいと思います。<br />
(多くの人は普通の画面上からしたほうが分かりやすいでしょう)</p>
<pre data-frame="single"><code>freeview -v &lt;subj&gt;/mri/orig.mgz \
hoge/mri/aparc+aseg.mgz:colormap=lut:opacity=0.4 </code></pre>
<p>orig.mgzというのはオリジナル画像。グレイスケールで読みこみましょう。<br />
aparc+aseg.mgzは部位別データ。部位別データには色を付けて読み込みましょう。</p>
<p>画面左側に表示されているのは読み込んだ画像一覧です。<br />
上に半透明の画像を重ねあわせていって上から見ています。<br />
色々できますので、遊んで体で覚えるのが良いと思います。</p>
<h3 id="解析結果のまとめ">解析結果のまとめ</h3>
<p>recon-allが終わった時点で、下記コマンドを入力しましょう。</p>
<pre data-frame="single"><code>asegstats2table --subjects hoge1 hoge2 hoge3 ...\
  --segno hoge1 hoge2 hoge3 ... --tablefile hoge.csv</code></pre>
<p>subjectにはsubject(つまり解析済みデータの通し番号)を入れます。<br />
segnoには見たい位置を入力します。その位置というのは<br />
$FREESURFER_HOME/FreeSurferColorLUT.txtに書かれていますので参照しましょう。</p>
<p>これでhoge.csvというファイルが出力されます。<br />
このファイルの中には既に脳の各部位のボリュームや皮質の厚さ等、<br />
知りたい情報が詰まっています。しかし、このまま使うのは危険です。<br />
freesurferは時にエラーを起こしますので、クオリティチェックと修正が必要です。</p>
<h3 id="画像解析の修正">画像解析の修正</h3>
<p>個別な修正はfreeviewを用いてすることになります。下記を参照して下さい。<br />
<a href="http://freesurfer.net/fswiki/Tutorials">Tutorials http://freesurfer.net/fswiki/Tutorials</a></p>
<p>このfreesurferのサイトには、説明用のスライドと動画があり、とてもいいです。<br />
以下、要約です。</p>
<ul>
<li>脈絡叢や各種膜を灰白質と間違える
<ul>
<li>freeviewで修正してrecon-all(オプション付き)</li>
</ul></li>
<li>白質の中で低吸収域を「脳の外側」と間違える
<ul>
<li>freeviewで修正してrecon-all(オプション付き)</li>
</ul></li>
<li>白質の中で薄い部分を灰白質と間違える(controlpointより小さい部分)
<ul>
<li>freeviewで修正してrecon-all(オプション付き)</li>
</ul></li>
<li>頭蓋骨をくりぬく時に間違って小脳などを外してしまう
<ul>
<li>recon-all(オプション付き)</li>
</ul></li>
<li>白質をfreesurferが少なく見すぎてしまう
<ul>
<li>freeviewでcontrolpointsを付け加えてrecon-all(オプション付き)</li>
</ul></li>
</ul>
<p>これは、問題にぶつかった時に上記サイトのスライドでも見ながら頑張るのが良いと思います。<br />
皮髄境界などはfreesurferは苦手としているそうです。<br />
<img src="img/freeview2.png" alt="freeviewによる編集" style="width:14cm" /></p>
<h4 id="skullstripのエラー">SkullStripのエラー</h4>
<p>Freesurferは脳だけを解析するためにSkull Stripという作業をします。要するに、頭蓋骨を<br />
外してしまうわけです。この時にwatershedmethod<a href="#fn43" class="footnote-ref" id="fnref43"><sup>43</sup></a>という方法を使うのですが、頭蓋骨を<br />
切り取ろうとして脳まで取ったり逆に眼球や脈絡叢まで脳と間違うことがあるので修正が必要です。</p>
<h4 id="脈絡叢の巻き込み">脈絡叢の巻き込み</h4>
<p>脈絡叢(血管の束とか)を巻き込んでいる場合はbrainmask.mgzを編集します。<br />
Brush value を255、Eraser valueを1にしてRecon editing<br />
shiftキーを押しながらマウスをクリックして脈絡叢を消していきます。編集がおわったら</p>
<pre data-frame="single"><code>recon-all -s &lt;subject&gt; -autorecon-pial</code></pre>
<p>とします。</p>
<h4 id="眼球が白質と間違われた時">眼球が白質と間違われた時</h4>
<p>上記と同様にして、編集がおわったら</p>
<pre data-frame="single"><code>recon-all -s &lt;subject&gt; -autorecon2-wm -autorecon3</code></pre>
<h4 id="頭蓋骨と間違って脳をえぐっているとき">頭蓋骨と間違って脳をえぐっているとき</h4>
<p>頭蓋骨と間違って脳実質まで取られた画像が得られた場合は</p>
<pre data-frame="single"><code>recon-all -skullstrip -wsthresh 35 -clean-bm -no-wsgcaatlas -s &lt;subj&gt;</code></pre>
<p>で調整します。この-wsthreshがwatershedmethodの閾値です。<br />
標準は25なのですが、ここではあまり削り過ぎないように35にしてます。</p>
<h4 id="白質の内部に灰白質があると判定されるとき">白質の内部に灰白質があると判定されるとき</h4>
<p>時々、白質の中の低吸収域を灰白質とか脳溝と間違えることがあります。これもfreeviewで編集します。<br />
wm.mgzを開いて色を付け、半透明にし、T1強調画像に重ねます。<br />
Brush value を255、Eraser valueを1にして<br />
Recon editingをチェックして編集します。</p>
<pre data-frame="single"><code>recon-all -autorecon2-wm -autorecon3 -subjid &lt;hoge&gt;</code></pre>
<h4 id="白質が厳しく判定されているとき">白質が厳しく判定されているとき</h4>
<p>実は、freesurferはbrainmask.mgzで白質を全部110という色の濃さに統一します。<br />
しかし、時々これに合わない脳があります。<br />
そんな時はbrainmask.mgzにコントロールポイントをつけてrecon-allをします。</p>
<p>File -&gt; New Point Setを選びます。<br />
Control pointsを選んでOKして、選ばれるべきだった白質を<br />
クリックしていきます。そして下記でいいそうです。</p>
<pre data-frame="single"><code>recon-all -s &lt;subject&gt; -autorecon2-cp -autorecon3</code></pre>
<h4 id="なんかコマンド難しくて死にたくなるな">なんか、コマンド難しくて死にたくなるな？</h4>
<p>「ああ！もう！シェルスクリプト作っちまえ！」と思いましたので、一筆。</p>
<pre data-frame="single"><code>recon-me () {
  recon-all -s $1 -autorecon2-wm -autorecon3
}

recon-myaku () {
  recon-all -s $1 -autorecon-pial
}

recon-hone () {
  recon-all -skullstrip -wsthresh $2 -clean-bm -no-wsgcaatlas -s $1
}

recon-gray () {
  recon-all -autorecon2-wm -autorecon3 -subjid $1
}

recon-gray () {
  recon-all -s $1 -autorecon2-cp -autorecon3
}</code></pre>
<p>これらをbashrcにでもぶち込んでおけば良いんじゃないかな？</p>

<h2 id="mricroncroglmriを使う場合">mricron/crogl(MRIを使う場合)</h2>
<p>MRIの形式って色々あります。例えば誰かの脳の画像を手に入れて、<br />
それを解析できなければ悲しいですね？<br />
そこで、変換ソフトが必要になります。<br />
ここではmricronとmricroglを紹介しますが、<br />
僕は後者のほうが新しいしトラブルも少ないのでいいと思います。<br />
実は他にMRIconverterとか言うのもあるらしいですが、<br />
僕はMRIの専門ではないのでよく分かりません…。</p>
<p>mricronはUBUNTUなら</p>
<pre data-frame="single"><code>sudo apt install mricron</code></pre>
<p>MACならhttp://www.mccauslandcenter.sc.edu/crnl/mricron/から<br />
インストーラーをダウンロードします。このmricronファミリーの中にあるdcm2niiというソフトが<br />
MRIの形式の変換に大変有用です。</p>
<p>さて、新しいmricroglですが、ここからダウンロード出来ます。<br />
<a href="http://www.mccauslandcenter.sc.edu/mricrogl/">http://www.mccauslandcenter.sc.edu/mricrogl/</a><br />
これはたまにmricronでは変換できないものを変換することが出来ます。</p>
<p>ちなみに、Debian系Linuxは神なので、Ubuntuなら下記で大丈夫です。</p>
<pre data-frame="single"><code>sudo apt install dcm2niix</code></pre>
<p>以上でfreesurfer/MNE/pythonのインストールは終了しました。<br />
これでゴリゴリ計算していくことができます。</p>
<h3 id="mriのファイルの変換">MRIのファイルの変換</h3>
<p>mricronもmricroglもmriの画像の閲覧が出来るソフトです。<br />
ちゃんと変換の前に内容を見ましょう。<br />
MRIって結構撮り損ないがあるものです。<br />
この中にdcm2niiというソフトがあるはずなので、そのソフトを起動します。<br />
mricronならdcm2niigui、mricroglならメニューからimport辺りを探して下さい。</p>
<figure>
<img src="img/nifti.png" alt="dcm2niiの画面" style="width:14cm" /><figcaption>dcm2niiの画面</figcaption>
</figure>
<figure>
<img src="img/mricron.png" alt="mricronによる3DMRI画像の閲覧" style="width:14cm" /><figcaption>mricronによる3DMRI画像の閲覧</figcaption>
</figure>
<p>例えば手元にあるMRIの形式がdicomならば、方言を吸収するためにNIFTI形式に直した方が<br />
僕の環境では安定していました。dcm2niiguiの画面にdicomのフォルダをドラッグしてください。<br />
ファイルが出力されるはずです。</p>
<p>さて、出力されたファイルですが、3つあるはずです</p>
<ul>
<li>hogehoge:単純にniftiに変換された画像</li>
<li>ohogehoge:水平断で切り直された画像</li>
<li>cohogehoge:脳以外の不要な場所を切り取った画像</li>
</ul>
<p>となります。どれを使っても構わないと思います。<br />
でも、大事なことがあります。<strong>使うソフトや変換の方法は合わせて下さい</strong><br />
なにやら、それぞれが微妙に違うのだそうです。MRIに詳しい人が言ってた。</p>

<h1 id="解析編">解析編</h1>
<p>いよいよ解析の準備に入ります。以下、MNEの公式サイトのチュートリアルなのですが…<br />
初心者が見るには敷居が高目です。要らない部分が結構あるし。<br />
一回はそれをなぞろうと思いますが、その後は噛み砕いてシンプルに紹介します。<br />
<a href="https://mne.tools/stable/auto_tutorials/index.html">https://mne.tools/stable/auto_tutorials/index.html</a></p>
<h2 id="肩慣らし">肩慣らし</h2>
<p>いきなり応用は無理だよ、という人に対する補習を行います。<br />
玄人は読み飛ばして下さい。</p>
<h3 id="mnepythonを使う前に学んでおくべきパッケージ">MNEpythonを使う前に学んでおくべきパッケージ</h3>
<p>とりあえず、pythonとnumpy<a href="#fn44" class="footnote-ref" id="fnref44"><sup>44</sup></a>の基礎を学ばねばなりません。<br />
これは最低限のことです。これが書けないのであればmne/pythonは無理です。</p>
<p>他に学んでおくべきパッケージはmatplotlibでしょう。<br />
scikit-learnもググってください。</p>
<p>初心者は毎日何らかの課題に向けてpythonスクリプトを書きましょう。<br />
毎日書いて下さい。大事なことなので2回言いました。<br />
指が覚えます。適当にググって良いサイトを見つければいいでしょう。<br />
Python入門から応用までの学習サイト<br />
<a href="http://www.python-izm.com/">http://www.python-izm.com/</a></p>
<h3 id="pythonを綺麗に書くために">pythonを綺麗に書くために</h3>
<p>プログラミング出来る人には釈迦に説法ですが、初心者の人に伝えたいことがあります。<br />
pythonに限らずプログラミングは中々奥が深いので、<br />
ある程度指が覚えたところで「綺麗なコード」を書かねばなりません。<br />
なぜなら、3ヶ月後に自分の書いたコードを読めなくなるからです。<a href="#fn45" class="footnote-ref" id="fnref45"><sup>45</sup></a><br />
僕のおすすめを書きます。</p>
<ul>
<li>mypy(pythonに静的型付けを導入するもの)</li>
<li>flake8(pythonの補完をしてくれるもの)</li>
<li>pep8(pythonを書くときのコーディング規約。即ちお作法)</li>
</ul>
<p>この辺りはエディタによって導入方法が違うので書きません。</p>
<h3 id="numpyで遊ぼう">numpyで遊ぼう</h3>
<p>詳しくはググって下さい。numpyは本書では語りつくせるわけがありません。以上です。</p>
<p>…ではあんまりなので、ほんのさわりだけ紹介しておきます。<br />
numpyとは行列計算のためのpython用パッケージです。</p>
<p>行列計算とは、高校数学の旧カリキュラムにおける数IIICの行列です。<br />
大学数学で皆に憎まれている、あの行列です。<br />
目を逸しそうになった人は、行列の意味を知らねばなりません。<br />
行列の意味は色々ありますが、ここでは<br />
「連立方程式とは四則演算である」という意味であります。<br />
本書に「割り算を極める」というセクションを書きましたので読むと良いでしょう。</p>
<p>Pythonの数値計算ライブラリ NumPy入門<br />
<a href="http://rest-term.com/archives/2999/">http://rest-term.com/archives/2999/</a></p>
<p>初心者の君は今思ったでしょう。「pythonならlistがあるから良くね？」<br />
ダメです！numpyはCやFORTRANで実装されており、超高速です。<br />
多分、100倍くらい。さらに、様々な数学的手法が実装されており、お得です。<br />
それ以前に、MNE-python自体がnumpyで実装されているので必須です。</p>
<pre data-frame="single"><code>import numpy as np
a = np.array([5, 6])
b = np.array([7, 8])</code></pre>
<p>解説します。<br />
1行目はnumpyを使うけれども長いからnpと略して使うよ、という意味です。<br />
ここはほぼほぼ慣習です。<br />
二行目と三行目で、aとbに5, 6と7, 8を代入しました。ここから下記を入力します。</p>
<pre data-frame="single"><code>print(a+b)</code></pre>
<p>結果</p>
<pre data-frame="single"><code>[12, 14]</code></pre>
<p>このように計算できます。<br />
ちなみに、numpyの配列と素のpythonのリストは違うものであり、素のpythonならこうなります。</p>
<pre data-frame="single"><code>a = [5, 6]
b = [7, 8]
print(a + b)</code></pre>
<p>結果</p>
<pre data-frame="single"><code>[5, 6, 7, 8]</code></pre>
<p>numpyと普通のlistはlist関数やnumpy.array関数で相互に変換できます。<br />
他にnumpy.arange等非常に有用です。</p>
<pre data-frame="single"><code>import numpy as np
np.arange(5, 13, 2)</code></pre>
<p>結果</p>
<pre data-frame="single"><code>array([5, 7, 9, 11])</code></pre>
<p>これは5〜13までの間、2刻みの数列を作るという意味です。<br />
そのほか、多くの機能がありMNEpythonのベースとなっています。<br />
出力結果がnumpy配列で出てくるので、MNEがあるとはいえ使い方は覚える必要があります。</p>
<p>numpyは多次元配列を表現できますが、その次元は<br />
shapeというメンバー変数に入っています。</p>
<pre data-frame="single"><code>import numpy as np
data = np.arange(5, 13, 2)
print(data.shape)</code></pre>
<p>結果は敢えて書きません。手を動かさなければ<br />
君は決してnumpyを使いこなせるようになりません。</p>
<h3 id="解析を始める前のwarning">解析を始める前のwarning!</h3>
<p>ここまでは単なるunix系の知識だけで済んでいましたが、この辺りからは数学の知識、<br />
pythonを流暢に書く技術、脳波脳磁図のデータ解析の常識等、色々必要です。<br />
pythonを書くのは本気でやればすぐ出来ますが、<br />
微分だとか行列計算を全部理解して応用するのはかなり面倒くさいです。<br />
時に、mne-pythonのソースコードを読む必要にかられます。<a href="#fn46" class="footnote-ref" id="fnref46"><sup>46</sup></a><br />
同人誌で完璧に説明するのは無理なので、一寸だけしかしません。<br />
また、データ解析の常識は進化が速いうえにその手の論文を<br />
読めていないと正確なところは書けません。<br />
僕の知能はチンパンジーレベルなのでここからは不正確な部分が交じるでしょう。<br />
本書は純粋な技術書であることに留意し、最新の知識を入れ続けましょう。</p>

<h3 id="jupyter用作図用おまじないセット">jupyter用作図用おまじないセット</h3>
<p>このへんのおまじないは素のpython使っているならいりませんが、<br />
jupyterやipythonのときは必要でしょう。</p>
<p>下記はjupyter/ipythonのコマンド</p>
<pre data-frame="single"><code>%matplotlib inline
%gui qt</code></pre>
<p>%matplotlib inlineについては、この設定ならjupyter上に表示されます。<br />
もし、別窓<a href="#fn47" class="footnote-ref" id="fnref47"><sup>47</sup></a>を作りたいなら、inlineを変えてください。<br />
python3の場合</p>
<pre data-frame="single"><code>%matplotlib qt5</code></pre>
<p>python2の場合</p>
<pre data-frame="single"><code>%matplotlib qt</code></pre>
<p>となります。<br />
下の%gui qtはmayaviによる3D表示のためのものです。<br />
mayaviがpython3で動くかどうかは僕はまだ確認してないです。</p>
<p>他に、こういうのもあります。</p>
<pre data-frame="single"><code>import seaborn as sns</code></pre>
<p>matplotlibの図を自動で可愛くしてくれるゆるふわパッケージです。</p>

<h2 id="データの読み込みとフィルタリングリサンプル公式サイト版">データの読み込みとフィルタリング・リサンプル(公式サイト版)</h2>
<p>ついに　MNEを使い始めます。まずは下記リンクを開けてください。<br />
<a href="http://martinos.org/mne/stable/python_reference.html">http://martinos.org/mne/stable/auto_tutorials/plot_artifacts_correction_filtering.html</a><br />
ちょっと小難しい文法を使っているように見えます。<br />
小難しい部分は初心者は混乱するだけなので無視してください。<br />
難しいなら読み飛ばして、次に移ってください。簡単にまとめています。<br />
公式サイトでは脳磁図前提としていますが、ここではついでに脳波の読み込みの解説もやります。<br />
是非脳波、脳磁図のファイルを手元において、読み込んだり<br />
フィルタを掛けてみてください。(でないと、覚えられません)</p>
<p>ここでは</p>
<ul>
<li>データの読み込み</li>
<li>パワースペクトル密度のプロット(以下psd)<a href="#fn48" class="footnote-ref" id="fnref48"><sup>48</sup></a></li>
<li>notch filterとlow pass filterを使って要らない波を除去する</li>
<li>サンプリングレートを下げて処理を軽くする</li>
</ul>
<p>をしています。</p>
<p>はじめのパラグラフ<a href="#fn49" class="footnote-ref" id="fnref49"><sup>49</sup></a>で大事な関数は以下です。</p>
<ul>
<li>mne.io.read_raw_fif:脳磁図のデータを読み込みます。<br />
ここではつけていませんが、通常preload=Trueをつけた方がいいです。<br />
preloadをつけると、メモリ上に脳磁図データを読み込み、<br />
色々と処理ができるようになります。(付けないと処理できないです…)<br />
脳波を解析するなら下記公式サイトの<strong>Reading raw data</strong>セクションに<br />
各種形式に対応した読み込み関数が書いてありますから、読み替えてください。<br />
<a href="http://martinos.org/mne/stable/python_reference.html">http://martinos.org/mne/stable/python_reference.html</a></li>
</ul>
<p>読み込みの詳細は後で書きます。<br />
- mne.read_selection:脳磁図の一部を取り出しています。<br />
- mne.pick_types:データの中から欲しいデータだけ取り出します。<br />
- plot.psd:psdプロットを行います。</p>
<p>基本は体で慣れるしかありませんが、大抵のエディタでは<br />
tabキーとかを押せば補完してくれるので、入力自体は楽です。<br />
例えば「raw.」と書いてtabを押せば、plot関数だけでも色々出てきます。<br />
だから、色々プロットして遊んでみてください。</p>
<p>次のcellではnotch filterをかけています。</p>
<ul>
<li>notch_filter<br />
これは特定の周波数を削除するフィルタです。<br />
何故それをするかというと、送電線の周波数が影響するからです。<br />
西日本では60Hz、東日本では50Hzです。それを除去できます。<a href="#fn50" class="footnote-ref" id="fnref50"><sup>50</sup></a><br />
関数内にnp.arangeと書いてあるのはnumpyの関数。<br />
60から241までの間で60ごとの等差数列を返すものです。<br />
つまり、ここでは60Hzを除去しています。</li>
</ul>
<p>次にlow pass filterをかけます。</p>
<ul>
<li>filter<br />
これは分かりやすいでしょう。ある周波数以上、以下の波を除去します。<br />
バンドパスフィルタと言います。<br />
ERPをする時は遅い周波数成分を除去するときは注意が必要です。<br />
その場合は0.1Hz未満でするのがいいのかもしれません。<br />
また、ICAでノイズ除去する時は1Hzくらいでかけるといいです。</li>
</ul>
<p>最後にサンプリングレートを変えています。<br />
理由は今後処理がかなりのものになるので負担を軽くしたいからです。</p>
<ul>
<li>resample<br />
ここでは100Hzまで下げていますが、最低見たい周波数の2〜3倍以上の周波数が必要です。<br />
また、周波数は元の周波数の約数である必要があります。<br />
というか、普通resampleとか必要ないんですが、何かここではやっていますね。</li>
</ul>
<p>以上…MNEの公式サイトは一寸詳しいです。初心者にはちょっとつらかったですね…。<br />
よしよし。</p>
<h2 id="データの読み込みとfilterresample僕の解説">データの読み込みとfilter,resample(僕の解説)</h2>
<p>公式サイトはpythonをバリバリ書ける上に生理学をきちんと理解できている人向けに感じます。<br />
本書はあくまで初心者向けです。<br />
先ずは大雑把に理解して体を動かすべきと思うので、以下は極めて乱暴な僕なりのまとめです。<br />
大まかに理解した上で公式サイトに取り組めば良いのではないでしょうか？</p>
<p>極めて乱暴にまとめると、ノイズ取りの第一段階はこうです。</p>
<pre data-frame="single"><code>raw = mne.io.read_raw_fif(&#39;hoge&#39;,preload=True)    #読み込み
raw.filter(1,100)    #0.1~100Hzの波だけ残すバンドパスフィルタ
raw.notch_filter([60,100])    #この場合、60と100Hzを消してる
raw.save(&#39;fuga&#39;)</code></pre>
<p>…ていうか、このくらい雑な例のほうが良いと思う。</p>
<p>ちなみに、第0段階があります。それはbadchannnelの指定、interpolation、maxfilter等ですが、<br />
とりあえず読めなきゃ話にならないので。</p>
<ul>
<li>1行目で読み込みます。脳波と脳磁図では読み込み方が違うので、次セクションを参照。<br />
preloadをTrueにしてください。そうしないとメモリ上に読み込んでくれません。<a href="#fn51" class="footnote-ref" id="fnref51"><sup>51</sup></a><br />
fifというのは適当に読み替えて下さい。</li>
<li>2行目でバンドパスフィルタかけてます。1Hz未満の波と、100Hz以上の波を消しています。<a href="#fn52" class="footnote-ref" id="fnref52"><sup>52</sup></a></li>
<li>3行目で送電線のハムノイズを取っています。<a href="#fn53" class="footnote-ref" id="fnref53"><sup>53</sup></a></li>
<li>4行目でデータを間引いて処理を軽くしています。必ず元データの約数に設定し、<br />
wavelet変換するならばwavelet変換の最高の周波数の2〜3倍以上の周波数にしてください。<br />
というか、僕ならresampleはしません。データが荒くなるからです。</li>
<li>5行目で掃除した結果を’fuga’という名前で保存しています。</li>
</ul>
<p>あとは、plotを色々してみてください。</p>
<p>以下、本書ではこのような乱暴な解説をしてとりあえず手で覚えた後、<br />
理屈を覚えていくスタイルにしていきます。</p>
<h2 id="脳波読み込みの問題">脳波読み込みの問題</h2>
<p>脳波はすんなり読み込めたでしょうか？そうでもないかもしれないですね。<br />
なにしろ、脳磁図と違って脳波は沢山の形式があるのです。<br />
例えば、ヘッダーファイルを要求する形式があったりもしますし、<br />
モンタージュや眼球運動チャンネルの設定を追加せねばならぬ場合もあります。<br />
このセクションは試行錯誤が要求されます。</p>
<p>ちなみに、mneはmne.io.read_raw_hogeって感じで色々なデータに対応しています。<br />
やたら対応できるのは多いので適当に見て下さい。</p>
<p>さて…脳波は色々な企業が参入していますが、<br />
脳波のファイルには以下の情報が入ってたり入ってなかったりです。</p>
<ul>
<li>波形データ</li>
<li>チャンネル名と空間データ</li>
<li>測定条件</li>
</ul>
<p>このあたりは脳波計のユーザーが設定できる所もあったりするので、<br />
脳波計の管理者に聞いたりするのが早いかもしれません。<br />
また、モンタージュ(センサーの空間情報)を指定せねばならぬ事もあります。<br />
例えばbiosemiの場合は下記のように書きます。</p>
<pre data-frame="single"><code>raw = mne.io.read_raw_edf(
    filename,
    preload=True,
    montage=&#39;biosemi64&#39;,
    eog=[&#39;eye-l&#39;,&#39;eye-r&#39;],
    exclude=[&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;,&#39;X4&#39;]
)</code></pre>
<p>解説します…。</p>
<ul>
<li>filename<br />
これは問題ないですね</li>
<li>preload<br />
これも問題ないです。前のセクションを御覧ください。</li>
<li>montage<br />
これは場合によっては問題ありですのであとで解説します。</li>
<li>eog<br />
これは、眼球運動は何番目のチャンネルだよ、というやつですね。単純。</li>
<li>exclude<br />
これは、このチャンネルはいらないよ、というやつです。<br />
余りチャンネルが有ることは日常茶飯事です。数字で指定もできます。</li>
</ul>
<h3 id="日本光電">日本光電</h3>
<p>最近mneでは日本光電の形式を読めるようになりました。<br />
これで病院づとめの人も脳波解析が出来ますね！<br />
mne.io.read_nihon関数です。<br />
なんか、日本国を呼んでいる感じがして名前がデカいですね！</p>
<h3 id="edfでevent情報が読み込めない場合">EDFでevent情報が読み込めない場合</h3>
<p>EDF形式はかなりメジャーな脳波の形式です。<br />
event情報が文字列として入ってたりします。<br />
そんな時はMNEpythonでは読めません。なので、別のソフトを使います。<br />
使うソフトはpyedflibです。インストールしましょう。</p>
<pre data-frame="single"><code>pip install pyedflib</code></pre>
<p>そして、コードを書くのですが、たいへん面倒いです。</p>
<pre data-frame="single"><code>import pyedflib
edf = pyedflib.EdfReader(&#39;hoge.edf&#39;)
annot = edf.read_annotation()</code></pre>
<p>これでannot(list形式)にイベント情報が入ります。<br />
しかし、annotの中を覗くと分かると思いますが、たまーにこのannotの中に<br />
2行で1つのイベントとかが入ってたりして、そいつを1つのイベントとして<br />
書き直すスクリプトを書かないといけなかったりするので面倒臭いです。<br />
頑張って書いて下さい。</p>
<h3 id="edfが少しも読み込めない場合">EDFが少しも読み込めない場合</h3>
<p>EDF形式はメジャーなのですが、そんな中にも色々な形式があります。<br />
EDF+CだとかEDF+Dだとか。EDF+Dは凄く読み込みにくいです。<br />
pyedflibはEDF+Dを読めません。しかし、万事休すではありません。<br />
open sourceのいいソフトがあります。edfbrowserというソフトです。</p>
<p><a href="https://www.teuniz.net/edfbrowser/">https://www.teuniz.net/edfbrowser/</a></p>
<p>このサイトにはwindows版が公開されていますね。<br />
このソフトはtoolsメニューからEDF+DをEDF+Cに変換する事ができます。</p>
<p>macやlinuxの人はコンパイルしてください。<br />
このサイトにはmacのコンパイルの仕方が書いてありませんが、<br />
それはこのようにします。<br />
まず、xcodeをapp_storeからインストールします。<br />
そして、homebrewをインストールします。ググってください。<br />
その上で、下記のようにしてgitとqtをインストールします。</p>
<pre data-frame="single"><code>brew install qt
brew install git</code></pre>
<p>そして、ソースコードをダウンロードします。<br />
ソースコードのフォルダの中で、</p>
<pre data-frame="single"><code>qmake
make</code></pre>
<p>とすると、バイナリが出来上がります。</p>
<h3 id="脳波のセンサーの位置が変則的な場合">脳波のセンサーの位置が変則的な場合</h3>
<p>さて…montageの話をします。montageは要するにセンサーの空間情報です。<br />
この世には色々な脳波の取り付け方があります。「は？10-20法しかねえよ！」<br />
と言われそうですが、あるものは仕方ないのです。センサーの数の違いもありますし。</p>
<p>MNEpythonでは出来合いのモンタージュセットがあります。<br />
10-20法ならだいたいセンサーはこの辺だよ、というやつですね。<br />
それは上記のように文字列で指定できます。大抵はこれで事足ります。<br />
しかし、時々凄くニッチなセンサー配置の脳波計があったりします。<br />
そういうのはMNEpythonで対応できないこともしばしばです。<br />
そんな時には文字列じゃなくてモンタージュ情報を別途読み込んで、<br />
montage変数に入れなきゃなりません。めんどいです。<br />
詳しくはmne.ioの解説記事をみて下さい。形式ごとの解説記事があります。</p>
<p>ちなみに下記のようにrawを読み込んだ後で指定する事も可能です。</p>
<pre data-frame="single"><code>from mne.channels import read_montage
mont = read_montage(&#39;standard_1020&#39;)
raw.set_montage(mont)</code></pre>
<h3 id="脳波のセンサーからソースベース出来んの">脳波のセンサーからソースベース出来んの？</h3>
<p>これについては大きな声では言いたくないのですが、出来ます。<br />
ちょっと捻ったやり方が必要です。<br />
ただし、脳波のセンサーを位置情報としたソースベース解析が<br />
どの程度の精度を持っているかは…お察しください。</p>
<p>まず、上記のraw.set_montage(mont)に一つオプションを入れます。</p>
<pre data-frame="single"><code>raw.set_montage(mont, set_dig=True)</code></pre>
<p>これをすると、raw.infoの中にraw.info[‘dig’]という項目が入ります。<br />
このdigの中に位置情報が入りますから、これを使って位置合わせが出来ます。</p>
<p>さて、これを僕がやってみた時に、<br />
どういうわけかmegのmontage情報に比べて縮尺がやたら大きかったです。<br />
僕がやったときはなんと千倍のサイズでした()<br />
この大きさになると無理感が出てくるので、ちっちゃくしちゃいました。</p>
<pre data-frame="single"><code>for n in raw.info[&#39;dig&#39;]:
    n[&#39;r&#39;]=n[&#39;r&#39;]/1000</code></pre>
<p>無理矢理感あふれるやり方ですね…。<br />
こうすることにより、MEGと同じ様にmne coregが出来るようになりました。<br />
皆さんは皆さんの条件に合わせて格闘して下さい。<br />
mne coregについては後述します。ソースベース解析の所を御覧ください。</p>
<h3 id="脳波のセンサーの名前が変則的な場合">脳波のセンサーの名前が変則的な場合</h3>
<p>もう一つかなり面倒くさい問題があります。<br />
MNEpythonはチャンネルの位置情報を自動で設定する時に<br />
ファイルの中に記述されているチャンネルの名前を参照して<br />
位置情報を当てはめていきます。これの何が困るのでしょうか？</p>
<p>脳波計がmontageの’Fp1’という風な普通の名前で出力してたら良いのですが、<br />
例えば’EEG-Fp1’という風な名前だったら名前を変えてあげないと読めないのです。<br />
名前は大事なのです。</p>
<p>変える方法としては、raw.rename_channels関数を使う方法があります。<br />
<a href="https://mne-tools.github.io/stable/generated/mne.channels.read_montage.html#mne.channels.read_montage">mne.channels.read_montage</a>の解説記事を開いてみて下さい。</p>
<p>まず、チャンネルの名前を表示しましょう。<br />
いっぱいモンタージュ情報が書いてありますが、ここでは10-20法を見てみます。</p>
<pre data-frame="single"><code>mont = mne.channels.read_montage(&#39;standard_1020&#39;)
print(mont.ch_names)
mont.plot()</code></pre>
<p>凄くたくさんのチャンネル名と図が出てきましたね？<br />
次に、読み込んだ脳波のチャンネルリストを見てみましょう。</p>
<pre data-frame="single"><code>print(raw.ch_names)</code></pre>
<p>チャンネル名が同じ名前になっているでしょうか？<br />
なっていなかったら書き換えていかねばなりません。<br />
書き換えるには、pythonの辞書形式を利用します。<br />
2つのチャンネル名をよーく見比べて変えていって下さい。<br />
下記のような辞書を作っていきます。</p>
<pre data-frame="single"><code>channel_list = {
    &quot;EEG Fp1-Ref&quot;: &quot;Fp1&quot;, &quot;EEG Fp2-Ref&quot;: &quot;Fp2&quot;,
    &quot;EEG F3-Ref&quot;: &quot;F3&quot;, &quot;EEG F4-Ref&quot;: &quot;F4&quot;,
    &quot;EEG C3-Ref&quot;: &quot;C3&quot;, &quot;EEG C4-Ref&quot;: &quot;C4&quot;,
    &quot;EEG P3-Ref&quot;: &quot;P3&quot;, &quot;EEG P4-Ref&quot;: &quot;P4&quot;,
    &quot;EEG O1-Ref&quot;: &quot;O1&quot;, &quot;EEG O2-Ref&quot;: &quot;O2&quot;,
    &quot;EEG F7-Ref&quot;: &quot;F7&quot;, &quot;EEG F8-Ref&quot;: &quot;F8&quot;,
    &quot;EEG T3-Ref&quot;: &quot;T3&quot;, &quot;EEG T4-Ref&quot;: &quot;T4&quot;,
    &quot;EEG T5-Ref&quot;: &quot;T5&quot;, &quot;EEG T6-Ref&quot;: &quot;T6&quot;,
    &quot;EEG Fz-Ref&quot;: &quot;Fz&quot;, &quot;EEG Cz-Ref&quot;: &quot;Cz&quot;,
    &quot;EEG Pz-Ref&quot;: &quot;Pz&quot;,&quot;EEG A1-Ref&quot;:&quot;A1&quot;,
    &quot;EEG A2-Ref&quot;:&quot;A2&quot;}</code></pre>
<p>脳波の基準電極や眼球運動や心電図もこんな風に辞書にして下さい。<br />
では、この辞書を使ってチャンネル名を変えましょう。</p>
<pre data-frame="single"><code>raw.rename_channels(channel_list)</code></pre>
<p>これで、脳波のチャンネルの名前を変え終わりました。<br />
最後に、用意したmontageと脳波をくっつけます。</p>
<pre data-frame="single"><code>mont=mne.channels.read_montage(&#39;standard_1020&#39;)
raw.set_montage(mont)</code></pre>
<p>これで上手くいけば普通にMNEpythonで解析できます。</p>
<h3 id="基準電極">基準電極</h3>
<p>基準電極の設定は下記のような感じでできます。</p>
<pre data-frame="single"><code>raw = mne.set_eeg_reference(
  raw, ref_channels=[&#39;LMASTOID&#39;])[0]</code></pre>
<p>が、普通脳は研究では全体の平均で設定することが多いようですから、下記のようなのが普通でしょうか。</p>
<pre data-frame="single"><code>raw2=mne.set_eeg_reference(raw)[0]</code></pre>
<p>ちなみに、初期設定では全体の平均を基準電極としていますから、この設定は実は不要です。</p>
<p>末尾の[0]はこの関数がlist形式で結果を出してくるから必要です。<br />
詳細は<br />
http://martinos.org/mne/stable/python_reference.html<br />
を見て、各自読み替えてください。</p>
<p>このようなスクリプトははじめは面倒ですが、<br />
一度書いてしまえば後は使いまわしたり自動化出来ます。</p>
<h3 id="トリガーチャンネル">トリガーチャンネル</h3>
<p>もう一つの鬼門がトリガーチャンネルです。つまり、刺激提示の時刻を記録したものです。<br />
これは通常下記で表示できます。</p>
<pre data-frame="single"><code>mne.find_events(raw)</code></pre>
<p>rawの中の刺激提示チャンネルが読めない場合はどうにかしてテキスト形式とかで書き出してください。<br />
そこからは…貴方はもちろんpythonistaなので書けるはずです。<br />
例えば、pandasを使って</p>
<pre data-frame="single"><code>import pandas as pd
shigeki=pd.read_csv(&#39;hoge.csv&#39;)</code></pre>
<p>後はゴリゴリスクリプト書いてください。</p>
<p>僕もこのようなトリガーチャンネルについて苦労しました。<br />
僕の場合はトリガーが脳波と同じように波形として記録されていたのです。脳波の波形は</p>
<pre data-frame="single"><code>raw.get_data()</code></pre>
<p>で出力することが出来ます。内容はチャンネルごとのnumpy形式の数列です。<br />
サンプリング周波数を鑑みてがんばってください。<br />
トリガーチャンネルは信号が入ったら波形が跳ね上がっていたので、<br />
僕はその跳ね上がりを検知するようなスクリプトを書くことで解決しました。</p>

<h2 id="bad-channelの設定">bad channelの設定</h2>
<p>苦行その1です。次にダメなチャンネルの設定や眼球運動の除去を行います。<br />
http://martinos.org/mne/stable/auto_tutorials/plot_artifacts_correction_rejection.html<br />
これには2つのやり方があります。</p>
<h3 id="やり方1">やり方1</h3>
<p>raw.plot()でデータを見ながらひたすら下記のように<br />
badchannelを設定していってください。それだけです。</p>
<pre data-frame="single"><code>raw.info[&#39;bads&#39;] = [&#39;MEG 2443&#39;]</code></pre>
<p>badchannelは、例えば明らかに一個だけ滅茶苦茶な波形…<br />
振幅が大きくて他のとぜんぜん違う動きしているとか、<br />
物凄い周波数になっているとか、毛虫っぽいとか、そういうやつを選んでください。</p>
<h3 id="やり方2おすすめ">やり方2(おすすめ)　</h3>
<pre data-frame="single"><code>raw.plot()</code></pre>
<p>をした上で、画面上でポチポチクリックしていけば、rawにbadが<br />
入っていくように出来ています。便利ですね！<br />
もちろん、あとで保存しないとちゃんと残りません。</p>
<pre data-frame="single"><code>raw.save(&#39;hoge.fif&#39;)</code></pre>
<p>pythonの対話モードを使って毎回一々やっていくのは超絶面倒なのでスクリプトにしたいかと思います。<br />
しかし、その場合plotし終わったらすぐpythonが終了して図が即消えます。<br />
それを防ぐには以下の一行を入れましょう。</p>
<pre data-frame="single"><code>input()</code></pre>
<h3 id="interpolation">interpolation</h3>
<p>選び終わったら、badchannelを補正します。<br />
隣接するチャンネルを平均したようなやつで置き換えることになります。<br />
それには下記を走らせるだけでいいです。</p>
<pre data-frame="single"><code>raw.interpolate_bads()</code></pre>
<p>後でbadchannelを無視したICAを掛けるとか、色々出来るわけです。</p>
<h3 id="maxfilter">maxfilter</h3>
<p>ここはEEGには不要です。<br />
しかし、MEGはEEGと違ってノイズがのりやすいです。<br />
何故なら、地球の磁力は脳みその磁力の1000倍だからです！<br />
MEG使う人はmaxfilterを使ってノイズを除去することが出来ます。<br />
maxfilterはelekta製のとmne製のがあります。</p>
<p>ここではmne製のを紹介します。<br />
<a href="https://mne-tools.github.io/stable/generated/mne.preprocessing.maxwell_filter.html">https://mne-tools.github.io/stable/generated/mne.preprocessing.maxwell_filter.html</a></p>
<p>さて、maxfilterには2つファイルが必要です。<br />
この2つのファイルは、それぞれの施設によって違うものです。<br />
一つはcalibration用のdatファイル、一つはcrosstalk用のfifファイルです。<br />
これについてはelektaの機械ならあるはずなので、そこから抜き出すといいでしょう。<br />
ここについては僕は詳しくないので、周囲の賢者に聞いて下さい。</p>
<p>もう一つ、MNEのmaxfilterには特徴があって、badchannelを設定してあげないとうまく動きません。<br />
因みに、elektaのは自動でbadchannelを設定しちゃうそうです。</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb103-1" title="1"><span class="im">from</span> mne.preprocessing <span class="im">import</span> maxwell_filter</a>
<a class="sourceLine" id="cb103-2" title="2">cal <span class="op">=</span> <span class="st">&#39;hoge.dat&#39;</span></a>
<a class="sourceLine" id="cb103-3" title="3">cross <span class="op">=</span> <span class="st">&#39;fuga.fif&#39;</span></a>
<a class="sourceLine" id="cb103-4" title="4">raw <span class="op">=</span> maxwell_filter(raw,calibration<span class="op">=</span>cal,</a>
<a class="sourceLine" id="cb103-5" title="5">                     cross_talk<span class="op">=</span>cross, st_duration<span class="op">=</span><span class="dv">10</span>)</a></code></pre></div>
<p>このmaxwell_filter関数で行います。<br />
calibrationとcross_talkは見てのとおりと思いますが、st_durationも大事なやつです。<br />
MNEpythonの標準の設定ではst_durationはNoneなのですが、<br />
実際は数値を設定しないと酷いことになります。<br />
公式サイトには「俺たちのMEGはキレイだからNoneで良いんだ」と<br />
ドヤ顔していましたが、町中のMEGだと地下鉄通るだけで酷いことになるので、<br />
大草原の小さなラボとかでないなら設定してあげましょう。<br />
元祖elekta maxfilterではここが10になっています。</p>
<p>このst_durationの数字は実はhighpass filterの役割も果たします。だから、注意が必要です。<br />
1/st_duration以下の周波数がカットされるので、遅い周波数を見たい人は気をつけて下さい。<br />
その他、いろいろな理由でst_durationは出来れば大きな値が良いそうですが、<br />
計算コストが上がるという欠点がありますので、程々に。</p>
<h2 id="icaでノイズを取ろう">ICAでノイズを取ろう</h2>
<p>苦行その2です。<br />
ICAは日本語で言うと独立成分分析と言い、古典的機械学習の一種です。<br />
つっても、波形に関する機械学習でいえば大変有用です。<a href="#fn54" class="footnote-ref" id="fnref54"><sup>54</sup></a><br />
10個の耳で聞いた一つの音を、10個の「有効っぽい成分」に分けちゃう方法です。</p>
<p>何故ICAをするかというと、ノイズ取りです。<br />
前回やったノイズとは違うノイズを取ります。<br />
例えば眼球運動や心電図、場合によっては筋電図です。<br />
眼球運動や心電図は特徴があるので、ICAで分けた時分かれてくれるのですね！</p>
<p>順を追って内容を説明します。</p>
<pre data-frame="single"><code>from mne.preprocessing import ICA
from mne.preprocessing import create_eog_epochs, create_ecg_epochs</code></pre>
<p>まずは、ICAのモジュールをインポートします。</p>
<pre data-frame="single"><code>picks_meg = mne.pick_types(raw.info, meg=True,
                           eeg=False, eog=False,
                           stim=False, exclude=&#39;bads&#39;)</code></pre>
<p>次に、どのような波にICAをかけるか選びます。基本、解析したい脳磁図(脳波)に<br />
ICAをかけるので、それをTrueにします。badchannelも弾きます。</p>
<pre data-frame="single"><code>n_components = 25  
method = &#39;fastica&#39;  
decim = 4  
random_state = 9</code></pre>
<p>n_componentsはICAが分ける波の数です。<br />
ICAで分ける波の数は何個が良いのか僕にはよく分かりませんが、<br />
あまり少なすぎないほうがいいでしょう。<br />
ここではひとまず適当に25個にしています。</p>
<p>methodはicaの方法です。方法は三種類選べます。API解説ページをご参照ください。</p>
<p>decimはどの程度詳しくICAをかけるかの値です。<br />
数字が大きくなるほど沢山かけますが、数字を入力しなければ最大限にかけます。</p>
<p>random_stateは乱数発生器の番号指定です。<br />
pythonでは乱数テーブルを指定することが出来ます。<br />
そうすると、再現可能な乱数(厳密には乱数ではない)が生成できるようになります。<br />
実はICAは乱数を使うので、結果に再現性がないのですが、<br />
この擬似乱数テーブルを用いることにより再現性を確保しつつ乱数っぽく出来るのです。<br />
(狡いけど)便利ですね！</p>
<pre data-frame="single"><code>ica = ICA(n_components=n_components,
          method=method, random_state=random_state)
raw = raw.filter(1, 100)
ica.fit(raw, picks=picks_meg, decim=decim,reject = dict( grad=4000e-13))</code></pre>
<p>ここで、rawに周波数フィルタをかけています。これはICAが低周波の影響を<br />
受けやすく、ノイズをとることに失敗してしまうのを防ぐためです。</p>
<p>icaで特徴を抽出し、データに適用しています。<br />
この時点ではまだ何も起こっていません。下記を実行してください。<br />
jupyterなら先に%matplotlib qtと入力した上でです。<br />
分離した波(特徴)が表示されます。</p>
<pre data-frame="single"><code>ica.plot_sources(raw)</code></pre>
<figure>
<img src="img/ICA_wave.png" alt="icaで分離した波。明らかに眼球運動や心電図が分離された図が出てくると思います。" style="width:14cm" /><figcaption>icaで分離した波。明らかに眼球運動や心電図が分離された図が出てくると思います。</figcaption>
</figure>
<p>チャンネル名のところをクリックするとtopomapが表示されます。<br />
個人的には生波形を見るのが明快で好きです。</p>
<p>ちなみに、これを凄く詳しく見るには下記のようになります。重いですが、これも結構良いです。</p>
<pre data-frame="single"><code>ica.plot_properties(raw, picks=0)</code></pre>
<figure>
<img src="img/ICA_property1.png" alt="ica propertyの図。左上を御覧ください。これこそが典型的な眼球運動のtopomapです。" style="width:14cm" /><figcaption>ica propertyの図。左上を御覧ください。これこそが典型的な眼球運動のtopomapです。</figcaption>
</figure>
<p>最後に、0番目と10番目の波をrawデータから取り除きます。</p>
<pre data-frame="single"><code>filtered_raw=ica.apply(raw,exclude=[0,10])</code></pre>
<p>ここでのrawはフィルタを掛けていないraw…で良いのか僕はよく分かりません。<br />
ともかく、これでicaは終わりです。<br />
上記の出力結果や取り除いたチャンネル、random_stateは保存しておきましょう。<br />
random_stateを保存しておくことでICAに再現性が生まれます。<br />
(狡いんですけどね)</p>
<h2 id="icaコンポーネントのより良い取り除き方">ICAコンポーネントのより良い取り除き方</h2>
<p>実際に上記を手動でやるのは恣意的になったり、再現性が無かったり、<br />
面倒臭すぎたりして、なにより面倒くさいので僕は大嫌いです！<br />
(大事なことなので二回言いました)<br />
それはともかく、抜く波が恣意的になるのはいただけません。<br />
例えば病人だけに出る波が欲しい時に健常者から波を抜きまくってしまう<br />
姑息な事をする輩が居るかも知れません。それはいただけません。</p>
<p>そこで、もっとクールなやり方が2つあります。</p>
<h3 id="自動判定">自動判定</h3>
<p>眼球運動チャンネルや心電図をとっていたら、それに似てるやつを<br />
自動判定してくれる機能がMNE-pythonにはあります、やったね！やり方は以下のとおりです。</p>
<p>まずは、眼球運動がある場所を眼球運動によってepochを作ります。</p>
<pre data-frame="single"><code>from mne.preprocessing import create_eog_epochs

eog_epochs = create_eog_epochs(raw, reject=reject)
eog_inds, scores = ica.find_bads_eog(eog_epochs)</code></pre>
<p>簡単ですね！eog_indsは眼球運動に超似ているチャンネルの番号リストです。<br />
scoresはどれだけ似ているかの度合いです。とりあえず、plotしましょう。</p>
<pre data-frame="single"><code>ica.plot_scores(scores, exclude=eog_inds)</code></pre>
<p>どれが悪いコンポーネントかがplotされたかと思います。<br />
では、どの程度浮き立っているか確認しましょう。</p>
<pre data-frame="single"><code>ica.plot_sources(eog_epochs.average(), exclude=eog_inds)</code></pre>
<p>浮き立っている度合いがわかったかと思います。では、詳しく見てみましょう。</p>
<pre data-frame="single"><code>ica.plot_properties(eog_epochs, picks=eog_inds)</code></pre>
<p>詳しいですね！いい感じであれば一網打尽にしてしまいましょう。</p>
<pre data-frame="single"><code>ica.exclude = eog_inds
ica.apply()</code></pre>
<p>心電図については殆どこいつがecgになっただけだから、もう解説はしません。</p>
<h3 id="半自動判定">半自動判定</h3>
<p>眼球運動チャンネルや心電図をそもそも取っていない時はどうするのでしょう？<br />
その時は一部のコンポーネントを「根本的なノイズだよ」と指定して、<br />
それに似ているコンポーネントを一網打尽にすることが出来ます。では、やっていきましょう。</p>
<p>まずは、ICAのオブジェクトをいっぱい作ります。上記のICA.fit()で出来るやつですね！<br />
で、それらを沢山並べてリストにします。<br />
リストにしたものを作る時、きっと時間がかかるので、ICA.saveで保存してから<br />
読み込むほうが良いでしょうね。<br />
超絶面倒なのでmap関数を使います。(沢山の物に同じ関数を適用する関数)</p>
<pre data-frame="single"><code>from mne.preprocessing import read_ica
ica_paths = [&#39;hoge.fif&#39;, &#39;fuga.fif&#39;, &#39;piyo.fif&#39;]
icas = list(map(read_ica, ica_paths))</code></pre>
<p>で、このicaのリストの中から典型的なノイズを選んできます。<br />
例えば5番目のicaの3番目のコンポーネントがノイズっぽい場合はこうします。</p>
<pre data-frame="single"><code>template = (5, 3)</code></pre>
<p>で、corrmapという関数にぶち込みます。</p>
<pre data-frame="single"><code>from mne.preprocessing import corrmap
corrmap(icas, template, threshold=&#39;auto&#39;, label=None,
    ch_type=&#39;eeg&#39;, plot=True, show=True,
    verbose=None, outlines=&#39;head&#39;,
    layout=None, sensors=True, contours=6, cmap=None)</code></pre>
<ul>
<li>icas: 要するにさっきのリストです</li>
<li>template: さっきのテンプレートです</li>
<li>threshold: どのくらい似てるものまで引っ掛けるかです。<br />
標準は’auto’なんですが、’auto’では中々何も引っかかりません。</li>
<li>label: 引っ掛けたやつにつけるラベルです。文字列入れて下さい。</li>
<li>ch_type: eegならeegですし、megならmagとかgradになります。</li>
</ul>
<p>だいたい、そんな感じです。corrmapをplot=Trueの条件でかけると、<br />
いっぱい似てるやつが引っかかってきます。<br />
labelに何か入れていれば、icaにラベルがつきます。<br />
ica.labels_に格納されており、labelの情報は辞書形式です。</p>
<pre data-frame="single"><code>{&#39;eog&#39;: [1], &#39;ecg&#39;: [2]}</code></pre>
<p>この例では、labelを’eog’と’ecg’の二回分corrmapをまわしたときの結果みたいなもんですな！</p>
<p>どの程度の閾値にすれば適切か分かんないので試行錯誤しましょう。<br />
corrmapは違うラベルでやれば、違うラベルがどんどん追加されていきます。</p>
<p>ところで、ラベルに情報が入っても、print(ica.labels_)みたいに<br />
しないと貴方はそれを見れません。<br />
plotしてくれないのです…これでは実際のsourcesがどんな感じか分かりませんね？</p>
<pre data-frame="single"><code>raw = Raw(&#39;hoge.fif&#39;)  # ダメな例
icas[0].plot_sources(raw)</code></pre>
<p>labelに情報が入るだけなのでこのままではダメです。</p>
<p>ica.excludeはList形式なのでこれをどうにかしたいですね。<br />
まぁ、せいぜい工夫して下さい。僕ならこうします。</p>
<pre data-frame="single"><code>from operator import add
from functools reduce

ica.exclude = list(set(reduce(add, ica.labels_.values())))</code></pre>
<p>setは重複のない値を格納するオブジェクト、reduceは調べて下さい。</p>
<p>python初学者は面食らうやり方ですね。こういう風にベタにかいてもいいですね。</p>
<pre data-frame="single"><code>for n in ica.labels_.values():
    if n not in ica.exclude:
        ica.exclude += n</code></pre>
<p>こうしてやればplot_sourcesしたときに悪いコンポーネントは赤く表示できるようになります。</p>
<p>いい感じであればicaを保存するといいでしょう。<br />
良くない感じなら閾値を変えたりチャンネル変えたりしてやり直しです。<br />
このやり方をする時のコツとしては、「こいつこそが典型的な眼球運動だ！」という奴を選ぶことと、<br />
HighpassFilterを掛けた上で作業を行うことです。</p>
<h2 id="epochとevoked">EpochとEvoked</h2>
<p>初心者にはなんのことやら分かりにくい単語ですが、波形解析には重要な用語です。<br />
Epochsはぶつ切りのデータそのものです。Evokedは「誘発された波」です。</p>
<p>元データ(raw)に「ここで刺激したよ！」という印を付けておいて、<br />
後からその印が入っているところだけ切り出してきます。<br />
切り出してきたものがEpochsですね。<br />
Evokedは切り出したものを加算平均して算出します。</p>
<p>例えば元データ(raw)に刺激提示したタイミングを記録しているならば、<br />
下記のコードでその一覧を取得できます。</p>
<pre data-frame="single"><code>events=mne.find_events(raw)</code></pre>
<p>このevents情報からほしいものを抜き出してきて、epochやevokedを作ります。<br />
上記eventsの内容は例えばこうなります。</p>
<pre data-frame="single"><code>221 events found
Events id: [1 2 4 7 8]
Out[205]:
array([[ 15628,      0,      2],
       [ 18053,      0,      2],
       [ 20666,      0,      4],
       [ 23131,      0,      1],
       [ 25597,      0,      8],</code></pre>
<p>この場合刺激チャンネルには1, 2, 4, 8という刺激が入っています。<br />
このうち、刺激情報1を使って切り出したいときは下記です。</p>
<pre data-frame="single"><code>epochs = mne.Epochs(raw, event_id=[1], events=events)</code></pre>
<p>先程のeventsを使っています。<br />
event_idは配列にしてください。ここは[1, 2]とかも出来るのでしょう。<br />
evokedを作るのはとても簡単で、下記のとおりです。</p>
<pre data-frame="single"><code>evoked = epochs.average()</code></pre>

<h2 id="データのplot">データのplot</h2>
<p>是非自らplotしてみてください。何をやっているのか理解が早まると思います。</p>
<pre data-frame="single"><code>epochs.plot()
evoked.plot()</code></pre>
<figure>
<img src="img/epochs.png" alt="epochsの例" style="width:14cm" /><figcaption>epochsの例</figcaption>
</figure>
<figure>
<img src="img/evoked.png" alt="evokedの例" style="width:14cm" /><figcaption>evokedの例</figcaption>
</figure>
<p>epochsやrawをプロットしたとき、どうなったでしょうか？</p>
<h3 id="jupyterの場合">jupyterの場合</h3>
<p>jupyterではどのように表示するかを選ぶことが出来ます。<br />
jupyterにそのまま表示したい場合は下記を先にjupyter上で実行してください。</p>
<pre data-frame="single"><code>%matolotlib inline</code></pre>
<p>別のwindowに表示したいときは下記のようにしてください。</p>
<pre data-frame="single"><code>%matplotlib qt</code></pre>
<p>また、3D画像を表示したい場合は</p>
<pre data-frame="single"><code>%gui qt</code></pre>
<p>jupyterに表示するメリットはjupyter自体を実験ノート風に使えること、<br />
別ウィンドウに表示するメリットはrawやepoch等大きなデータを表示する時に<br />
スクロールさせることが出来ることです。<br />
(反面、バージョン管理がしんどい)</p>
<p>実はjupyter上でスクロール出来る表示もあるのですが、重くてあまり良くないです。<br />
詳しくはqiitaで検索してください。親切な記事がいくらでもあります。</p>
<h3 id="pysurfer">pysurfer</h3>
<p>また、PySurferについては例えば下記のような感じです。<br />
これはmacの場合ですが、ubuntuも同じ感じです。<br />
subjectやsubjects_dirはfreesurferの設定で読み替えてください。<br />
jupyterで下記の呪文を唱えましょう。</p>
<pre data-frame="single"><code>import surfer
%gui qt</code></pre>
<p>そしてこうです。この場合ブロードマン１を赤く塗っています。</p>
<pre data-frame="single"><code>brain = surfer.Brain(subject, &quot;lh&quot;, &quot;inflated&quot;,
subjects_dir=subjects_dir)
brain.add_label(&quot;BA1.thresh&quot;, color=&quot;red&quot;)</code></pre>
<p>注意すべき点として、拡張子や左右半球にかんしてはadd_label関数では<br />
省略して入力する必要があります。</p>
<figure>
<img src="img/label.png" alt="pysurferで表示したfreesurferのラベルファイル" style="width:14cm" /><figcaption>pysurferで表示したfreesurferのラベルファイル</figcaption>
</figure>
<p>ちなみに、labelファイルはそれぞれのsubjectの中のlabelフォルダの中にあります。<br />
このlabelについてはブロードマンの脳磁図ベースの古典的なものが多いですね。<br />
新しい系はannotファイルの中に多いです。</p>
<figure>
<img src="img/annot.jpg" alt="pysurferで表示したfreesurferのannotationファイル" style="width:14cm" /><figcaption>pysurferで表示したfreesurferのannotationファイル</figcaption>
</figure>
<pre data-frame="single"><code>brain = surfer.Brain(subject, &quot;lh&quot;, &quot;inflated&quot;,
subjects_dir = subjects_dir)
brain.add_annotation(&#39;aparc.a2009s&#39;)</code></pre>
<p>沢山表示されていますね。僕はちょっと気持ち悪いなぁと思いました。<br />
一つだけ表示すればいいなら以下のようにします。</p>
<pre data-frame="single"><code>labels = read_labels_from_annot(hoge, &#39;aparc&#39;)
labels = list(filter(lambda x: label_name in x.name, labels))
b.add_label(label)</code></pre>
<p>hogeにはSubjectを入れてください。</p>
<p>さて、実は脳みそだけでなく、脳みその中の活動の動画も撮ることが出来ます。<br />
それについてはソース推定のセクションで書こうと思います。</p>
<h2 id="numpyのplot">numpyのplot</h2>
<p>これ、結構面倒くさいです。では、表示していきましょう。numpyの情報をdataとします。<br />
しかし、例えばwavelet変換をした情報なんかなら、<br />
時間軸、周波数軸、チャンネルというふうに、多次元です。<br />
二次元のほうが皆さん見やすくて好きですよね？では、二次元にします。</p>
<pre data-frame="single"><code>data_mean = data.mean(axis=0)</code></pre>
<p>mneでは三次元配列を多用しますが、とりあえずaxis=0でうまくいくことが多いですね。<br />
ここは適当ですが、いい感じに調整して下さい。</p>
<pre data-frame="single"><code>import matplotlib.pyplot as plt
def make_and_save_fig(data, fname)-&gt; None:
    fig, ax = plt.addsubplot()
    ax = plt.imshow(data, vmax=0.25, cmap=&#39;rainbow&#39;)
    ax.set_yticks(np.arange(85, 0, -5))
    ax.set_yticklabels(np.arange(15, 100, 5))
    ax.set_xticks(np.arange(0, 1000, 100))
    ax.set_xticklabels(np.arange(-300, 700, 100))
    ax.invert_yaxis()
    plt.savefig(fname)
    plt.clf()</code></pre>
<p>二次元の画像データをplotするやつですね。<br />
set_yticksはデータのどの部分に目盛りをつけるかを指定したもの。<br />
set_yticklabelsはデータの目盛りに書き込む内容です。<br />
ここでは、15から100Hzの周波数について解析して、5Hzずつ目盛りをつけていったのですね。<br />
matplotlibは突然pltとして出てきていますが、これは仕様です。<br />
axに吐き出したものはpltで色々するんですね。詳しくはググって下さい。</p>
<h2 id="多チャンネル抜き出し">多チャンネル抜き出し</h2>
<p>もし、多チャンネルのevokedを平均したものを割り出したいなら貴方はnumpyを使うことになります。<br />
ここでは脳波のevokedを例にしておきます。他のデータでも応用ききます。<br />
下記のチャンネルを選択したいとします。</p>
<pre data-frame="single"><code>channels = [&#39;Fz&#39;, &#39;FCz&#39;, &#39;FC1&#39;, &#39;FC2&#39;,
            &#39;Cz&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;F1&#39;, &#39;F2&#39;]</code></pre>
<p>pythonの配列では、中の項目を逆引きで探し出す.index()関数があります。<br />
加工した波形データは.data変数の中に格納されています。その一番初めの情報が<br />
チャンネル別なので、1チャンネル…例えば’Fz’なら下記のようにすれば割り出せます。</p>
<pre data-frame="single"><code>evoked.data[evoked.info[&#39;ch_names&#39;].index(&#39;Fz&#39;)]</code></pre>
<p>この’Fz’をfor文で書きかえていけば良いのです。</p>
<pre data-frame="single"><code>data = []
for channel in channels:
  wave = evoked.data[evoked.info[&#39;ch_names&#39;].index(ch)]
  data.append(wave)</code></pre>

<h2 id="センサーレベルwavelet変換">センサーレベルwavelet変換</h2>
<p>これは解析のゴールの一つと言えましょう。<br />
特定の周波数の波の強さとか、揃い具合を数字に出来れば論文が<br />
書けるってわけです！ヒャッホゥ！</p>
<h3 id="そもそもwavelet変換とは何なのか">そもそもwavelet変換とは何なのか</h3>
<p>波形解析の方法です。画像変換にも使えます。<br />
ここでは特定の周波数の波の強さや位相を計算する方法として使います。<br />
フーリエ変換という言葉をご存知でしょうか？<br />
フーリエ変換は全ての波をsin波の合算として解釈することで波を一つの式として表す方法です。<br />
余程ヤバイ波じゃなければ、ほぼ全ての波はフーリエ変換によって近似的に変換できるのです。<br />
凄いですね！しかし、これには欠点があります。不規則な波の変化に対応できないのです。<br />
何故なら、sin波は未来永劫減衰しない波だからです。<br />
フーリエ変換において、波は未来永劫つづくのが前提なのです。<br />
(擬似的に切り取ることは出来るし、普通にそれだけでも研究は成立する)</p>
<p>そこで、減衰する波を使って波を表す方法を使います。これが非直交Waveletです。<a href="#fn55" class="footnote-ref" id="fnref55"><sup>55</sup></a><br />
そのため、減衰する波を単純な数式で表現する必要があります。</p>
<p>これを理解するためには高校数学を理解する必要があります。<a href="#fn56" class="footnote-ref" id="fnref56"><sup>56</sup></a><br />
なんと！この同人誌は高校を卒業した人向けの同人誌であったのか！？<br />
まぁ、中卒の人でも高校数学の特定の数学を勉強すれば十分いけます。勉強するべきなのは</p>
<ul>
<li>三角関数</li>
<li>複素数</li>
<li>指数・対数</li>
<li>微分方程式</li>
</ul>
<p>と、このあたりです。詳しくは後半の「初心者のための波形解析」を御覧ください。</p>
<figure>
<img src="img/wavelet_base.png" alt="waveletの例。これはmorlet waveletという種類。morletはモルレと読む。青は実数部分、緑は虚数部分。" style="width:14cm" /><figcaption>waveletの例。これはmorlet waveletという種類。morletはモルレと読む。青は実数部分、緑は虚数部分。</figcaption>
</figure>
<figure>
<img src="img/3d_wavelet_base.png" alt="morlet waveletの実数軸、虚数軸、角度軸による3d plot。" style="width:14cm" /><figcaption>morlet waveletの実数軸、虚数軸、角度軸による3d plot。</figcaption>
</figure>
<h3 id="wavelet変換にまつわる臨床的な単語">wavelet変換にまつわる臨床的な単語</h3>
<p>波の強さや揃い具合を測れると言っても、まずは用語がないとどうしようもありません。<br />
脳活動に関する用語としては以下のようなものがあります。(ただし、コネクティビティ系は除く)</p>
<table>
<thead>
<tr class="header">
<th>単語</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>total power</td>
<td>何らかの刺激を受けて出てくるpower</td>
</tr>
<tr class="even">
<td>evoked power</td>
<td>何らかの刺激を受けた直後に同期して出るpower</td>
</tr>
<tr class="odd">
<td>induced power</td>
<td>何らかの刺激を受けて刺激に同期せずに出るpower</td>
</tr>
<tr class="even">
<td>phase locking factor</td>
<td>同一部位での位相同期性</td>
</tr>
</tbody>
</table>
<p>どういうことでしょう？<br />
つまり、何か刺激を受けた時に「受け取った直後にすぐ起こる」のがevoked<br />
何か刺激を受けた後「なんかよく分からんけど生じる不規則な波」がinduced<br />
上記の合算がtotalです。</p>
<p>total powerは簡単に計算できます。単にwavelet変換して<br />
結果の絶対値を二乗すればそれで終わりであります。<br />
evoked powerは二種類の出し方があります。まぁ、流派みたいなものでしょうか。<br />
induced powerもまた、二種類の出し方があります。<br />
これは後で書きます。</p>
<p>このなかで、Phase Locking Factorは別名 Inter Trial Coherence(itc)といいます。<br />
MNEpythonではitcという言い方しています。<a href="#fn57" class="footnote-ref" id="fnref57"><sup>57</sup></a><br />
それぞれ生理学的には違うものを見ているらしいです。<br />
本書ではitcという言い方にしておきましょうか…。</p>
<p>MNEpythonではセンサーベースならどれも実装されています。<br />
ソースベースではinduced powerとitcの計算方法が実装されています。<a href="#fn58" class="footnote-ref" id="fnref58"><sup>58</sup></a></p>
<p>ではEvoked Power,Induced Power,Inter Trial Coherenceについて解析を行いましょう。</p>
<h3 id="つの流儀とmne">2つの流儀とMNE</h3>
<p>InducedPowerの計算の仕方に2つの流儀があります。<br />
名前については適当につけました。どっちが正しいとかはない。</p>
<h4 id="生波形引き算派">生波形引き算派</h4>
<p>生波形を合算していくと、そのうちキレイにEvokedの波形が出ます。<br />
この波形を生波形から引き算します。しかる後、Wavelet変換して、これをInducedPowerとします。<br />
その上で、TotalPowerからInducedPowerを引き算します。</p>
<h4 id="evokedpower引き算派">EvokedPower引き算派</h4>
<p>生波形をまずWavelet変換して、TotalPowerを出します。<br />
そして、生波形の合算もWavelet変換してEvokedPowerを出します。<br />
TotalPowerからEvokedPowerを引き算してInducedPowerを計算します。</p>
<h3 id="wavelet変換の実際">wavelet変換の実際</h3>
<p>morletのやり方は臨床研究的にメジャーなやり方と僕は思っています。<br />
まずはEvokedPowerからやりましょう。下記のスクリプトで実行できます。<br />
この場合は合算の後にWavelet変換ですね。</p>
<pre data-frame="single"><code>from mne.time_frequency import tfr_morlet
freqs=np.arange(30,100,1)
n_cycles = 6
evoked_power = tfr_morlet(evoked, n_jobs=4, freqs=freqs,
                          n_cycles=n_cycles, use_fft=True,
                          return_itc=False, decim=1)</code></pre>
<ul>
<li>freqs : どの周波数帯域について調べるか。<br />
上の例では30Hzから100Hzまで1Hz刻みに計算しています。</li>
<li>n_cycles : 一つのwaveletに含まれる波のサイクル数。<br />
5~7という値で固定する方法がよく用いられます。<br />
　MNEではこのサイクル数を可変にすることも出来ます。</li>
<li>n_jobs : CPUのコアをいくつ使うか。重い処理なのです。<br />
ちなみに、n_jobsを大きくするよりも、n_jobsを1にして<br />
同時にたくさん走らせたほうが速いです…が、メモリは食います。</li>
<li>use_fft : FFTによる高速wavelet変換を行うかどうか。<br />
数学の話になるので、詳しい所は本書では扱いません。<br />
要するに速く計算するかどうかです、Trueでいいかと。</li>
<li>decim : この値を大きくすると処理が軽くなりますが、<br />
出力結果がちょっと荒くなります。</li>
<li>return_itc : これをTrueにするとphaselocking factorも<br />
算出してくれます。</li>
</ul>
<p>この関数はevokedもepochsも引数として取ることが出来ます。<br />
return_itcがTrueかFalseかで大きく挙動が違います。<br />
挙動の組み合わせについてですが、下記のとおりです。</p>
<table>
<thead>
<tr class="header">
<th>return_itc</th>
<th>引数</th>
<th>返り値1つ目</th>
<th>返り値2つ目</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>False</td>
<td>evoked</td>
<td>EvokedPower</td>
<td>なし</td>
</tr>
<tr class="even">
<td>False</td>
<td>epochs</td>
<td>TotalPower</td>
<td>なし</td>
</tr>
<tr class="odd">
<td>True</td>
<td>epochs</td>
<td>TotalPower</td>
<td>InterTrialCoherence</td>
</tr>
</tbody>
</table>
<p>Inducedが無いじゃないか！ってなりましたね？<br />
Inducedを計算したければ、Epochsのオブジェクトで以下のようにします。</p>
<pre data-frame="single"><code>epochs.subtract_evoked()</code></pre>
<p>これをすると波形からEvokedが引かれて計算できるようになります。または、</p>
<p>itcを計算したい時は返り値が2つになりますから、下記の通りです。</p>
<pre data-frame="single"><code>freqs=np.arange(30,100,1)
n_cycles = 6
total_power, itc = tfr_morlet(epochs, n_jobs=4, freqs=freqs,
                              n_cycles=n_cycles, use_fft=True,
                              return_itc=True, decim=1)</code></pre>
<p>ここで一つ注意点があります。<br />
wavelet変換は基準になる波を実際の波に掛け算して行うのですが、<br />
波の始まりと終わりのところだけは切れちゃうはずです。そこは十分注意して下さい。<br />
どの程度のwaveletの波の長さなのかについては、勉強して適当に計算して下さい。</p>

<h2 id="データの集計について">データの集計について</h2>
<p>データの集計についてですが…実は結構面倒くさいです。<br />
MNEは個人個人のデータを解析するモジュールだからです。<br />
それぞれのデータはMNEのオブジェクトの中に入っています。<br />
貴方は個人個人のデータをMNEで解析した後、<br />
そのデータを<strong>自分で</strong>集計する必要があります。numpyを使う必要性はここで出てきます。</p>
<p>MNEのオブジェクト(itc, power, evoked, epochs, raw等)は<br />
ユーザーがいじることが出来るようになっています。</p>
<p>中の実データはそれぞれのオブジェクトの中のdataという変数か、<br />
またはget_data関数で抽出してくることになります。<br />
powerならpower.dataに、rawならraw.get_data()に入っています。<br />
こうして出してきた配列はnumpy形式の配列です。</p>
<p>ピックアップした情報は多次元配列ですから、内容は膨大です。直接見ても整理つきません。<br />
そこで便利な変数がnumpyにはあります。例えばevokedのデータを作ったならば</p>
<pre data-frame="single"><code>evoked.data.shape</code></pre>
<p>とすればデータの構造が確認できます。<br />
この場合は[チャンネル、時間]になろうかと思います。</p>
<p>データの構造としてはこんな感じのようです。括弧がついているのはオブジェクト内の関数です</p>
<table>
<thead>
<tr class="header">
<th>形式</th>
<th>データ</th>
<th>1次元目</th>
<th>2次元目</th>
<th>3次元目</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>raw</td>
<td>raw.get_data()</td>
<td>チャンネル</td>
<td>波形</td>
<td></td>
</tr>
<tr class="even">
<td>epochs</td>
<td>epochs.get_data()</td>
<td>チャンネル</td>
<td>波形</td>
<td></td>
</tr>
<tr class="odd">
<td>evoked</td>
<td>evoked.data</td>
<td>チャンネル</td>
<td>波形</td>
<td></td>
</tr>
<tr class="even">
<td>itc</td>
<td>itc.data</td>
<td>チャンネル</td>
<td>周波数</td>
<td>波形</td>
</tr>
<tr class="odd">
<td>power</td>
<td>power.data</td>
<td>チャンネル</td>
<td>周波数</td>
<td>波形</td>
</tr>
</tbody>
</table>
<p>揃っていませんね…。<br />
(どうせ使うのはevoked以下くらいなので大して困りません。)<br />
まぁ、itcやpowerは波形データじゃないので揃ってなくてもいいですが。</p>
<p>それぞれのオブジェクトは<br />
object.save(filename)<br />
とすれば保存できます。<br />
読み込みは多くの形式に対応する必要があってか一寸複雑です。</p>
<table>
<thead>
<tr class="header">
<th>形式</th>
<th>読み込み関数</th>
<th>備考</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>raw</td>
<td>mne.io.Raw()</td>
<td>脳磁図の場合。脳波とかは公式サイトAPI参照</td>
</tr>
<tr class="even">
<td>raw</td>
<td>mne.io.read_raw_hoge()</td>
<td>様々な形式のがある。hogeは読み替えてね。</td>
</tr>
<tr class="odd">
<td>epochs</td>
<td>mne.read_epochs()</td>
<td></td>
</tr>
<tr class="even">
<td>evoked</td>
<td>mne.read_evoked()</td>
<td>条件によってlistで返されることあり</td>
</tr>
<tr class="odd">
<td>itc</td>
<td>mne.time_frequency.read_tfrs()</td>
<td>条件によってlistで返されることあり</td>
</tr>
<tr class="even">
<td>power</td>
<td>mne.time_frequency.read_tfrs()</td>
<td>条件によってlistで返されることあり</td>
</tr>
</tbody>
</table>
<p>例えば</p>
<pre data-frame="single"><code>itc = mne.time_frequency.read_tfrs(&#39;/home/hoge/piyo&#39;)[0]</code></pre>
<p>という感じで読み込みます。行の最後についている[0]は上記のごとく<br />
条件によってlistで返されることがある関数だからです。<br />
そうじゃない関数の場合は[0]は不要です。実際に手を動かして練習すればわかると思います。</p>
<p>さて、実データのみではサンプリング周波数やチャンネルの名前が分からず<br />
困ったことになりますが、mne/pythonではこれらは<br />
それぞれのobjectの中のinfoというpython辞書形式変数に入っています。<br />
例えばprint(itc.info)とかprint(itc.info[‘ch_names’])とかで<br />
読めたりしますから確認してみてください。僕はこのinfoを使ってチャンネルを抽出したりします。</p>
<p>ここまでの知識で、自分でnumpy形式で脳波脳磁図を扱えるようになります。</p>
<p>あとは下記のようにすれば良いと思います。</p>
<ol type="1">
<li>powerなりitcなり波形なり、個人レベルで計算する</li>
<li>numpy形式で1チャンネル抜き出したり数チャンネルの平均取ったりする</li>
<li>個人個人で数字が出てくるので、それを保存する</li>
<li>Rでその数字を統計解析する</li>
</ol>
<p>例えばhogeチャンネルのfugaHzからpiyoHz、<br />
foo番目からbar番目(秒×サンプリング周波数)の反応までの<br />
実データを抽出したいなら、</p>
<pre data-frame="single"><code>itc.data[hoge, huga:piyo, foo:bar]</code></pre>
<p>何番目ってアレですね…なら、fooとbarを秒単位にして、こうしましょう。</p>
<pre data-frame="single"><code>sfreq = 1000
itc.data[hoge, huga: piyo, foo / sfreq: bar / sfreq]</code></pre>
<p>です。ちなみに、wavelet変換時にdecimの値を設定している場合は<br />
(秒×サンプリング周波数/wavelet変換のdecimの値)となります。<br />
APIページでtime_frequency.tfr_morlet()関数をご参照ください。</p>
<p>2はnumpyのmean等で実現します。<br />
import numpy as npの後</p>
<pre data-frame="single"><code>np.mean(itc.data[hoge, huga:piyo, foo:bar])</code></pre>
<p>などとすれば良いと思います。</p>
<p>3はpythonの基本構文通りなので解説しません。<br />
4はどのようにしたいかは人によって違うかと思います。<br />
最近は僕は単純にcsv形式に書き出しています。pandasなんかはとても素敵です。<br />
numpyでも普通のlistでもcsvに変換してくれます。こうすればいいです。</p>
<pre data-frame="single"><code>from pandas import DataFrame
DataFrame(hoge).to_csv(filename)</code></pre>
<h2 id="jupyterでのrとpadasの連携">jupyterでのRとpadasの連携</h2>
<p>「Rをjupyterで動かすために」である程度書きましたが、再掲します。<br />
jupyter上で</p>
<pre data-frame="single"><code>%load_ext rpy2.ipython</code></pre>
<p>とした後</p>
<pre data-frame="single"><code>%%R -i input -o output
hogehoge</code></pre>
<p>という風に記述すればhogehogeがRとして動きます。<br />
ここのデータの受け渡しにもpandasを使うのが良いです。<br />
項目には名前をつけることが出来ます。</p>
<pre data-frame="single"><code>from pandas import DataFrame
data = Dataframe(data
                 columns=(&#39;group&#39;,
                          &#39;hemisphere&#39;,
                          &#39;test&#39;, &#39;value&#39;))</code></pre>
<p>これで、横軸にcolumsのラベルの付いたデータフレームが出来ます。<br />
こいつをto_csvを使ったりjupyterとかでRにぶちこみます。</p>
<pre data-frame="single"><code>%%R -i data
result &lt;- aov(
  df$value ~ df$group * df$hemisphere * df$test,
  data=df))
cat(result)</code></pre>
<p>だいたいこんな感じです。</p>
<h2 id="rでのanovaについて">RでのANOVAについて</h2>
<p>pythonのscipyでの統計もいいのですが「なんで統計ソフト使わないん？舐めてるん？」<br />
とrejectを食らう可能性もありますから辞めましょう。</p>
<p>どうせ多重検定することになるんですから、それについて一寸。<br />
だいたいANOVAを用います。aovがRのANOVA関数です。<br />
これをsummary関数に読ませることで結果を簡単にまとめます。<br />
さらに、cat文を使うことで画面上に表示します。<br />
中の式は、データフレーム内の掛け算になっています。</p>
<p>ANOVA詳しい人は知っていると思いますが、これは相互作用を算出するものです。<br />
相互作用を計算しない場合は’+’演算子を使ってください。結果が算出されると思います。<br />
あとはANOVAの本でも読んで下さい。本書では割愛します。<br />
Rによるやさしい統計学という本が僕のおすすめです。</p>

<h2 id="connectivity">Connectivity</h2>
<p>Connectivityを脳波でやってみましょう。Connectivityは要するに、<br />
脳のあちこちの繋がり具合を調べる指標です。MRIとかでよくされている手法ですね。</p>
<p>mne-connectivityでは脳波と脳磁図でこれを計算することが出来ます。<br />
実装されている計算方法を列挙してみます。<br />
まずは、何はなくても計算しやすくする変換をせねば始まりません。<br />
変換方法は下記の3つが提供されています。</p>
<ul>
<li>multitaper</li>
<li>fourier</li>
<li>morlet wavelet</li>
</ul>
<p>フーリエ変換やwavelet変換をした上で、それぞれの値を比較するのです。<br />
比較の方法は下記のとおりです。</p>
<ul>
<li>Coherence: Coherencyの絶対値</li>
<li>Coherency: 純粋に計算で出されたやつ</li>
<li>ImaginaryCoherence: 同一ソースの影響を除いたもの</li>
<li>Phase-Locking Value: 純粋に計算で出されたやつ</li>
<li>Phase Lag Index: 同一ソースの影響を除いたもの</li>
<li>Weighted Phase Lag Index: PhaseLagIndexに重みを付けたもの</li>
</ul>
<p>…多すぎですね(´・ω・｀)<br />
このうち、CoherenceとPhaseLockingValueは<span style='color: red'>敢えて言おう、カスであると。<span style='color: red'><br />
それ以外のどれが良いとかは…よくわかりません。<br />
色々やってみたり先行研究を見るのが良いかも？<br />
これらの詳細については波形解析の理屈編に一応書きました。<br />
とりあえず、計算方法を書いておきます。まずは、epochを作ります。作り方は前述のとおりです。<br />
眼球運動や心電図のデータは要らない<a href="#fn59" class="footnote-ref" id="fnref59"><sup>59</sup></a>ので、<br />
pick_channelやdrop_channelで要らないのを外していきます。</p>
<pre data-frame="single"><code>epochs.pick_channels([&#39;hoge&#39;])
epochs.drop_channels([&#39;fuga&#39;])</code></pre>
<p>では、始めましょう。</p>
<pre data-frame="single"><code>from mne_connectivity import spectral_connectivity_epochs
cons = spectral_connectivity_epochs(
    epochs, method=’coh’, indices=None,
    sfreq=500, mode=’multitaper’, fmin=35, fmax=45, fskip=0,
    faverage=False, tmin=0, tmax=0.5, mt_bandwidth=None,
    mt_adaptive=False, mt_low_bias=True,
    cwt_frequencies=None, cwt_n_cycles=7,
    block_size=1000, n_jobs=1)
</code></pre>
<p>…基本、我流の僕はソースコードが汚いんですが、今回はあまりにも<br />
一行あたりが長すぎて一ページに収めにくかったんです…。<br />
やむを得ず圧縮のためにscと短縮しました…。では、解説いきます。</p>
<ul>
<li>method: そのままmethodですね。上記の通り。</li>
<li>indices: どことどこのconnectivityを見たいかです。</li>
<li>sfreq: サンプリング周波数です。</li>
<li>mode: multitaper, fourier, cwt_morletの3つを選べます。</li>
<li>fmin,fmax: 見たい周波数帯域です</li>
<li>fskip: どのくらい飛び飛びで解析するかです。</li>
<li>faverage: 最終的に幾つかの周波数を平均した値を出すかどうかです。</li>
<li>tmin,tmax: どこからどこまでの時間見るか</li>
<li>cwt_frequencies: morlet waveletの時の周波数(numpy形式の数列)</li>
<li>cwt_n_cycles: morlet waveletの波の数</li>
<li>block_size,n_jobs: 一度にどのくらい計算するか</li>
</ul>
<p>この関数は、中々<del>詰め込み</del>多機能な関数です。<br />
なんと、上記の沢山のmethodを全部できます。出来るがゆえの大変さもあります。</p>
<p>conは三角行列です。<br />
三角行列というのは、行列の対角より上か下が全部0で出来ている行列です。</p>
<figure>
<img src="img/sankaku.png" alt="三角行列の例" /><figcaption>三角行列の例</figcaption>
</figure>
<h3 id="fouriermultitaperモード">fourier/multitaperモード</h3>
<p>fourierやmultitaperは時間軸がないです。その辺がmorlet waveletと違うところです。<br />
conの内容は[チャンネル数 X チャンネル数 X 周波数]という三次元配列になります。<br />
この内、チャンネル数 X チャンネル数 の部分が三角行列になります。<br />
周波数は、関数が勝手に「これがいいよ」と言って抜き出してきた<br />
離散的な周波数になります。</p>
<p>ここで、幾つかの周波数について個別にやりたいなら話は違うのですが、<br />
加算平均したいなら下記のコードで十分です。</p>
<pre data-frame="single"><code>conmat=np.mean(con,axis=(2))</code></pre>
<p>これで、conmatに三角行列が入りました。</p>
<h3 id="waveletモード">waveletモード</h3>
<p>morlet waveletは乱暴に言うとfourierに時間軸を与える拡張版です。<br />
[チャンネル数 X チャンネル数 X 周波数 X 時間]という4次元になります。<br />
この場合は下記のコードで三角行列を作りましょう。</p>
<pre data-frame="single"><code>conmat=np.mean(con,axis=(2,3))</code></pre>
<p>三角行列が出来ました。</p>
<h3 id="plot">plot</h3>
<p>さっきの2つは三角行列を作るモードでした。<br />
三角行列がある場合は綺麗なplotが出来ます。下記のとおりです。</p>
<pre data-frame="single"><code>mne.viz.plot_connectivity_circle(conmat, epochs.ch_names)</code></pre>
<figure>
<img src="img/con.png" alt="僕の脳波のコネクティビティの図。花火みたいで綺麗なので好きです。" /><figcaption>僕の脳波のコネクティビティの図。花火みたいで綺麗なので好きです。</figcaption>
</figure>
<h3 id="indicesモード">indicesモード</h3>
<p>三角行列関連は、要するに全部入りな感じの計算でした。<br />
indicesというところに引数を入れると、特定のconnectivityだけ計算してくれます。</p>
<pre data-frame="single"><code>indices = (np.array([0, 0, 0]),
           np.array([2, 3, 4]))</code></pre>
<p>このようにnumpy配列を作ります。1列目は何番目のチャンネルとそれぞれを見比べたいか。<br />
2列目はそれぞれのチャンネルです。ここでは<br />
0 → 2 , 0 → 3 , 0 → 4 番目のチャンネルを比べています。</p>
<p>で、このindicesを引数として入れるとどうなるかというと、<br />
fourier/multitaperモードなら[見比べたチャンネルの数 X 周波数]となります。<br />
morlet waveletモードなら[見比べたチャンネルの数 X 周波数 X 時間]となります。</p>

<h2 id="ソースレベルmeg解析">ソースレベルMEG解析</h2>
<p>ついにソースレベルの解析を行います。これがMNE/pythonの真髄です。<br />
すこし難しいのです。頑張りましょう。<br />
数学分かる人向けにいいますと、こいつはMAP推定です。</p>
<ol type="1">
<li>脳の構造画像からセンサーへの伝わり方を計算する</li>
<li>事後分布として分散共分散行列を用いる</li>
<li>MAP推定する</li>
</ol>
<p>という手順です。</p>
<p>数学わからない人に適当に言うと</p>
<ol type="1">
<li>MRIとセンサーの位置情報から方程式を作る</li>
<li>どの程度の波の大きさを想定するか設定する</li>
<li>上記から大まかな当たりをつけて推定する</li>
</ol>
<p>という感じ。</p>
<p>ソースレベル解析の性質や仕組みは他の所を見ていただくとして、<br />
早速MRIとMEGをくっつけていきます。<br />
(MRIがない場合は標準脳を使えるけど、あまり感心しない)<br />
目標は「脳内の信号を算出するための式を作る」事です。<br />
式さえできればなんとか計算できるわけです。<br />
必要物品は以下の通り</p>
<ul>
<li>脳の中の見たい場所リスト(SourceSpace)</li>
<li>センサーの位置情報(Montage)</li>
<li>脳波か脳磁図の結果(Raw)</li>
<li>皮膚や頭蓋骨の抵抗値や、その分布(BEMmodel)</li>
</ul>
<p>このなかで、MRIについては標準脳を使うのでなければ<br />
freesurferでrecon-allをしたデータが必要です。<br />
前述しましたので、頑張って下さい。一晩かかります。</p>
<p>これらを使って何をするかと言うと、<br />
脳の中の活動と、センサーで捉えた結果で連立方程式を解いてあげるのです。<br />
さて、これは理工系の人は知っているのですが、<br />
実は連立方程式を解くという行為は割り算に他ならないのです。<br />
(ここで文系や医学部の人はびっくりする)<br />
大学数学を習ってなかった人やサボっていた人はあとの方に書いた<br />
「鶴亀算とは割り算である」をご参照ください。</p>
<p>さて、脳の中の電気の活動量をX、センサーで捉える磁場とか電場とかをYとすると<br />
<span class="math inline"><em>A</em><em>X</em> = <em>Y</em></span>という形式に落とし込めるはずです。<br />
Aは適当な定数です。距離とか抵抗で計算できます。電磁気学です。<br />
これは高校物理をちゃんと勉強した人は直感的に分かるはず。</p>
<p>このAを求めることをForwardSolutionという感じに言います。掛け算を求めるのですね！<br />
ここから<span class="math inline"><em>X</em> = <em>A</em><sup> − 1</sup><em>Y</em></span>という風に変えればXを計算できます。<br />
これをInverseSolutionと言い、<span class="math inline"><em>A</em><sup> − 1</sup></span>のことを<br />
InverseOperatorと言います。割り算ですね！このInverseOperatorを求めることが当面の目標です。</p>
<p>手順としては以下のとおりです。</p>
<h3 id="掛け算を作る">掛け算を作る</h3>
<p>まずは、掛け算を作るために、脳の中の位置情報、センサーの位置情報、そして、<br />
その両者がどのように重なっているかの位置関係を求める必要があります。<br />
必要なのは</p>
<ul>
<li>抵抗値</li>
<li>脳みその形</li>
<li>センサーのセットの形</li>
<li>脳みそとセンサーセットの相対的な位置</li>
<li>それぞれをまとめる方程式</li>
</ul>
<p>これだけあれば掛け算を作れます。具体的には、下記です。</p>
<ol type="1">
<li>MRIから脳の形を取ってきて、骸骨の抵抗とかも加味して計算できる形にする。<br />
これをBEMmodelと呼ぶ。これを使って掛け算の形にする。</li>
<li>脳の形から「推定する脳部位の位置」を特定する。<br />
この脳内の位置情報をソーススペース(Source space)と呼ぶ。<br />
(鶴亀算の鶴と亀のいる場所を計算する)</li>
<li>センサーの位置情報。MNEではMontageクラスのオブジェクト。<br />
ただし、脳波計によってはRawの中に組み込まれていて不要なこともある。</li>
<li>「推定するべき脳の部位」とEEG/MEGのセンサーの位置をすり合せて<br />
両者の位置関係を求める。この作業は手動で行われる。(超絶めんどい)<br />
この重ね合わせ情報はtransというファイル形式で保存される。</li>
<li>脳の部位情報と頭の形情報とセンサーの位置から、<br />
脳活動によってどのようにセンサーに信号が届くかを計算する。<br />
これを脳磁図における順問題(forward solution)という。<br />
これにより、掛け算が求められる。</li>
</ol>
<h3 id="割り算を作る">割り算を作る</h3>
<p>次に割り算を作ります。MNEやsLORETAやdSPMといった何やら難しげな手法は、<br />
この割り算を作るときのやり方の違いなのです。</p>
<ol type="1">
<li>綺麗な割り算をするためのCovariance matrixを作る(理屈は後述)。</li>
<li>上記の脳部位とセンサーの関係性から、特定の脳部位での電源活動の波形を推定する。<br />
これを脳磁図における割りざ…逆問題(Inverse solution)という。<br />
割り算は逆数の掛け算と同じであるから、掛け算に置き換えられる。<br />
この時の逆数のことをInverseOperatorという。<br />
InverseOperatorを滑らかにするためにCovarianceMatrixを使う。<br />
この割り算に決まった解答はない。「最も良い解を得る方法」が幾つか提案されている。</li>
<li>脳全体で推定した波形のうち、欲しいものをとってくる。</li>
</ol>
<p>本当にこれだけ。なんと、現時点での脳の電気活動のソース推定とは割り算なのであった！</p>
<p>簡単に言いましたが、これが割り算である事を数学的にちゃんと理解するには<br />
ラグランジュの未定乗数法によって導かれる行列の微分方程式を<br />
解かねばなりません。あとでかるーく触れます。</p>
<p>その後は色々なストーリーがあるでしょう。</p>
<h3 id="その後のストーリー">その後のストーリー</h3>
<ul>
<li>推定された波形をwavelet変換する。</li>
<li>PSDやERPをしてみる。</li>
<li>脳の各部位のコネクティビティを算出する。</li>
<li>何か僕達が思いつかなかった凄いアイデアを実行する。</li>
</ul>
<p>などなど。でははじめましょう。</p>
<h3 id="手順0freesurfer">手順0、freesurfer</h3>
<p>脳画像を解析したと思いますが、その脳画像のチェックはしてください。<br />
ダメダメなやつになっていることもありますので。<br />
ダメダメだったらトラブルシュートしなければなりません。</p>
<p>無いなら標準脳でも出来なくはないです。</p>
<h3 id="手順1trans">手順1、trans</h3>
<p>まず、脳とセンサーの位置をすり合わせておきましょう。</p>
<p>GUIでの操作となります。2通りの動かし方があります。<br />
下記のコードを実行すると画面が立ち上がります。</p>
<p>pythonで</p>
<pre data-frame="single"><code>from mne.gui import coregistration
coregistration()</code></pre>
<p>bashで</p>
<pre data-frame="single"><code>mne coreg</code></pre>
<p>mne coregコマンド簡単ですね！公式でもmne coregがオヌヌメと書いてありました。<br />
あんま変わらないとは思いますが。</p>
<p>subjectとかのpathを指定しない場合は、GUI上で指定することになります。<br />
もし0から立ち上げた場合、山のようにあるMRIのsubjectから該当の<br />
subjectを探さねばならなくなります。重いので指定してあげたほうが楽です。</p>
<p>pythonの関数に色々入れてから起動すれば、既にデータが読み込まれているので、楽です。</p>
<pre data-frame="single"><code>coregistration(subject = subject,
               subjects_dir = subjects_dir,
               inst = file_path)</code></pre>
<p>instはeegやmegデータ…rawでもepochでも良いらしいですが、どれかを指定して下さい。</p>
<p>mne coregの場合は、mne coreg -hとでもやってhelpを見てください。</p>
<figure>
<img src="img/trans.png" alt="mne coregistrationの画面。最悪の苦行。" style="width:14cm" /><figcaption>mne coregistrationの画面。最悪の苦行。</figcaption>
</figure>
<p>手順はこうです。</p>
<ol type="1">
<li>必要ならば、MRIのsubjectを読み込む</li>
<li>必要ならば、fifファイルを読み込む</li>
<li>左側、setのところで耳と眉間の位置を入力<br />
(MEGならスタイラスでポチるところ)</li>
<li>それの一寸上の所、lockをポチる。</li>
<li>面倒なら右側、Fit LPA/RPAボタンとかを押す。</li>
<li>表示された黄土色の生首をマウスでグリグリしながら、<br />
右上の±ボタンを押して調整。</li>
<li>ちゃんとfitしたら右下のsave as ボタンを押して保存。</li>
</ol>
<p>あとで、保存したtransを</p>
<pre data-frame="single"><code>from mne import read_trans
trans = read_trans(&#39;/Users/hoge/fuga/trans.fif&#39;)</code></pre>
<p>みたいな感じで読み込んで使います。<br />
右上のボタンを押した場合は黄土色の生首の大きさが変わってしまうので、<br />
freesurferのsubjectに別名をつけて保存する必要があります。</p>
<p>ほかに注意点として、脳波とかの場合は表示が<br />
projectionモードになっていたりして見にくかったりするかもです。<br />
色々調整してみてください。</p>
<h3 id="手順2bem作成">手順2、BEM作成</h3>
<p>脳からセンサーまでの抵抗を計算せねばなりますまい。</p>
<p>上記の通り、MRIから抽出してくる形データからBEMモデルを作ります。<br />
BEMは脳の全体を包み込むサランラップみたいなデータになります。<a href="#fn60" class="footnote-ref" id="fnref60"><sup>60</sup></a><br />
頭蓋骨とか皮とか、そういう抵抗が強いものを考慮するために、BEMは三枚一組で<br />
出力されます。実装上は3枚あるということを意識しなくても大丈夫です。</p>
<p>ちなみに、サランラップみたいなものを使わない方法もあります。<br />
球形を想定してやる方法ですね。今回は書きません。</p>
<p>作るためにはfreesurferによる解析データが必要となります。<br />
freesurferを既に使っているならSubject関連は既に馴染んだ言葉でしょうか？<br />
もちろんSUBJECTやSUBJECTS_DIRは読み替えてください。</p>
<pre data-frame="single"><code>mne watershed_bem -s subject -d subjects_dir</code></pre>
<p>これにより、freesurferのサブジェクトの中にBEMが作成されました。<br />
再びpythonに戻り、下記を入力してみてください。</p>
<pre data-frame="single"><code>from mne.viz import plot_bem
plot_bem(subject=subject,
         subjects_dir=subjects_dir,
         brain_surfaces=&#39;white&#39;,
         orientation=&#39;coronal&#39;)</code></pre>
<p>これでBEMが表示されるはずです。</p>
<figure>
<img src="img/bem.png" alt="BEMの図示。" style="width:14cm" /><figcaption>BEMの図示。</figcaption>
</figure>
<p>もし、標準脳を使うなら、以下のコマンドをターミナルから叩いて下さい。</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb165-1" title="1"><span class="ex">mne</span> coreg</a></code></pre></div>
<p>guiの画面が現れると思います。<br />
’fsaverage→SUBJECTS_DIR’というボタンを押して下さい。<br />
freesurferの標準脳であるfsaverageが現れます。<br />
以降、subjectにはfsaverageを入れると標準脳を使うことになります。</p>
<h3 id="手順3ソーススペース作成">手順3、ソーススペース作成</h3>
<p>脳内の位置情報を作りましょう。</p>
<p>脳磁図で見れる空間のうち、どの部分の電源を推定するかを設定する必要があります。<br />
その設定がソーススペースです。subjects_dirは環境変数に設定していれば要らないです。<br />
環境変数ってのはbashrcとかbash_profileとかに書くやつです。一応前述しています。</p>
<pre data-frame="single"><code>from mne import setup_source_space
src = setup_source_space(subject=subject,
                         spacing=&#39;oct6&#39;,
                         subjects_dir=subjects_dir)</code></pre>
<p>もちろん、標準脳が欲しい場合は黙ってfsaverage。暫く待ちます。<br />
これで、srcという変数にソーススペースが入りました。</p>
<p>さて、見慣れぬ単語が出てきました。oct6とは何でしょうか？それはここに書いてあります。<br />
<a href="http://martinos.org/mne/stable/manual/cookbook.html#setting-up-source-space">http://martinos.org/mne/stable/manual/cookbook.html#setting-up-source-space</a></p>
<p>ソーススペースを作るためには計算上正十二面体や正八面体で<br />
区画分けするので、その設定ですね。<br />
やり方によってソーススペースの数も変わるみたいです。<br />
臨床的に意味があるかはわかりません。</p>
<p>標準脳を使う場合は’fsaverage’をsubjectに指定して下さい。<br />
ない場合は手順2のmne.gui.coregistration()でボタンを押して下さい。</p>
<figure>
<img src="img/src.png" alt="ソーススペースの図示。小さい点々がソーススペース。" style="width:14cm" /><figcaption>ソーススペースの図示。小さい点々がソーススペース。</figcaption>
</figure>
<h3 id="手順4順問題">手順4、順問題</h3>
<p>まずは掛け算を作ります。</p>
<p>先程作ったBEMは3枚あります。EEGの場合は3枚必要です。何故なら、磁力と違って電力は<br />
脳脊髄液と頭蓋骨と頭皮を素通りしにくいからです。だから、BEMを三枚仮定するのです。<br />
MEGの場合は一枚だけで十分だそうです。</p>
<p>では、BEMで順問題を解く準備をしましょう。</p>
<pre data-frame="single"><code>from mne import make_bem_model, make_bem_solution
conductivity = (0.3,)
model = make_bem_model(subject=&#39;sample&#39;,
                       ico=4,
                       conductivity=conductivity,
                       subjects_dir=subjects_dir)
bem = make_bem_solution(model)</code></pre>
<p>これにより、BEMを読み込み、順問題解きモードに入りました。<br />
icoはどの程度細かく順問題を解くかの数値です。icoの数字が高いほうが詳しいです。<br />
conductivityは電気や磁力の伝導性のパラメータです。<br />
EEGの場合はこれが(0.3, 0.006, 0.3)とかになったりします。</p>
<p>では、先程作った色々なものと組み合わせて順問題を解きます。</p>
<pre data-frame="single"><code>from mne import read_trans, make_forward_solution
trans = read_trans(&#39;/hoge/fuga&#39;)
mindist = 5
fwd = make_forward_solution(raw.info,
                            trans=trans,
                            src=src,
                            bem=bem,
                            meg=True,
                            eeg=False,
                            mindist=mindist,
                            n_jobs=4)</code></pre>
<p>ここまでやった方にとって、上記のパラメータはだいたい分かるでしょう。<br />
mindistは頭蓋骨から脳までの距離です。単位はmm。<br />
ここで使うのはraw.infoです。epochs.infoでもいいかも。</p>
<h3 id="手順5コヴァリアンスマトリックス関連">手順5、コヴァリアンスマトリックス関連</h3>
<p>MNEによる推定にはcovariance matrixというものを使って割り算を綺麗にやります。<br />
数学分かる人向けに書きますと、<br />
「MNEはベイズのMAP推定の一種で、事後分布に脳波の分散共分散行列を使う」<br />
ってことです。<br />
これにはMEGを空撮りした空データや、刺激提示されてないときのデータなどを使います。<br />
下記で計算します。</p>
<pre data-frame="single"><code>from mne import compute_covariance
cov = compute_raw_covariance(raw_empty_room,
                             tmin=0,
                             tmax=None)</code></pre>
<p>ちなみに、刺激提示されてないときの計算は下記のとおりです。</p>
<pre data-frame="single"><code>from mne import compute_covariance
cov = compute_covariance(epochs,
                         tmax=0.,
                         method=&#39;auto&#39;)</code></pre>
<p>ちなみに、このmethod=autoというのはMNEに実装された新しいやり方だそうです。<br />
tmax=0にしているので、刺激が入る前までの波を取り除きます。<br />
つまりベースラインコレクションみたいな感じになるのです。<br />
ちなみに、epochsでcovariance…特にautoですると結構重いです。<br />
autoの場合、クロスバリデーションまでやってくれて凄いみたいですね。<br />
その代わり、計算の重さが酷いです。</p>
<h3 id="手順6逆問題">手順6、逆問題</h3>
<p>最終段階、割り算です。順問題とcovariance matrixを組み合わせて割り算の形にしましょう。<br />
下記のとおりです。</p>
<pre data-frame="single"><code>from mne.inverse import make_inverse_operator
inverse_operator = make_inverse_operator(epochs.info,
                                         fwd,
                                         cov,
                                         loose=0.2,
                                         depth=0.8)</code></pre>
<p>inverse_operatorと言うのは何かというと、逆問題を算出するための式です。<br />
このinverse_operatorを作るために頑張ってきたと言っても過言なしです。</p>
<p>ここで、第一引数にepochs.infoを入れていますが、infoなら<br />
rawでもevokedでも良いはずです。</p>
<p>さて、ここでlooseとdepthという耳慣れぬ物が出てきました。一寸大事なパラメータです。<br />
脳内の電流源推定と言っても、電流の向きを考慮しなくてはならないわけです。<br />
looseはその向きがどのくらいゆるゆるかの指標です。<br />
脳磁図はコイルで磁場を測る関係上、<strong>脳の表面と水平な方向</strong>の成分を捉えやすいように出来ています。<br />
でも、脳波複雑だから完全な水平ってないよね？どのくらいのを想定する？<br />
という風なパラメータです。looseは0〜1の値をとりますが、looseが1というのは超ユルユル、<br />
どの方向でも良いですよということです。<br />
ちなみに、looseが0の時は一緒にfixedをTrueにする必要があります。<br />
fixedがTrueの時は、MNEpythonが脳の形に沿って自動調整してくれます。</p>
<p>depthは何かというと、どのくらい深い部分を見たいか、です。<br />
MNEという計算手法は脳の表面の情報を拾いやすい偏った計算方法です。<br />
故に、深い部分に対して有利になるようにする計算方法があります。<br />
depthを設定すると、脳の深い所を探れるわけです。<br />
depthをNoneに設定すると、ほぼ脳の表面だけ見ることになります。</p>
<p>他にlimit_depth_chsというパラメータもあります。これをTrueにすると、完全に脳の表面だけ見ます。<br />
即ち、マグネトメータをやめて、グラディオメータだけで見るのです。</p>
<p>ここまで長かったので保存しておきましょう！</p>
<pre data-frame="single"><code>from mne.inverse import write_inverse_operator
write_inverse_operator(&#39;/home/hoge/fuga&#39;, inverse_operator)</code></pre>
<p>このinverse_operatorが作れたら、あとは色々出来ます。</p>
<h3 id="手順7-ソース推定">手順7 ソース推定</h3>
<p>まずは、ソース推定をやってみましょう。</p>
<pre data-frame="single"><code>from mne.minimum_norm import apply_inverse
source = apply_inverse(evoked, inverse_operator, 1 / 9)</code></pre>
<p>ちなみに、ここではevokedを使っていますが、<br />
epochsならapply_inverse_epochs、rawならapply_inverse_rawです。</p>
<pre data-frame="single"><code>from mne.minimum_norm import apply_inverse_epochs
source = apply_inverse_epochs(evoked, inverse_operator, 1 / 9)</code></pre>
<pre data-frame="single"><code>from mne.minimum_norm import apply_inverse_raw
source = apply_inverse_raw(evoked, inverse_operator, 1 / 9)</code></pre>
<p>ちなみに、epochsの場合はlistを返します。<br />
listの内容はSourceEstimate , VectorSourceEstimate , VolSourceEstimateです。<br />
SourceEstimateがBemベースの結果ですね。</p>
<p>一旦、これを図示してみましょう。</p>
<pre data-frame="single"><code>source[0].plot(time_viewer=True)</code></pre>
<p>やりました！これぞ、MNE-pythonの真髄、割り算であります！</p>
<p>このtime_viewer=Trueは時間を追って見ていきたい時につけると良いオプションです。</p>
<p>さて、これで出てきたsourceの中にdataという変数があります。<br />
まさに膨大な数です。脳内の膨大な場所について電流源推定したのです。<br />
これは、一つ一つが脳内で起こった電流と考えて良さそうです。細かい所は公式サイト見てください。</p>
<p>こんな膨大な数列があっても困りますよね？脳のどこの部位なのかわかりませんし。<br />
そこで、freesurferのラベルデータを使います。<br />
それによって、脳のどの部分なのか印をつけてやるのです。</p>
<h3 id="手順8前半ラベル付け">手順8、前半ラベル付け</h3>
<p>freesurferにはいくつかのアトラスがあります。アトラスとは、地図みたいなものですね。</p>
<p>詳しくはここをみて下さい。<br />
<a href="https://surfer.nmr.mgh.harvard.edu/fswiki/CorticalParcellation">https://surfer.nmr.mgh.harvard.edu/fswiki/CorticalParcellation</a><br />
desikan atlasとかDestrieux Atlasとか色々ありますよね。<br />
こういうのを読み込まねばなりません。ターミナルでこのように打ってみて下さい。</p>
<pre data-frame="single"><code>ls $SUBJECT_DIR</code></pre>
<p>もしfreesurferを既に動かしているならば、解析済みのMRIが沢山あるはずです。<br />
サブジェクトの中身にはlabelというディレクトリがあります。<br />
この中にいっぱいそういうfreesurferのアトラスが入っています。</p>
<p>ファイルの形式には二種類あり、annot形式とlabel形式があります。<br />
annot形式は新しく開発されたアトラスが入っていて、label形式はブロードマンと思います。<br />
annot形式の内容はこのように読みます。</p>
<pre data-frame="single"><code>from mne import read_labels_from_annot
labels = read_labels_from_annot(subject, parc=&#39;aparc&#39;)</code></pre>
<p>詳しくは公式サイト(ry<br />
この関数はラベルのリストを読んできます。<br />
parcは一応aparcとaparc.a2009sというに種類のものがあって、<br />
このうち後者のほうが新しい分け方らしいです。どっちがいいとかはない。<br />
こうして読んだら、labelのリストが出てきます。単体のlabelは下記で。</p>
<pre data-frame="single"><code>from mne import read_label
label = read_label(filename, subject = None)</code></pre>
<p>これでlabelを読み込めたら、次はそれを当てはめることになります。<br />
Labelオブジェクトにはnameというメンバー変数があるので、自分がどれを見ているのかは確認できます。<br />
が、nameだけでは実際はイマイチわかりません。<br />
freesurferの元論文を見てからどこかを見つけていきましょう。</p>
<p>ここ、どのラベルがそれなのかサクッと調べたいですよね？<br />
filter関数やリスト内包表記でも使うのがいいかと思います。</p>
<pre data-frame="single"><code># filter関数
print(list(filter(lambda label: &#39;transv&#39; in label.name, labels)))
# List内包表記
print([label.name for label in labels if &#39;transv&#39; in label.name])</code></pre>
<h3 id="手順8後半label当てはめ">手順8後半、label当てはめ</h3>
<p>では、labelをベースにデータを抜き出しましょう。</p>
<pre data-frame="single"><code>from mne import extract_label_time_course
source_label = extract_label_time_course(source,
                                         labels,
                                         src,
                                         mode=&#39;mean_flip&#39;)</code></pre>
<p>ここではsourceがソースのデータ、srcが左右半球のソーススペースのリストです。<br />
modeはいくつかあります。<br />
mean: それぞれのラベルの平均です。これを使うのが普通でしょうか…<br />
mean_flip: 特異値分解を使ってベクトルが違うやつも取り出すのです。<br />
pca_flip: PCAを使って取り出してくるのです。<br />
max: ラベルの中で最大の信号が出てきます</p>
<p>これで脳内の波形が取り出せたわけです。<br />
これで、色々出来ます。なにしろ、今までwavelet等していたわけですから。</p>
<h3 id="三次元plot">三次元plot</h3>
<p>でも、これだけじゃダメですね。きちんと見てみないと実感がない。<br />
ここで、mayaviとpysurferが登場します。mayaviは三次元を表示するパッケージ、<br />
pysurferはfreesurferをmayaviを使って表示するパッケージですね。<br />
下記はhoge番目のLabelを見ています。</p>
<pre data-frame="single"><code>from mne.minimum_norm import apply_inverse_epochs

hoge = 4
source = apply_inverse_epochs(evoked, inverse_operator, 1 / 9)
brain = source[0].plot(subjects_dir=subjects_dir, time_viewer=True)
labels = read_labels_from_annot(&#39;fsaverage&#39;, subjects_dir=subjects_dir)
brain.add_label(labels[hoge])</code></pre>
<p>これにより、きちんと脳の部位にラベルをつけたまま脳活動を表示できます。<br />
でも、実はこの方法だけじゃラベルつけたまま時系列表示できません。<br />
時系列表示します。</p>
<pre data-frame="single"><code>from mayavi import mlab
import surfer

hoge = 4
scene = mlab.figure()
source = apply_inverse(evoked, inverse_operator, 1 / 9)
labels = read_labels_from_annot(&#39;fsaverage&#39;,
                                subjects_dir=subjects_dir)
brain = surfer.Brain(&#39;fsaverage&#39;,
                     &#39;lh&#39;,
                     &#39;inflated&#39;,
                     subjects_dir=subjects_dir,
                     figure=scene)
brain.add_label(labels[hoge])
source.plot(subjects_dir=subjects_dir,
               time_viewer=True,
               figure=scene)</code></pre>
<p>何やってるかと言うと、mayaviで一旦canvas的なものを作って、<br />
そこに一寸ずつ書き加えているイメージです。<br />
まず、適当にソース推定します。そして、その推定をplot…の前に、<br />
先にsurfer.Brainで脳の画像を作って、add_labelsで脳の特定部位に色を塗ります。<br />
手順前後はいけません！最後にソース推定をplotして終わり。</p>
<h3 id="三次元movie">三次元movie</h3>
<p>三次元で表示したものを動画として保存してドヤ顔しましょう。<br />
先程のスクリプトにsceneというのがありましたね？それを使います。<br />
それを該当の箇所に入力してsave_movieだけです。</p>
<pre data-frame="single"><code>surf = source_estimate.plot(subject[&#39;mri&#39;],
                            surface=&#39;inflated&#39;,
                            hemi=&#39;both&#39;,
                            figure=scene)
surf.save_movie(&#39;hoge.gif&#39;)</code></pre>
<p>ね、簡単でしょ？今回はgifにしてみました。<br />
すげーヌルヌル動くんですが、同人誌の前の君に見せられなくて残念です。</p>
<h3 id="その後のお楽しみ1ソースベースwavelet">その後のお楽しみ1、ソースベースwavelet</h3>
<p>ソースベースでwaveletやりたいなら、特別に楽ちんな関数が実装されています。</p>
<p>induced powerとinter trial coherenceを算出する関数は下記です。<br />
※labelを選ばなければ激重注意！<a href="#fn61" class="footnote-ref" id="fnref61"><sup>61</sup></a></p>
<pre data-frame="single"><code>from mne.minimum_norm import source_induced_power
induced_power, itc=source_induced_power(epochs,
                                        inverse_operator,
                                        frequencies,
                                        label,
                                        baseline=(-0.1, 0),
                                        baseline_mode=&#39;zscore&#39;,
                                        n_cycles=n_cycles,
                                        n_jobs=4)</code></pre>
<p>基本は以前wavelet変換で行った事に、いくつか追記するだけです。<br />
やり方は色々あります。labelはfreesurferのラベルデータです。<br />
これで算出されたwavelet変換の結果の取扱は、前に書いたwavelet変換の結果と同じです。<br />
この関数は、割り算のあとwavelet変換してるのではなくて、<br />
wavelet変換したあと割り算してるっぽいです。<a href="#fn62" class="footnote-ref" id="fnref62"><sup>62</sup></a><br />
これ、コネクティビティを計算する時と手順が逆なんですよね。<br />
なんだかよく分かりませんね…<br />
あと、InducedPowerと言いながら、多分TotalPowerを見ていたりするので、<br />
これを計算する前にepochsに関して以下をやっておく必要があったりします。</p>
<pre data-frame="single"><code>epochs.subtract_evoked()</code></pre>
<p>これやると、多分itcはおかしくなっちゃうので、上記は実は2つ同時に計算は出来てない。</p>
<h3 id="その後のお楽しみ2ソースベースconnectivity">その後のお楽しみ2、ソースベースconnectivity</h3>
<p>ソースベースでコネクティビティ出来ます。<br />
mne_connectivityというパッケージを使います。<br />
これ、元々mneと同じパッケージだったのが別になったやつです。</p>
<pre data-frame="single"><code>from mne_connectivity import spectral_connectivity_epochs
con = spectral_connectivity(
    source_label, method=&#39;coh&#39;, mode=&#39;multitaper&#39;,
    sfreq=500, fmin=30,
    fmax=50, faverage=True, mt_adaptive=True)</code></pre>
<p>使い方はセンサーベースコネクティビティと同じです。<br />
この場合、さっき計算して出したラベルごとのデータと、<br />
ラベルリストを放り込めば、先述の5つの変数が出てくるので楽ちんです。</p>
<h2 id="コラム3-markdownで同人誌を書こう"><em>コラム3-markdownで同人誌を書こう！</em></h2>
<pre data-basicstyle="\normalfont" data-frame="shadowbox"><code>皆さんもこのような科学系同人誌書きたいですよね？
書いてコミケにサークル参加したいですよね？
**難しいLaTexなんて覚えなくても大丈夫。そう、markdownならね！**
LaTeXは添えるだけ。手順は下記。

macならmactexとpandocをインストールします。
ubuntuやwindowsならTeXliveをインストールします。
mactexはググれば出てきます。pandocは
brew install pandoc

ubuntuなら
sudo apt install texlive-lang-japanese
sudo apt install texlive-xetex
sudo apt install pandoc

これでpandocでmarkdownからpdfに変換できるようになります。
例えばDoujinshi.mdというmarkdownファイルを作って

pandoc Doujinshi.md -o out.pdf \
-V documentclass = ltjarticle --toc --latex-engine = lualatex\
-V geometry:margin=1in -f markdown+hard_line_breaks --listings

四角で囲われているところはコードの引用の書式に従って書いた後、
コードの上の```の末尾に{frame=single}と書き加えてください。

これで同人誌に出来るPDFになります。詳しくはググってください。

何故僕が同人誌を書くかって？
君達が同人誌を書いてくれなかったからだ！
今度はぜひ君の素晴らしい同人誌を僕に見せてくれよな！</code></pre>

<h1 id="理論編">理論編</h1>
<p>ここまで実践を行ってきましたが、ブラックボックスでした。<br />
でも、理解する努力はすべきでしょう。ここから理論編に入ります。</p>
<p>内容は高校数学でギリギリやれますし工学部二年生は大抵理解しています<a href="#fn63" class="footnote-ref" id="fnref63"><sup>63</sup></a>が、<br />
初心者には結構難しいです。また、本書はあんま頭のいい人が書いてるわけじゃないです。<br />
だから、ここでは物凄くざっくり(やや不正確な)解説をします。</p>
<h2 id="初心者のための波形解析">初心者のための波形解析</h2>
<p>脳波には波形解析が必須でしょう。波だからね。<br />
波形解析としては下記を行います。</p>
<ul>
<li>フーリエ変換</li>
<li>ヒルベルト変換</li>
<li>非直交Wavelet変換</li>
<li>直交Waveletによる多重解像度解析</li>
</ul>
<p>実は他にもあるのですが、今の所はこれだけ。必要な知識は高校数学。<br />
高校を卒業していない人と忘れた人は下記辺りを参考にすればよいかと。<br />
<a href="https://manabitimes.jp/math">https://manabitimes.jp/math</a></p>
<h3 id="波形解析で得たいものと必要な変換">波形解析で得たいものと、必要な変換</h3>
<p>脳波や脳磁図を解析して貴方は何を得たいでしょうか？<br />
脳波や脳磁図の特定の波長…例えばα波、β波、γ波等の強さを求めたいですね！それもミリ秒単位で！<br />
また、どのくらい位相が揃っているかとかも見たいです。波と波の関係性とかもみたいですね。<br />
なので、必要なのは下記を兼ね備えたデータです。</p>
<ul>
<li>波の強さ</li>
<li>波の位相</li>
<li>波の位置(ミリ秒単位)</li>
<li>注目した周波数以外は無視できる</li>
<li>波と波の関係性</li>
</ul>
<p>波というものは位相があります。出っ張りもあれば凹みもあって、しかもいろいろな波が<br />
重なっていたりして定量化しにくいです。特定の周波数の波の出っ張りと凹みを<br />
両方同じように評価するにはどうすればいいでしょう？</p>
<p>これらを実現するのが周波数解析です。本当は色々な種類の周波数解析があるのですが、<br />
ここでは以下の3つの解析を解説しようと思います。</p>
<ul>
<li>フーリエ変換</li>
<li>Wavelet変換</li>
<li>ヒルベルト変換</li>
</ul>
<h3 id="フーリエ変換とは">フーリエ変換とは</h3>
<p>調べたい波を、全てsinとcosだけで表してしまうやりかたです。<br />
周波数ごとに長いsin,cos波を大きくしたり小さくしたりしながら当てはめます。<br />
要するに、周波数ごとに<br />
<span class="math inline"><em>A</em><em>c</em><em>o</em><em>s</em><em>x</em> + <em>B</em><em>s</em><em>i</em><em>n</em><em>x</em></span><br />
という形に直していきますが、実はもう一寸スマートなやり方があって<br />
<span class="math inline"><em>A</em><em>c</em><em>o</em><em>s</em><em>x</em> + <em>B</em><em>i</em><em>s</em><em>i</em><em>n</em><em>x</em></span><br />
という複素数の形式(!?)に落とし込んでいくのを目指します。<br />
理由は波の強さ、位相を観察するためには複素数のほうが都合がいいからです。</p>
<h3 id="shorttimeフーリエ変換">ShortTimeフーリエ変換</h3>
<p>sinやcosは未来永劫続く波です。そして、実際の波は未来永劫続く波ではないです。<br />
無限に続く波と有限の波を掛け算するのは厳しいですよね？<br />
そこで、有限の波を「この波は実は繰り返し起こってて、実は無限なんだ！」<br />
と嘘こくのがShortTimeフーリエ変換です。<br />
有限の波の最初と最後がブツンと切れると凄く都合が悪いので、<br />
そこは緩やかに減衰させておいて(Taper)その波が続くものと仮定して変換していきます。<br />
要するに、嘘っぱちですが、大まかな振幅とかは解ると思います。</p>
<h3 id="wavelet変換とは">Wavelet変換とは</h3>
<p>sinもcosも未来永劫絶対に減衰しない波であるため、不規則な波のフーリエ変換は元来きついです。<br />
「一部を無理やり切り取ってきて、切り取った波が永遠に続く波と<br />
想定した上で変換すること」は一応可能でも、実は解析結果が凄く荒くなります。<a href="#fn64" class="footnote-ref" id="fnref64"><sup>64</sup></a><br />
そこで、フーリエ変換にほんの少しの細工を施して時間軸を加味したのが<br />
Wavelet変換です。<br />
実は、これにも色々種類があって、主だった所は<br />
非直交連続Wavelet変換と、直交多重解像度解析です。<br />
まず、非直交の話をします。</p>
<p>理解するためにはフーリエ級数を理解する必要があります。</p>
<h3 id="ヒルベルト変換">ヒルベルト変換</h3>
<p>上記とはちょっと違った風な解析ですが、実用上の性質や使い方はwavelet変換によくにています。<br />
wavelet変換は一つの波から「実数部分と虚数部分を抽出してくる変換」<br />
と言えますが、ヒルベルト変換は「元の波から架空の虚数軸部分を作っちゃう変換」みたいなイメージです。<br />
架空の虚軸を出してくればパワーも位相も出し放題ですね。<br />
内容的には逆フーリエ変換を足し算とすると、ヒルベルト変換は引き算みたいなものです。<br />
計算の方法は簡単で、中学校の頃に習う<span class="math inline">1/<em>x</em></span>という風な双曲線を元の波に掛け算してあげるだけです。<br />
この理屈に関しては後で述べます。</p>
<h3 id="フーリエ級数">フーリエ級数</h3>
<p>早速ですが、フーリエ変換の時、元の波は下記のように表します。</p>
<p><br /><span class="math display">$$f(x)=a_0+\sum_{k=1}^{\infty}(a_n\cos{\frac{2\pi nt}{T}}+b_n\sin{{\frac{2\pi nt}{T}}})$$</span><br /></p>
<p>これは何かというと、波を変換している式です。解説します。それぞれ…</p>
<ul>
<li><span class="math inline"><em>f</em>(<em>x</em>)</span>:元の波を表す式</li>
<li><span class="math inline"><em>a</em><sub>0</sub></span>:波のベースの高さ</li>
<li>t:時間</li>
<li>n:解析したい周波数に対応した変数</li>
<li>T:周期(任意の定数)</li>
<li>右辺:特定周波数の波を表す式</li>
</ul>
<p>かなり複雑な式っぽいですが、<span class="math inline">∑</span>の中を御覧ください。<br />
解析したい周波数が変数として与えられてます。これは、特定の周波数だけにしか対応しないのです。</p>
<p>大抵の波はこの単純な波の足し算で説明することが出来るのです。</p>
<p>実はこの方程式を積分したりして解けば、各nに対するaもbも算出することが出来ます。<br />
右辺全体をフーリエ級数、aとbをフーリエ係数と言います。<br />
この式によって規則的なほとんど全ての波を別形式に書き換えられます。<br />
凄いですね！ですが、それだけでは面白くありません。<br />
波をこのように別の式に書き換えた所で僕達がほしい<br />
「波の強さ」「波の位相同期性」「波の位置」の情報がないからです。<br />
なので、上の式を複素数を使って変換して公式を求めます。</p>
<h3 id="複素フーリエ級数">複素フーリエ級数</h3>
<p>高校数学の複素数平面を覚えているでしょうか？全ての二次元の座標は<br />
複素数平面上で下記の式によって表現できます。<br />
<br /><span class="math display"><em>r</em>(<em>c</em><em>o</em><em>s</em><em>θ</em> + <em>i</em><em>s</em><em>i</em><em>n</em><em>θ</em>)</span><br /><br />
高校時代に習った極座標みたいな何かですね！おぼろげに覚えているかも知れません。<br />
最終的にはこの様な形に成れば、波の強さも位相も分かるはずです。</p>
<p>さて、貴方はオイラーの公式をご存知でしょうか？<br />
この世で最も美しく偉大な公式の一つです。(実際人気が高い)<br />
高校数学でギリギリ出てきます。下記です。</p>
<p><br /><span class="math display"><em>e</em><sup><em>i</em><em>θ</em></sup> = <em>c</em><em>o</em><em>s</em><em>θ</em> + <em>i</em><em>s</em><em>i</em><em>n</em><em>θ</em></span><br /></p>
<p>何度見ても美しい公式ですね。<a href="#fn65" class="footnote-ref" id="fnref65"><sup>65</sup></a>崇めて下さい。証明はググってください。<br />
これは美しいだけでなく役に立ちます。まずはこのオイラーの公式による変換を考えます。</p>
<p>端折りますが、オイラーの公式を変形するとsinとcosをeとiで表現することが可能です。<br />
<br /><span class="math display">$$cos \theta = \frac{e^{i\theta} + e^{-i\theta}}{2}$$</span><br /><br />
三角関数なんかいらんかったんや。<br />
というわけで、フーリエ級数の式からsinとcosを排除できます。式を弄くり倒すと、<br />
<br /><span class="math display">$$f(x)=\sum_{n=-\infty}^{\infty}C_ne^{i\pi t/T}$$</span><br /><br />
と変形できます。Cnは変換a,bを複素数でまとめたものです。<br />
この式の右辺を複素フーリエ級数といいます。<br />
フーリエ変換とはフーリエ係数を求める計算のことです。</p>
<p><span class="math inline"><em>f</em>(<em>x</em>)</span>は元の波、<span class="math inline"><em>e</em><sup><em>i</em><em>π</em><em>t</em>/<em>T</em></sup></span>はオイラーの公式を見ると…半径1の円ですね。</p>
<p>ここで知りたいのはCnです。Cnを求めるにはやはり高校数学によって下記のように書き換えられます。<br />
<br /><span class="math display">$$C_n=\frac{1}{T}\int_{-T/2}^{T/2}x(t)e^{-2\pi nt/T}$$</span><br /><br />
<span class="math inline"><em>f</em>(<em>x</em>)</span>は脳波や脳磁図の結果ですので、フーリエ変換は<br />
脳波や脳磁図に絶対値1の複素数を掛け算して積分する操作といえそうです。</p>
<p>plotすると勉強になるかも知れません。i乗とか実際に計算するのはアレなので、実際の計算をする時も<br />
オイラーの公式で展開…と言いたいところなのですが、<br />
python3なんかは複素数の演算ができるので、<span class="math inline"><em>e</em><sup><em>i</em></sup></span>を計算できたりします。凄いですね！！！</p>
<p>というわけで、上の式をそのままpython3流に書けばフーリエ変換は<br />
自分でコーディングすることが出来るわけです。でも、僕は自分ではしないです。<br />
既にそれをする為の最適化されたパッケージは開発されているからです。<a href="#fn66" class="footnote-ref" id="fnref66"><sup>66</sup></a></p>
<p>ところで、フーリエ変換にはFFTという超速いアルゴリズムがあります。<br />
これは畳み込みの定理を組み合わせることでwavelet変換にも応用できます。<br />
結果は変わらないので実際の計算をする時は使うといいでしょう。</p>
<figure>
<img src="img/wavelet_base.png" alt="再掲。Morlet Waveletの2Dプロット" /><figcaption>再掲。Morlet Waveletの2Dプロット</figcaption>
</figure>
<figure>
<img src="img/3d_wavelet_base.png" alt="再掲。3Dプロット" /><figcaption>再掲。3Dプロット</figcaption>
</figure>
<h3 id="結局何をしているのか">結局何をしているのか</h3>
<p>要するに</p>
<p><span class="math inline"><em>波</em> = <em>特</em><em>定</em><em>の</em><em>周</em><em>波</em><em>数</em><em>の</em><em>波</em>1 + <em>特</em><em>定</em><em>の</em><em>周</em><em>波</em><em>数</em><em>の</em><em>波</em>2 + <em>特</em><em>定</em><em>の</em><em>周</em><em>波</em><em>数</em><em>の</em><em>波</em>3...</span></p>
<p><span class="math inline"><em>特</em><em>定</em><em>の</em><em>周</em><em>波</em><em>数</em><em>の</em><em>波</em> = <em>複</em><em>素</em><em>数</em><em>の</em><em>定</em><em>数</em> * <em>基</em><em>準</em><em>の</em><em>波</em></span></p>
<p>という感じに変えていくだけの計算です。各周波数の数列さえわかれば波が表せます。<br />
で、この定数を複素数にしたものが複素数版フーリエ級数。<br />
複素数だから「定数」の絶対値や位相が計算しやすい、ということです。</p>
<p>さて、今あなたは周波数ごとに<br />
<span class="math inline"><em>A</em> + <em>B</em><em>i</em></span> または <span class="math inline">(<em>r</em>, <em>θ</em>)</span> という形の複素数を得ることが出来ています。<br />
これをどう料理していくかが次の問題です。<br />
ここまでくれば高校の複素数です。</p>
<h3 id="スペクトル解析">スペクトル解析</h3>
<p>得たかったものは何だったか思い出しましょう。複素数から「絶対値、位相」が分かるというのは<br />
高校時代に数学をしたことのある人は明らかでしょう。<br />
では、脳波の強さとは何でしょうか？それはエネルギーみたいなものです。<br />
即ち、絶対値の二乗に他なりません！<br />
(物理の人に怒られる表現。実際はそう簡単でもない。)<br />
脳波の位相はもちろん、上記の複素数の位相成分ですね。</p>
<p>フーリエ変換で出て来る数値(フーリエなら係数に相当するやつ)は<br />
スペクトルと業界(脳波以外でも波を使う業界なら全て)で呼ばれています。<br />
特に、自分自身に自分自身を掛け算したものの積分は「パワースペクトル」といいます。<br />
<span class="math inline"><em>f</em>(<em>ω</em>)</span>の絶対値の二乗が力(パワー)、そして位相がそのまま位相です。</p>
<p>この、パワースペクトルの時間単位の平均値が<br />
パワースペクトル密度(PSD)と言われ、脳波解析の結果の一つです。</p>
<p>では、位相についてはどうするでしょうか？<br />
一つの脳波の位相を取り出したところで意味はありません。<br />
位相の良いところは他の波とリズムが揃っているか調べられる所にあります。<br />
「毎回同じ位相を取り続けるかどうか」であったり、<br />
「他の場所の位相とどのくらい差があるか」であったり、色々わかります。</p>
<p>毎回同じかどうかはPhaseLockingFactorとかInterTrialCoherenceと呼ばれ、<br />
それぞれPLF、ITCと略されます。(意味は同じです)<br />
他の場所の位相とどのくらい差があるかはPhaseLockingValueと呼ばれ、<br />
PLVと略されます。(後で書きますが、PLVは頑健ではないので別の指標を使います)</p>
<p>さて、実際の計算は大したことはありません。複素数 <span class="math inline"><em>A</em> + <em>i</em><em>B</em></span> について考えてみましょう。<br />
これの絶対値は $ (A + iB)(A - iB) $であることは自明です。<br />
すなわち、複素共役同士を掛け算したものです。<br />
これ、自分自身をかけ合わせると位相が0になりますが、<br />
他の波の複素共役と掛け合わせると位相の引き算になるのです。<br />
コネクティビティはこういうのを使っていきます。</p>
<p>さて、これまで「複素共役を掛け算して積分したもの」がいっぱい出てきました。<br />
長いので、よく下記のように略されます。<br />
Sxx (xとx、つまり自分と自分の関係、パワースペクトル)<br />
Sxy (xとy、つまり自分と他人の関係、クロススペクトル)<br />
以下、このように書いていきます。</p>
<h3 id="そしてwavelet変換へ">そしてwavelet変換へ</h3>
<p>一旦話を戻し、まずはPowerを考えます。<br />
フーリエ変換の時点では周波数ごとの複素数が一つづつありました。<br />
これでは時間の次元が失われていますね。いつそのPowerだったんだよと思います。<br />
この理由は、フーリエ変換に使うsinとcosが永遠に続く波であるからです。<br />
永遠に続く波を使えば、そりゃ時間軸は表現できるわけ無いです。</p>
<p>それを解決するのがwavelet変換です。<br />
時間軸を表現するためにものさしに使うものは減衰する波の必要があります。<br />
減衰させるには色々あるのですが、Gabor Waveletでは以下のようにします。</p>
<p><br /><span class="math display">$$c\sigma \pi^{\frac{-1}{4}}e{\frac{-1}{2}t^2}e^{i\sigma t}$$</span><br /><br />
この、左側がフーリエ変換のためのやつ、右に付け加えたのが減衰するやつ。</p>
<p>こんな感じの式に色々と定数を付けたのが<strong>Gabor Wavelet</strong>です。</p>
<p>何故定数をつけるかというと、掛け算するときに掛け合わせるものの<br />
絶対値が1じゃないとエネルギーを計算するのが超面倒だからです。<br />
くるくる回りながら減衰する波です。</p>
<p>実際は、これはWaveletとしては結構お粗末なんだそうです。<br />
こいつに引き算を付け加えてスケールしても歪まないようにしたのが<br />
かの有名な<strong>MorletWavelet</strong>です。</p>
<p><br /><span class="math display">$$c\sigma \pi^{\frac{-1}{4}}e{\frac{-1}{2}t^2}(e^{i\sigma t}-\kappa \sigma)$$</span><br /></p>
<p><span class="math inline"><em>κ</em></span>は<span class="math inline"><em>σ</em></span>から導かれる定数です。詳しくはググれ。<br />
ちなみに、これは他にも色々あるやり方の一つです。</p>
<p>Wavelet変換も計算結果が複素数平面として出てきますから、<br />
さっきと同じようにPowerと位相が分かるはずです。しかも、時間別に！</p>
<p>初めてフーリエ級数とか聞いた人はここまで読んで意味がわからなかったと思います。<br />
そんな人には高校数学の美しい物語の複素フーリエ級数関連の記事をお勧めします。</p>
<h3 id="wavelet逆変換とbandpass-filter">wavelet逆変換とbandpass filter</h3>
<p>上記のようにwavelet変換は数値を出すのに応用できるのですが、<br />
これは実はbandpass filterモドキにも応用することが出来ます。<br />
何故なら、周波数を分けちゃう事ができるのと、Wavelet変換は逆変換が出来るからです。<br />
手順としては、Wavelet変換したものの中から欲しい周波数帯域を選んで、<br />
Wavelet逆変換を行えばbandpass filterの一種みたいなものになります。<br />
だから、意外とバンドパスフィルタを先にかけないと駄目ということもないわけです。<br />
ちなみに、これは世間でよく用いられているbandpass filterとはちょっと違います。</p>
<h3 id="morletwaveletとは">MorletWaveletとは</h3>
<p><br /><span class="math display">$$\Psi(t) = c\sigma \pi^{-\frac{1}{4}}e^{\frac{-1}{2}t^2}(e^{i\sigma t}-\kappa \sigma)$$</span><br /></p>
<p><img src="img/morlet.png" alt="morlet.png" /><br />
青が実軸、橙が虚軸です。</p>
<p>括弧の中に引き算が入りました。Morlet Waveletです。[^morlet]</p>
<p>でも、これ、図は綺麗でも式の見た目的に凄く気持ち悪いですよね？<br />
実際に<span class="math inline"><em>σ</em></span>を小さい値にしてみるとガウシアンな曲線がグチャッと潰れて<br />
実軸小さすぎで虚軸が大きすぎな実に気持ち悪い状態になります。<br />
その結果、<strong>パラメータによっては波の真ん中よりも周辺の方が過大評価されてしまいます。</strong><br />
<img src="img/morlet1.png" alt="morlet1.png" /></p>
<p>青が絶対値、橙が実軸、緑が虚軸です。</p>
<p>フーリエ変換に時間軸にガウシアンな関数を畳み込んで時間軸を加え、<br />
歪みを取り除いたのに こうなってしまっては何のために<br />
ガウシアンにしたのかさっぱりわからないですね🤔</p>
<h3 id="気持ち悪さ対策">気持ち悪さ対策</h3>
<p><strong><span class="math inline"><em>σ</em></span>を大きく取ればMorletWaveletとGaborWaveletは近似され、ほぼ重なります。</strong><br />
下のプロットを見ても明らかでしょう。<br />
時間解像度を犠牲にすれば全然問題ないね！<br />
実際、僕も<span class="math inline"><em>σ</em> = 7</span>のMorletWaveletを愛用しており、実用上全く問題ないです。<br />
良かったね！解散！<br />
↓<span class="math inline"><em>σ</em></span>が7のGaborとMorletの比較。</p>
<p><img src="img/morletvsgabor.png" alt="morletvsgabor.png" /><br />
重なって線が一本しか見えない！</p>
<p>…でも、根本的な解決になっていませんね。<br />
そもそも<span class="math inline"><em>σ</em></span>が小さい場合はどうすれば良いのでしょうか…。<br />
この場合は我慢してMorletWaveletを使うか、そうでなければ別のガウシアンに依存しない<br />
Waveletを用いるところだと思います。</p>
<p>この世には他にも色々なWaveletがあります。</p>
<h3 id="フーリエ逆変換を使って算出するwavelet">フーリエ逆変換を使って算出するWavelet</h3>
<p>実は、フーリエ逆変換すると算出されるWaveletというのが数種類発見されています。<br />
なんて変態的な導出の仕方なんでしょう！と思います。<br />
これらの利点は挙げろと言われると難しいのですが、<br />
Morletと比べて真ん中が凹まないやつが発見されていますから、そこが利点かも？</p>
<p>例えば2000年に入ってから知られるようになった一般モールスWavelet[^morse]というWaveletがあります。<br />
(Morseはモールスっていう読み方で正しいのかどうかは分からないので詳しい人教えて下さい)</p>
<p>既にこれを脳波解析に応用している論文もあります。定義は</p>
<p><br /><span class="math display"><em>Ψ̂</em>(<em>w</em>) = <em>s</em><em>i</em><em>g</em><em>n</em>(<em>ω</em>)<em>α</em><sub><em>β</em><em>γ</em></sub><em>ω</em><sup><em>β</em></sup><em>e</em><sup> − <em>ω</em><sup><em>γ</em></sup></sup></span><br /></p>
<p>という式…ではなく、<strong>これのフーリエ逆変換が一般モールスWavelet</strong>です。<br />
計算上はFFTやるならフーリエ変換の手間が省けてお得ですね！</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/139153/1f01fc38-d49a-c47f-0546-3072f2cac768.png" alt="morse.png" /><br />
MorletWaveletとそっくりです。(パラメータいじって似せました)</p>
<p>ちなみに、このwaveletは<span class="math inline"><em>β</em></span>と<span class="math inline"><em>γ</em></span>で調整するんですが、<br />
<span class="math inline"><em>β</em></span>が低かったらちびまる子ちゃんの永沢君みたいに<br />
真ん中が尖った波になります。<br />
<img src="img/nagasawa.png" alt="super_nagasawa.png" /></p>
<p>永沢君みたいなwaveletが欲しかった人には朗報なんですかね？<br />
(周波数解像度は超絶悪くなります)</p>
<h2 id="直交wavelet">直交Wavelet</h2>
<p>んで、直交Waveletの話がまだだったんですが…マジレス、脳波解析に向きません。<br />
向きませんが多用されています。<br />
主に、リアルタイム解析に於いて。<br />
何故かって？多分、計算コストが小さいのと端の問題が深刻じゃないからと思います…多分。</p>
<p>一応、ウェーブレット10講というガチな本に書いてありますので、<br />
知りたい人は読んで下さい。下手な解説書よりもこれ読んだがいいです。<br />
名著です…役に立つかは分からんけど。</p>
<p>直交Waveletって、すっごいギザギザしていて、普通じゃないです。<br />
図をご覧ください。<br />
<img src="img/orthogonal_wavelet.png" alt="orthogonal_wavelet" /><br />
こいつがどういうものかというと、上記のWavelet変換が<br />
時間軸に於いて無限であることを辞められなかったのに対して、<br />
なんと、このWaveletは時間軸に於いて有限です！</p>
<p>これって凄いことなんです。</p>

<h2 id="ヒルベルト変換-1">ヒルベルト変換</h2>
<p>wavelet変換は1つの実数の波から実軸と虚軸を分離しました。<br />
でも、そもそも元々の波は実軸に存在します。おかしいですね？<br />
ということは、もしかして波って本来実軸と虚軸があるのか？ってなります。<br />
そう、実はそうなのです！<br />
男と女、ウサギとカメ、sinとcos、実軸と虚軸の様に、<br />
一つの波があればその相方が存在するのです！<br />
そう、今君は相方の波を探しに行きたくなりました。</p>
<p>元々の実軸をそのまま実軸にして、新たな虚軸を生み出す変換が<br />
ヒルベルト変換です。導出の仕方は、フーリエ変換と似ています。<br />
ヒルベルト変換の結果は、元の波をcosとするとsin。<br />
つまり、まるでWavelet変換のように波の振幅を計算できるのです。<br />
凄いですね！</p>
<p>Wavelet変換は掛け算をして積分をして算出していましたがヒルベルト変換では双曲線を掛け算します。<br />
ここについて数学を理解するためにはコーシー主値だとか<br />
ディラックのデルタ関数を使う必要があります。<br />
デルタ関数とかコーシー主値の解説は出来るけど超絶めんどいのでしません！<br />
というか、この本で読むより別にいい本がいくらでもあります。<br />
それらの出ないところだけ解説します！<br />
一部無限大が出てきて気持ち悪さが残りますが、仕様です。<br />
<img src="./img/soukyoku.png" alt="双曲線" /><br />
これについては、既にwavelet変換と同等の性能を持っていることが<br />
分かっている…らしいですが、実際どうなんでしょうね？<br />
なお、このセクションは数学者がブチ切れると思うので、恐恐書いています。</p>
<h3 id="複素フーリエ級数とフーリエ逆変換の復習">複素フーリエ級数とフーリエ逆変換の復習</h3>
<p>波とは、時間軸と振幅の軸がある二次元のデータです。<br />
とりあえず、フーリエ変換の式を書いてみましょう。<br />
<span class="math inline"><em>f</em>(<em>t</em>)</span>が元の波、<span class="math inline"><em>f̂</em>(<em>w</em>)</span>がフーリエ変換結果、tが時間、wが周波数として、<br />
細かい所を省いてこんな感じです。</p>
<p><br /><span class="math display"><em>f̂</em>(<em>w</em>) = ∫<sub> − ∞</sub><sup>∞</sup><em>f</em>(<em>t</em>)<em>e</em><sup> − <em>i</em><em>w</em><em>t</em></sup><em>d</em><em>t</em></span><br /></p>
<p>波というのは時間と振幅の二次元データですね。<br />
それを<span class="math inline"> − ∞</span> ~ <span class="math inline">∞</span>の周波数に変換しちゃうのがフーリエ変換でした。<br />
こんな感じです。</p>
<pre><code>振幅 * 時間　→　周波数 * 周波数ごとの複素数</code></pre>
<p>そんで、フーリエ逆変換はこんな感じでした。</p>
<p><br /><span class="math display"><em>f</em>(<em>t</em>) = ∫<sub> − ∞</sub><sup>∞</sup><em>f̂</em>(<em>w</em>)<em>e</em><sup><em>i</em><em>w</em><em>t</em></sup><em>d</em><em>w</em></span><br /></p>
<pre><code>周波数 * 周波数ごとの複素数　→　振幅 * 時間</code></pre>
<p>さて、このフーリエ逆変換は複素フーリエ級数の書き方で書くとこう書けます。<br />
<br /><span class="math display">$$f(t) = \sum_{n=-\infty}^{\infty}{C_n e^{iwt}}$$</span><br /></p>
<p>これは、単に<span class="math inline">∫</span>を<span class="math inline"><em>Σ</em></span>に、<span class="math inline">$\hat{f(w)}$</span>を<span class="math inline"><em>C</em><sub><em>n</em></sub></span>にそれぞれの書き換えただけです。<br />
つまり、各周波数nについて、<span class="math inline"> − ∞</span> ~ <span class="math inline">∞</span>までを全部足し算するのがフーリエ逆変換です。<br />
ちなみに、<span class="math inline"><em>C</em><sub><em>n</em></sub></span>は複素数です。</p>
<p>フーリエ逆変換はこの無限の<span class="math inline"><em>C</em><sub><em>n</em></sub></span>で出来た複素数の級数から実際の波を求める計算といえます。</p>
<h3 id="フーリエ変換の負の位相の性質">フーリエ変換の負の位相の性質</h3>
<p>さて、<span class="math inline">$\hat{f(w)}$</span>の<span class="math inline"><em>w</em></span>は<span class="math inline"> − ∞</span> ~ <span class="math inline">∞</span>の周波数(スカラー値)なのですが、<br />
ここで複素数<span class="math inline"><em>f̂</em>(<em>w</em>)</span>と<span class="math inline"><em>f̂</em>( − <em>w</em>)</span>について<br />
<br /><span class="math display">$$\hat{f}(w) = \overline{\hat{f}(-w)}$$</span><br /><br />
と、複素共役になるという事が知られています。<br />
ぱっと言われて「ん？」となった人はフーリエ変換の導出を復習してみてください。</p>
<h3 id="相方の波を求める">相方の波を求める</h3>
<p>さて、<span class="math inline"><em>f̂</em>(<em>w</em>)</span>というのは複素数です。<span class="math inline"><em>a</em>(cos <em>θ</em> + <em>i</em>sin <em>θ</em>)</span>という形をしています。<br />
つまり、<br />
<br /><span class="math display">$$\hat{f}(w)+\overline{\hat{f}(-w)} = a(\cos\theta + i\sin\theta) + a(cos\theta - isin\theta)$$</span><br /><br />
となりますね。だから<br />
<br /><span class="math display">$$\hat{f}(w)+\overline{\hat{f}(-w)} = 2a\cos\theta$$</span><br /><br />
これは実軸のcos波です。フーリエ逆変換はこのように共役な複素数を全部を足し合わせていく変換で、<br />
正と負の周波数は複素共役の関係であったわけですから、実数が出てくるのは感覚的には普通でしょう。</p>
<p>では、虚軸だとかsin波はどうでしょう？こうすればいいだけです！<br />
<br /><span class="math display">$$\hat{f}(w)-\overline{\hat{f}(-w)} = 2ai\sin\theta$$</span><br /><br />
相方が出てきました！フーリエ逆変換を足し算とすれば、ヒルベルト変換は引き算なのかもしれない！</p>
<h3 id="式の形にする">式の形にする</h3>
<p>全ての正の周波数のフーリエ級数から、負の周波数のフーリエ級数を引き算することで<br />
sin波が出るのですが、これをきちんと式で表してみましょう。sgn関数を使います。<br />
sgn関数とはsgn(x)のxが正のときは1、負のときは-1を吐き出す関数で、sinに似てますが関係ないです。</p>
<p><br /><span class="math display"><em>s</em><em>g</em><em>n</em>(<em>w</em>)<em>f̂</em>(<em>w</em>)</span><br /></p>
<p>という感じにすると、正の成分から負の成分を引いていったことになりますね。<br />
では、こいつを元に、フーリエ逆変換の<span class="math inline"><em>f̂</em>(<em>w</em>)</span>を全部引き算にしてやりましょう。<br />
ただ、これだけでは虚数になっちゃうので-iを掛け算してあげます。<br />
ヒルベルト変換の結果…つまり、欲しかった虚軸の波を<span class="math inline"><em>H</em>(<em>t</em>)</span>とすると<br />
<br /><span class="math display"><em>H</em>(<em>t</em>) = ∫<sub> − ∞</sub><sup>∞</sup> − <em>i</em><em>s</em><em>g</em><em>n</em>(<em>w</em>)<em>f̂</em>(<em>w</em>)<em>e</em><sup><em>i</em><em>w</em><em>t</em></sup><em>d</em><em>w</em></span><br /><br />
となります。やりました！ヒルベルト変換です！</p>
<h3 id="さらに形を整える">さらに形を整える</h3>
<p>上の式からフーリエ変換の成分を駆逐してやります。<br />
sgn関数をフーリエ変換すると<span class="math inline"> − <em>i</em><em>π</em>/<em>t</em></span>になることが知られています。<br />
(これを示すためにはデルタ関数のフーリエ変換について書くことになり、超絶めんどいので書きません)<br />
では、加工するまえにフーリエ変換の畳み込みの復習をしていきましょう。</p>
<h3 id="畳み込み定理">畳み込み定理</h3>
<p>フーリエ変換やラプラス変換において以下のような公式があります。<br />
Fをフーリエ変換やラプラス変換とすると以下が成立します。</p>
<p><br /><span class="math display"><em>F</em>(<em>a</em> * <em>b</em>) = <em>F</em>(<em>a</em>)<em>F</em>(<em>b</em>)</span><br /></p>
<p>a*bというのは畳み込みを表します。掛け算したうえで積分するというやつですね。</p>
<p>これを使ってヒルベルト変換っぽく作ってみます。ここで、畳み込みの公式を示しておきます。<br />
<br /><span class="math display"><em>F</em>(<em>a</em> * <em>b</em>) = ∫<sub> − ∞</sub><sup>∞</sup><em>a</em>(<em>x</em>)<em>b</em>(<em>t</em> − <em>x</em>)<em>d</em><em>x</em></span><br /></p>
<h3 id="よく見るヒルベルト変換の式の導出">よく見るヒルベルト変換の式の導出</h3>
<p>ヒルベルト変換をフーリエ変換してみます。<br />
<br /><span class="math display"><em>F</em>(<em>H</em>(<em>t</em>)) = <em>s</em><em>g</em><em>n</em>(<em>w</em>)<em>f̂</em>(<em>w</em>) =  − <em>i</em><em>s</em><em>g</em><em>n</em>(<em>w</em>)<em>F</em>(<em>f</em>(<em>t</em>))</span><br /><br />
これは畳み込みにすごーく近くないですか？ここで、仮にsgnのフーリエ逆変換の結果をGとします。<br />
<br /><span class="math display"> = <em>F</em>(<em>G</em>)<em>F</em>(<em>f</em>(<em>t</em>)) = <em>F</em>(<em>G</em> * <em>f</em>())</span><br /><br />
で、両辺のフーリエ変換を解除します。<br />
<br /><span class="math display"><em>H</em>(<em>t</em>) = <em>G</em> * <em>f</em>(<em>t</em>)</span><br /><br />
理由を話し出すとちょっと終わらないので今回は言いませんが、実はGは1/tであることが知られています。<br />
<br /><span class="math display"><em>H</em>(<em>t</em>) = 1/<em>t</em> * <em>f</em>(<em>t</em>)</span><br /><br />
凄いですね！これやこの、ヒルベルト変換です！</p>
<p>うん、数学者は見ていないね？…窓に！窓に！</p>

<h2 id="コネクティビティ各論">コネクティビティ各論</h2>
<p>コネクティビティについては色んなmethodがあります。なので、スペクトルとは章を分けてみました。<br />
ここではコネクティビティそれぞれのmethodについて僕の考えを述べます。間違ってたらごめんね。<br />
ちなみに、以下の方法は基本、低周波じゃないと無理です。<br />
γ波なんかを処理しようとするのは無謀なのであります。</p>
<h3 id="plvとcoherenceの問題点">PLVとCoherenceの問題点</h3>
<p>一つの個体の中でコネクティビティを語る場合、<br />
PLVとCoherenceという指標は最早形骸である。<br />
<strong><span style="color: red">敢えて言おうカスであると！</span></strong></p>
<p>さて、フーリエ変換のところでコネクティビティについてちらりと書きました。<br />
位相の差をとっていけばPLVという「どのくらい波が関連しているか」という<br />
指標になると書きました。式で表すと</p>
<p><br /><span class="math display">$$PLV = |\overline{\frac{Sxy}{|Sxy|}}|$$</span><br /></p>
<p>という感じです。この指標は正しいです。が、大きな欠点があります。<br />
脳波にしろ、脳磁図にしろ、脳内に電極をブチ込むやり方ではなく、<br />
漏れて拡散してきた物を捉えることになります。<br />
ということは、何らかの大きな震源が近くにある場合、<br />
影響を受けて似たような波が出た全てのチャンネルは<br />
コネクティビティが「ある」と間違った結果が出てきてしまうのです。<br />
図に沿って言うと、2つの青い点(センサー)で、一つの赤い波を同時に測定すると、<br />
繋がっていると勘違いするのです。常識的におかしい。</p>
<figure>
<img src="./img/plv.png" alt="PLVでコネクティビティを計算する場合、この図の青い点が繋がっていると言うことになる。" style="width:14cm" /><figcaption>PLVでコネクティビティを計算する場合、この図の青い点が繋がっていると言うことになる。</figcaption>
</figure>
<p>さて、PLVについて語ってきましたが、Coherenceという計算の方法もあります。<br />
以下のように計算します。これもまた、違和感のない計算方法ですが、<br />
PLVと同様に拡散やノイズの影響が大きいです。</p>
<p><br /><span class="math display">$$Coherence = \frac{\overline{|Sxy|}}{\sqrt{\overline{|Sxx|} * \overline{|Syy|}}}$$</span><br /></p>
<p>ちなみに、Coherenceに位相情報を残したものがCoherencyです。<br />
<br /><span class="math display">$$Coherence = \frac{\overline{Sxy}}{\sqrt{\overline{|Sxx|} * \overline{|Syy|}}}$$</span><br /><br />
こいつの使いみちは僕はあまり知らないです…</p>
<h2 id="plvやcoherenceの欠点の克服">PLVやCoherenceの欠点の克服</h2>
<p>いくつか方法があります。大きく分けて2つ、またはその組み合わせです。</p>
<ul>
<li>拡散する前の電流を推定する</li>
<li>拡散しても大丈夫な計算方法を採る</li>
</ul>
<h3 id="拡散する前の電流">拡散する前の電流</h3>
<p>CurrentSourceDensityという方法があるらしいです。<br />
こっちはソースベース解析ほどバリバリに推定するわけではない感じですが、<br />
PLVの弱点を補う方法ですね。残念ながらMNEpythonには未実装です。<br />
ていうか、僕はこの方法を知らないのです。</p>
<h3 id="plvの発展系">PLVの発展系</h3>
<p>mne-connectivityに実装されている有名所として、PLIとWPLIを紹介します。</p>
<h4 id="pli">PLI</h4>
<p>PhaseLagIndexという指標があります。こいつは上記の拡散をキャンセルしてしまう方法で、<br />
MNEではspectral_connectivity関数に実装されています。式は下記</p>
<p><br /><span class="math display">$$PLI = \overline{|sign(Im(Sxy))|}$$</span><br /></p>
<p>ここで、signは内容が正なら1、0なら0、負ならｰ1を返す関数。<br />
Imは虚軸だけを返す関数です。<br />
位相が常にxより進んでいたり、遅れている奴だけ加算していき、<br />
位相のズレが0付近をウロウロしてるやつやバラバラなやつは消すメソッドですね。<br />
確かにこれならばさっき挙げた偽のコネクティビティは出ないでしょう。<br />
とはいえ、結構荒っぽいやり方なので、僕は初見「マジカヨ…」って思いました。<br />
これでConnectivityをPlotしたら、隣同士ばかり繋がるような図じゃなくなります。<br />
つまり、成功しているということですかね。</p>
<h4 id="wpli">WPLI</h4>
<p>上記で、正なら1、負ならｰ1というのについてマジカヨ感が漂うのですが、<br />
そこをもう少しスムーズにしたのがWeightedPhaseLagIndexです。<br />
これは位相のズレが<span class="math inline"><em>π</em>/2</span>に近ければ近いほど大きな値を、<br />
<span class="math inline"> − <em>π</em>/2</span>に近ければ近いほど小さな値を入れ込みます。<br />
そうすることによって、ノイズに強くなった…らしいです。<br />
そりゃそうですよね。PLIは一寸ノイズがあったら1か-1に振り切れますもの。<br />
式は以下。</p>
<p><br /><span class="math display">$$WPLI = \frac{|\overline{Sxy}|}{\overline{|Sxy|}}$$</span><br /></p>
<p>見にくい記法ですみません…<br />
まぁ、それでも「マジカヨ…」感はありますけどね。</p>
<h3 id="coherenceの発展系">Coherenceの発展系</h3>
<p>さて、PLI系は同一の電流源からのラグをとっていたわけですが、<br />
同様のやり方がImaginaryCoherenceです。</p>
<p>これはCoherence虚軸のみを加算平均したものです。<br />
虚軸を加算平均するということは、位相が<span class="math inline"><em>π</em>/2</span>ずれたら最大になりますね。<br />
式は下記のような感じです。</p>
<p><br /><span class="math display">$$Coherence = \frac{\overline{Im(Sxy)}}{\sqrt{\overline{|Sxx|} * \overline{|Syy|}}}$$</span><br /></p>
<h3 id="でこういうのってロバストなの">で、こういうのってロバストなの？</h3>
<p>分からない…僕には何もわからないんです…実際にコネクティビティを計算してみればいいです。<br />
各方法で計算した所、全く違う結果になることはよくあるんです。悲しくなりますね。</p>
<h3 id="グラフ理論">グラフ理論</h3>
<p>さらなる解析として、グラフ理論があります。<br />
これは「互いにどんな風に繋がっているかな？」というのを<br />
考えていく理論です。色々なやり方があります。<br />
例えば、一筆書きでどんな風に繋ぐか、ループを作らずにどんな風に繋ぐかとか、<br />
そういうノリのやつです。後述します。</p>

<h2 id="ソースベース解析の理屈">ソースベース解析の理屈</h2>
<p>かなり面倒いので丁寧にはかけません。ここからは線形代数の範囲になります。<br />
分かる人に言うと、疑似逆行列を正規化した方法がMNEです。</p>
<p>以下、二行目で「は？」ってなったそこの君、PRMLを読んで下さい。<br />
PRMLを読めないそこの君。君のために解説を書きます。<br />
誤解を恐れずに脳内の活動を推定する方法を超簡単に言いますと、<br />
<strong>ソース推定とは鶴亀算であり、割り算です。</strong><br />
「鶴亀算と割り算は別のものじゃんｗｗｗ」と思った人は頑張らねばなりません。<br />
なので、そういう人のために、割り算については後述します。</p>
<p>さて、MNEはそんなふうに割り算をしてあげた上で、答えをもうちょっと<br />
スムーズにしてあげる為に正規化という処理を施して上げるものです。</p>
<p>つまり、<strong>MNEとはスムージング入りの割り算である！</strong><br />
と初心者には伝えたいです(怒られそう…)<br />
数学得意な人のために一言で言うと下記の表のとおりです。</p>
<table>
<thead>
<tr class="header">
<th>Method</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MNE</td>
<td>脳全体のノルム関する重み付き最小ノルム解</td>
</tr>
<tr class="even">
<td>dSPM/sLORETA</td>
<td>分散で補正したMNE</td>
</tr>
<tr class="odd">
<td>eLORETA</td>
<td>事前確率分布を事後確率分布で補正するMNE</td>
</tr>
<tr class="even">
<td>beamformer法</td>
<td>波のノルム関する重み付き最小ノルム解</td>
</tr>
</tbody>
</table>
<h3 id="もう一寸ちゃんと">もう一寸ちゃんと</h3>
<p>まず、脳のソースから出た磁力…電力でも良いですが、そのようなものがセンサーに届く時、<br />
その強さはソースで発生した電力、磁力に比例するはずです。<br />
詳細はアレですね…マクスウェルの方程式ですね。多分、距離の二乗には反比例すると思います。<br />
つまり…距離云々を除くと簡単な一次連立方程式になるはずなんです。<br />
センサーで捉えた情報を<span class="math inline"><em>y</em></span>とし、ソースで発生したのを<span class="math inline"><em>x</em></span>としましょう。<br />
あるソースで発生した電力とセンサーで捉えた電力の関係を下記の式で表せるとします。<br />
<br /><span class="math display"><em>y</em> = <em>a</em><em>x</em></span><br /><br />
これは単純な掛け算なわけですが、1センサー1ソースではなく、多センサー多ソースです。<br />
ここで、沢山になったy,a,xについて、下記のように表すとします。<br />
<br /><span class="math display"><em>Y</em> = <em>y</em><sub>1</sub>, <em>y</em><sub>2</sub>, <em>y</em><sub>3</sub>......</span><br /><br />
<br /><span class="math display"><em>X</em> = <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>......</span><br /><br />
ここで<span class="math inline"><em>A</em></span>を下記を満たす行列とします。<br />
<br /><span class="math display"><em>Y</em> = <em>A</em><em>X</em></span><br /><br />
この連立方程式を解きます。</p>
<p>横と縦を掛け算するので、行列の掛け算は連立方程式になるのは自明です。<br />
これがどうしても連立方程式に見えない人は、<br />
行列代数の入門書でも読んで下さい。ネットで検索するよりこれは本の方がいいです。</p>
<p>では解きま…じつは解けません。一次連立方程式はあんまり数が多くなると解けなくなるのです。<br />
鶴亀カブトムシ算は無限の解があるのです。</p>
<p>で、最も真実に近いっぽいのを推定していきます。<br />
今回、脳全体のある一瞬の波が最も小さくなるような波を推定しましょう。<br />
何故最小にしたいかって？乱れた波というものはグニョングニョンしてるので<br />
直感的に言ってグニョングニョンしてる波よりも静かな波のほうが<br />
本物っぽいでしょう？と位にしか言えません！<br />
その本物っぽい割り算を<span class="math inline"><em>A</em><sup>†</sup></span>として<br />
<br /><span class="math display"><em>X</em> ⇒ <em>A</em><sup>†</sup><em>Y</em></span><br /><br />
という感じにするのを目指します。</p>
<p>この方法がMinimumNormEstimation(MNE)です。<br />
(他に一つ一つの波が一番小さくなるbeamformer法とか色々あります)</p>
<p>条件<span class="math inline"><em>Y</em> = <em>A</em><em>X</em></span>のもとで<span class="math inline"><em>X</em></span>を小さくしたい<a href="#fn67" class="footnote-ref" id="fnref67"><sup>67</sup></a>のです。<br />
<span class="math inline"><em>X</em></span>が小さいってことは下記の式が小さいってことです。</p>
<p><br /><span class="math display">||<em>X</em>||<sup>2</sup></span><br /></p>
<p>ここで、<span class="math inline">||<em>X</em>||</span>とはXの対角成分の事を指します。<br />
例えばXの縦をチャンネル、横を時間軸とします。<br />
<span class="math inline">||<em>X</em>||<sup>2</sup></span>がどうなるかと言うと、<span class="math inline">||<em>X</em><sup><em>T</em></sup><em>X</em>||</span>となります。<br />
何故これの対角行列かと言うと、<br />
Xの1行目…例えばチャンネル1としましょう。これとXの2列目…これはチャンネル2です。<br />
これらの掛け算はチャンネル間の相関を表しているのであって、振幅を表しません。<br />
つまり、対角行列のみが大きさを表すのです。</p>
<p>まず、ラグランジュの未定乗数法という公式を使います。知らないカスはググれ。<br />
僕はこんな同人誌を書く程度には親切で友達がいっぱい出来そうな人<a href="#fn68" class="footnote-ref" id="fnref68"><sup>68</sup></a>なので教えてあげます。<br />
最大値や最小値を手軽に導くテクニックです。<br />
最大値や最小値は極値になるので、微分して0になればいいのです。</p>
<p><span class="math inline"><em>f</em>(<em>x</em>, <em>y</em>)</span>が極値になるx,yは</p>
<p><br /><span class="math display"><em>L</em>(<em>x</em>, <em>y</em>, <em>λ</em>) = <em>f</em>(<em>x</em>, <em>y</em>) − <em>λ</em><em>g</em>(<em>x</em>, <em>y</em>)</span><br /><br />
の時に</p>
<p><br /><span class="math display">$$\frac{\partial L}{\partial \lambda}= \frac{\partial L}{\partial y}= \frac{\partial L}{\partial x}=0$$</span><br /><br />
の解、または<br />
<br /><span class="math display">$$\frac{\partial g}{\partial x}= \frac{\partial g}{\partial y}$$</span><br /><br />
の解。…という感じの公式です。<br />
行列の微分をしないといけないので、行列の微分の仕方を確認しておきます。<br />
<br /><span class="math display">$$\frac{\partial a^tx}{\partial x}=a$$</span><br /><br />
<br /><span class="math display">$$\frac{\partial x^ta}{\partial x}=a$$</span><br /></p>
<p>今回はこれを微分します。<br />
<br /><span class="math display">$$L=\frac{X^2}{2}-\lambda^T (AX-Y)$$</span><br /></p>
<p><br /><span class="math display">$$\frac{\partial L}{\partial X} = X - A^T\lambda$$</span><br /><br />
これが0になるので<br />
<br /><span class="math display"><em>X</em> = <em>A</em><sup><em>T</em></sup><em>λ</em></span><br /><br />
<br /><span class="math display"><em>Y</em> = <em>A</em><em>X</em> = <em>A</em><em>λ</em><em>A</em><sup><em>T</em></sup> = <em>A</em><em>A</em><sup><em>T</em></sup><em>λ</em></span><br /><br />
<br /><span class="math display"><em>X</em> = <em>A</em><sup><em>T</em></sup>(<em>A</em><em>A</em><sup><em>T</em></sup>)<sup> − 1</sup><em>Y</em></span><br /></p>
<p>これで無事<span class="math inline"><em>X</em></span>を<span class="math inline"><em>A</em></span>と<span class="math inline"><em>Y</em></span>で表せました。<br />
まぁ、ここまでは普通の最小二乗の最適解なのだけれど。</p>
<h3 id="もっと良くする">もっと良くする</h3>
<p>もっと良くします。</p>
<p><br /><span class="math display"><em>Y</em> = <em>A</em><em>X</em></span><br /></p>
<p>という感じの割り算をときます。<br />
が、今回はL2ノルムを使います。L2ノルムについてはググって下さい。<br />
L2ノルムは要するに二乗をちっさくしようと言うことです。</p>
<p><br /><span class="math display"><em>a</em><em>r</em><em>g</em><em>m</em><em>i</em><em>n</em><em>L</em><sub><em>x</em></sub> = ||<em>Y</em> − <em>A</em><em>X</em>||<sup>2</sup> + <em>λ</em>||<em>W</em><em>X</em>||<sup>2</sup></span><br /></p>
<p>ここで、WXとは何かという疑問が生じます。<br />
XはまぁXなんですが、WXは「これがちっさくなって欲しいな？」というものです。<br />
WがIでも計算は出来るのですが、WがIの場合どうなるかと言うと<br />
「なるべく全てが、平等に正則化されるように」です。<br />
Wは重みとでも言えるもので、Xの振幅の逆数とでも言えるようなものです。<br />
つまり、Xが小さくなってほしいと言うより、<br />
Xの大きい部分は大きく、小さい部分は小さく予測したいのです。<br />
<span class="math inline"><em>W</em><sup><em>T</em></sup><em>W</em></span>の逆数は分散になるような感じです。<br />
詳しくは最小二乗法でググれ。誰かが「重み付き最小二乗法」とかで書いてる。</p>
<p>ここで、<span class="math inline">||<em>X</em>||</span>はXのトレースなのですが、行列の定義をみて計算してみて下さい。<br />
これはきちんと「Xの最小値」を求める式になっています。<br />
<br /><span class="math display"><em>L̂</em> = <em>t</em><em>r</em>((<em>Y</em><sup><em>T</em></sup> − <em>X</em><sup><em>T</em></sup><em>A</em><sup><em>T</em></sup>)(<em>Y</em> − <em>A</em><em>X</em>)) + <em>λ</em><em>t</em><em>r</em>(<em>X</em><sup><em>T</em></sup><em>W</em><sup><em>T</em></sup><em>W</em><em>X</em>)</span><br /><br />
<br /><span class="math display"> = <em>t</em><em>r</em>(<em>Y</em><sup><em>T</em></sup><em>Y</em> − <em>X</em><sup><em>T</em></sup><em>A</em><sup><em>T</em></sup><em>Y</em> − <em>Y</em><sup><em>T</em></sup><em>A</em><em>X</em> + <em>X</em><sup><em>T</em></sup><em>A</em><sup><em>T</em></sup><em>A</em><em>X</em>) + <em>λ</em><em>t</em><em>r</em>(<em>X</em><sup><em>T</em></sup><em>W</em><sup><em>T</em></sup><em>W</em><em>X</em>)</span><br /><br />
ここで、微分します。<br />
<br /><span class="math display">$$\frac{\partial \hat L}{\partial X} = - 2A^TY + 2 A^TAX + 2 \lambda W^TWX= 0$$</span><br /></p>
<p><br /><span class="math display"> − <em>A</em><sup><em>T</em></sup><em>Y</em> + <em>A</em><sup><em>T</em></sup><em>A</em><em>X</em> + <em>λ</em><em>W</em><sup><em>T</em></sup><em>W</em><em>X</em> = 0</span><br /><br />
<br /><span class="math display"><em>X</em> = (<em>A</em><sup><em>T</em></sup><em>A</em> + <em>λ</em><em>W</em><sup><em>T</em></sup><em>W</em>)<sup> − 1</sup><em>A</em><sup><em>T</em></sup><em>Y</em></span><br /><br />
さて、<span class="math inline"><em>W</em><sup><em>T</em></sup><em>W</em></span>は分散の逆数なのですが、<br />
<span class="math inline">(<em>W</em><sup><em>T</em></sup><em>W</em>)<sup> − 1</sup></span>が長いので<span class="math inline"><em>Σ</em></span>って書き換えさせて下さい。<br />
<br /><span class="math display"><em>X</em> = (<em>A</em><sup><em>T</em></sup><em>A</em> + <em>λ</em><em>Σ</em><sup> − 1</sup>)<sup> − 1</sup><em>A</em><sup><em>T</em></sup><em>Y</em></span><br /><br />
出ました！万歳！MNEの式です！だけど、なんだか書いてあるのと違う？</p>
<p>お前は教科書に載っている通りじゃないと満足しない心の狭い人間なのだね？<br />
OK、書き直すわ…<br />
<br /><span class="math display">(<em>A</em><sup><em>T</em></sup><em>A</em> + <em>λ</em><em>Σ</em>)<em>A</em><sup><em>T</em></sup> = <em>Σ</em><em>A</em><sup><em>T</em></sup>(<em>A</em><em>Σ</em><em>A</em><sup><em>T</em></sup> + <em>λ</em><em>I</em>)<sup> − 1</sup></span><br /><br />
上の式をじっと見て下さい。成立することが解ると思います。<br />
故に、こうなります。</p>
<p><br /><span class="math display"><em>X</em> = <em>Σ</em><em>A</em><sup><em>T</em></sup>(<em>A</em><em>Σ</em><em>A</em><sup><em>T</em></sup> + <em>λ</em><em>I</em>)<sup> − 1</sup><em>Y</em></span><br /><br />
これやこの、MNEの式です。<br />
だけど、まだ<span class="math inline"><em>λ</em><em>I</em></span>が怪しいですね？ここで、はじめの式を見て下さい。<br />
<br /><span class="math display"><em>a</em><em>r</em><em>g</em><em>m</em><em>i</em><em>n</em><em>L</em><sub><em>x</em></sub> = ||<em>Y</em> − <em>A</em><em>X</em>||<sup>2</sup> + <em>λ</em>||<em>W</em><em>X</em>||<sup>2</sup></span><br /><br />
これ、あからさまに第一項がYにまつわるもの、第二項がXにまつわるものですね？<br />
ということは、XにWがあるならYにもそれに相当するものがあって良いはずです。<br />
だから、脳内のノイズの分散共分散行列をCとしてあげます。<br />
…ノイズと言いましたが「背景」と言ったほうがわかりやすいかも知れません。<br />
数学得意な人は「重み付き最小ノルム解」と言います。<br />
数学得意な人は一々強そうな名前言いますよね…。式はこんな感じ。<br />
<br /><span class="math display"><em>a</em><em>r</em><em>g</em><em>m</em><em>i</em><em>n</em><em>L</em><sub><em>x</em></sub> = <em>C</em>||<em>Y</em> − <em>A</em><em>X</em>||<sup>2</sup> + <em>λ</em>||<em>W</em><em>X</em>||<sup>2</sup></span><br /></p>
<p>実際計算するとこうなるようです。<br />
<br /><span class="math display"><em>X</em> = <em>Σ</em><em>A</em><sup><em>T</em></sup>(<em>A</em><em>Σ</em><em>A</em><sup><em>T</em></sup> + <em>C</em>)<sup> − 1</sup><em>Y</em></span><br /><br />
で、この値は正則化されていないわけですから、<br />
グニョングニョンの値になってしまいます。<br />
なので、結局正則化のパラメータ入れるのです…。<br />
(ここは流石にググって)</p>
<p><br /><span class="math display"><em>X</em> = <em>Σ</em><em>A</em><sup><em>T</em></sup>(<em>A</em><em>Σ</em><em>A</em><sup><em>T</em></sup> + <em>λ</em><sup>2</sup><em>C</em>)<sup> − 1</sup><em>Y</em></span><br /><br />
読者の皆さんはつかれましたか？僕も疲れました。</p>
<p>まだ続きます(´・ω・｀)</p>
<h3 id="白色化">白色化</h3>
<p>脳内の各皮質って、それぞれ独立でいて欲しいですよね？<br />
じゃないと、脳内に沢山点々を打った意味がなくなります。<br />
こういう風に、それぞれの相関を打ち消す操作を白色化と言います。<br />
まず、想定されるノイズに関して、分散共分散行列を作ります。</p>
<p>ぐぐｒ…これは、分散を集めた的な行列です。<br />
これの対角成分は波そのものの分散なはずです。<br />
毎回観測される波は同じようなものであるという想定のもとで推定をしたいので、<br />
この分散共分散行列を式に入れ込みます。</p>
<p><br /><span class="math display"><em>Y</em> = <em>A</em><em>C</em><sup>1/2</sup><em>C</em><sup> − 1/2</sup><em>X</em></span><br /><br />
<br /><span class="math display"><em>Â</em><sup>†</sup><em>Y</em> = <em>C</em><sup> − 1/2</sup><em>X</em></span><br /><br />
<br /><span class="math display"><em>Â</em> = <em>A</em><sup>†</sup><em>C</em><sup>1/2</sup></span><br /><br />
の元で計算できる<span class="math inline"><em>A</em><sup>†</sup></span>を<span class="math inline">$\hat {A^\dagger}$</span>とすると<br />
<br /><span class="math display">$$ \hat{A^{\dagger}}C^{1/2}Y = X$$</span><br /><br />
こんなかんじ。<br />
<br /><span class="math display">$$ \hat{A^{\dagger}}C^{1/2} $$</span><br /><br />
<br /><span class="math display"> = <em>Σ</em><em>A</em><sup><em>T</em></sup><em>C</em><sup>1/2</sup>(<em>A</em><em>C</em><sup>1/2</sup><em>Σ</em><em>C</em><sup>1/2</sup><em>A</em><sup><em>T</em></sup> + <em>C</em>)<sup> − 1</sup><em>C</em><sup>1/2</sup></span><br /><br />
<br /><span class="math display"> = <em>Σ</em><em>A</em><sup><em>T</em></sup>(<em>A</em><em>Σ</em><em>A</em><sup><em>T</em></sup> + <em>λ</em><sup>2</sup><em>I</em>)<sup> − 1</sup><em>Y</em></span><br /><br />
せっかくここまでCを入れてたのに脱力感半端ないっすね。<br />
まぁ、実際の式ではCを掛け算したりはしますが、逆行列からは外れます。</p>
<h3 id="map推定">MAP推定</h3>
<p>今回はラグランジュの未定乗数法で二乗したやり方を書きましたが、<br />
ここまででも書きましたが、ベイズ統計学の視点からの見方もあります。<br />
しかし、ここまで書いて疲れました。これはここに書くのが超絶面倒いので書きません。</p>
<p>これの解説だけで本が一冊書けます。ぷるむるでも読めば良いんじゃないかな？</p>
<h3 id="dspmの理屈">dSPMの理屈</h3>
<p>さて…MNEの式をよく眺めてみましょう。これは<br />
<br /><span class="math display"><em>Y</em> = <em>A</em><em>X</em></span><br /><br />
の変形であり、シンプルな掛け算なのは言うまでもありません。<br />
そこで、MNEの式を次のように書き直してみます。<br />
<br /><span class="math display"><em>X</em> = <em>A</em><sup>†</sup><em>Y</em></span><br /></p>
<p>ここで、ふとした疑問が出てきます。<br />
<span class="math inline"><em>A</em><sup>†</sup></span>の分散が1じゃない場合に奇妙なことが起こります。<br />
<span class="math inline"><em>A</em><sup>†</sup></span>が1じゃない場合で、空室を撮ったと仮定してみて下さい。<br />
センサーが捉えるノイズと空室の分散は同じ大きさのはずですが、<br />
<span class="math inline"><em>A</em><sup>†</sup></span>が1じゃなかったら空室の中のノイズが<br />
大きくなったり小さくなったりしておかしいですね？？？<br />
脳が存在しない場合でも、脳があるはずの所に何かが生じてしまう。</p>
<p>ということで、計算結果を補正してあげる必要があります。<br />
通常、補正の方法は分散の1/2乗で割り算してあげる事によって為します。<br />
分散って言うと、振幅の二乗ですから、つまり振幅で割ってる的なことです。<br />
それぞれのソースを、そのソースの振幅で割り算してあげるのです。</p>
<p>振幅で割るってどうするのかって？<br />
対角成分で割り算してあげるのです。</p>
<p>答えを分散で割るとき、その方法が有名所が2つあります。<br />
一つの方法は下記です。</p>
<p><br /><span class="math display"><em>Y</em> = <em>A</em><em>X</em></span><br /><br />
<br /><span class="math display"><em>A</em><sup>†</sup><em>Y</em> = <em>X</em></span><br /><br />
この<span class="math inline"><em>A</em><sup>†</sup></span>を補正してあげるのですが、ソースの振幅を出さねばなりません。<br />
センサーの振幅は分散の1/2乗なので<span class="math inline"><em>C</em><sup>1/2</sup></span>とします。<br />
そこで、ソースの対角成分を考えます。Yの誤差をyとしておきましょう。<br />
CはYの分散、即ちyの二乗に比例します。<br />
そして、縦横ともにYのチャンネル数に等しいです。<br />
<span class="math inline">||<em>A</em><sup>†</sup><em>y</em>||</span>の大きさ的な物で割り算したいんですよね？<br />
なら、チャンネル数じゃなくてyのソース数分の大きさの行列にするべきです。<br />
<span class="math inline"><em>A</em><sup>†</sup></span>は縦がチャンネル数、横がソース数の行列になるはずです。<br />
その、縦横を考慮して、ソースを割り算できる行列を作るなら、<br />
<span class="math inline">||<em>A</em><sup>†</sup><em>y</em>(<em>y</em><em>A</em><sup>†</sup>)<sup><em>T</em></sup>||</span> と言う感じの形になるはずです。</p>
<p>つまり<br />
<br /><span class="math display">$$\sqrt{||A^\dagger C(A^\dagger)^T||^2} $$</span><br /><br />
となります。これで割るわけです。だから、こうなります。</p>
<p><br /><span class="math display"><em>X</em> = ||<em>A</em><sup>†</sup><em>C</em>(<em>A</em><sup>†</sup>)<sup><em>T</em></sup>||<sup> − 1/2</sup><em>A</em><sup>†</sup><em>Y</em></span><br /><br />
これぞ、dSPMです！</p>
<h3 id="sloretaの理屈">sLORETAの理屈</h3>
<p>ソースの分散を別の方法で計算してみます。<br />
<br /><span class="math display">$$\sqrt{||X^TX||} \Rightarrow \sqrt{||Y^TA\dagger X||} = \sqrt{||Y^TA^\dagger AY||}$$</span><br /><br />
つまり、推定された世界ではXの分散は<span class="math inline">||<em>A</em><sup>†</sup><em>A</em>||</span>倍になっているということです。<br />
じゃ、それで割ればいいということになりますね。</p>
<p><br /><span class="math display"><em>X</em> = ||<em>A</em><sup>†</sup><em>A</em>||<sup> − 1/2</sup><em>A</em><sup>†</sup><em>Y</em></span><br /><br />
はい、sLORETAです。</p>
<h3 id="eloretaの理屈">eLORETAの理屈</h3>
<p>もうほんとに疲れてきましたが、ここが最後かな…。</p>
<p>sLORETAは<span class="math inline"><em>A</em><sup>†</sup><em>A</em></span>で割り算していました。<br />
だけど、本当に<span class="math inline"><em>A</em><sup>†</sup><em>A</em></span>でいいん？という問題があります。<br />
実はこれ、もっとよく出来るよ！というのがeLORETAです。<br />
やることは、上記を再帰的にしたものです。</p>
<p>発想としては、この式の<span class="math inline"><em>Σ</em></span>ってどうよ？ってことです。<br />
sLORETAによると<span class="math inline">||<em>A</em><sup>†</sup><em>A</em>||</span>がソースの分散でした。まずは<br />
<br /><span class="math display"><em>X</em> = <em>Σ</em><em>A</em><sup><em>T</em></sup>(<em>A</em><em>Σ</em><em>A</em><sup><em>T</em></sup> + <em>λ</em><sup>2</sup><em>I</em>)<sup> − 1</sup><em>Y</em></span><br /><br />
この式の内容から考えていきます。<br />
sLORETAで想定される分散はこうなります。<br />
<br /><span class="math display"><em>Σ</em><em>A</em><sup><em>T</em></sup>(<em>A</em><em>Σ</em><em>A</em><sup><em>T</em></sup> + <em>λ</em><sup>2</sup><em>I</em>)<sup> − 1</sup><em>A</em></span><br /><br />
<span class="math inline"><em>Σ</em></span>はソースの分散ですね。<br />
で、<span class="math inline">||<em>A</em><sup>†</sup><em>A</em>||</span>もソースの分散みたいなものです。<br />
つまり、下記の等式が成立して欲しい。</p>
<p><br /><span class="math display"><em>A</em><sup><em>T</em></sup>(<em>A</em><em>Σ</em><em>A</em><sup><em>T</em></sup> + <em>λ</em><sup>2</sup><em>C</em>)<sup> − 1</sup><em>A</em> = <em>Σ</em><sup>2</sup></span><br /><br />
<br /><span class="math display">$$\sqrt{A^T(A\Sigma A^T + \lambda ^2 C)^{-1}A} = \Sigma$$</span><br /><br />
この<span class="math inline"><em>Σ</em></span>を収束させるために、繰り返し上記の式を再帰的に計算してきます。</p>
<ol type="1">
<li>まず、<span class="math inline"><em>Σ</em></span>を計算します。一寸ズレてます。</li>
<li>次に、 <span class="math inline">$\sqrt{A^T(A\Sigma A^T + \lambda ^2 C)^{-1}A}$</span>を計算します。</li>
<li>2を新しい<span class="math inline"><em>Σ</em></span>として、以下無限ループ。</li>
</ol>
<p>はい、eLORETAです。一応、eLORETAって探索的に場所を特定していくのに向いているらしいっす。<a href="#fn69" class="footnote-ref" id="fnref69"><sup>69</sup></a></p>
<h3 id="eloretaの実行">eLORETAの実行</h3>
<p>さて、MNEpythonで行う時は、いくらかパラメータを入れる必要があります。<br />
一つはCを決める時のパラメータ、<span class="math inline"><em>ϵ</em></span>です。<br />
MNEは<span class="math inline"><em>I</em></span>に分散を掛け算することでCを求めるらしいのですが、<br />
<span class="math inline"><em>ϵ</em></span>も掛け算します。これにより、どの程度正則化するかが決まるようです。<br />
正則化項のコントロール目的のパラメータですね！<br />
それから、max_iterというのがあります。<br />
これは、上記の再帰を何回再帰するかです。<br />
そして、force_equalというのがあります。<br />
これは、脳内の電流は三次元ベクトルですから、それをどう扱うかのパラメータです。<br />
これはdefaultでNoneですが、NoneにしているとMNEがよしなにしてくれます。<br />
looseというパラメータがソース推定であります。<br />
これは脳の皮質の電流の方向のズレをどの程度許容するかのパラメータです。</p>
<p>という感じの理解で多分合ってると思うけど、間違ってたらごめん(´・ω・｀)</p>

<h2 id="割り算を極める">割り算を極める➗</h2>
<p>こんにちは。このセクションは一つ前のセクションで、<br />
言っていることが何も分からなかった友達に特別支援をするための所です。<br />
君たちが分からなかったのは何かな？<br />
君たちが分からなかったのは割り算だ！というわけで…</p>
<p>今回は <del>多変量解析</del> <del>一般線形モデル</del> <del>古典的機械学習</del><br />
<strong>割り算</strong>の話をします。</p>
<p>早速ですが、割り算とは、例えば下記の式です。</p>
<p><br /><span class="math display">$$ \frac{10}{2} = 5 $$</span><br /></p>
<p>逆元(1/X)を掛けることと等価です。</p>
<p><br /><span class="math display">$$10 \times \frac{1}{2} = 5$$</span><br /></p>
<p>何の変哲もない割り算ですが、これを極めると、<br />
様々な応用が効くようになります。(多変量解析・逆問題)<br />
例えば、鶴亀算は紛れもなく割り算なのであります。</p>
<h3 id="鶴亀算とは連立一次方程式である">鶴亀算とは連立一次方程式である🐦🐢</h3>
<p>鶴亀算とはこの様な問題です🐦🐢</p>
<blockquote>
<p>鶴と亀の脚の本数の合計は10、個体数を4とします。<br />
鶴と亀はそれぞれ何匹ずつ居るでしょうか？</p>
</blockquote>
<p>この問題は、小学校中学年がよく悩む問題です。<a href="#fn70" class="footnote-ref" id="fnref70"><sup>70</sup></a><br />
そして、実は簡単な連立方程式で表わせます。鶴をx匹、亀をy匹とすると以下のとおりです。<a href="#fn71" class="footnote-ref" id="fnref71"><sup>71</sup></a></p>
<p><span class="math inline">2<em>x</em> + 4<em>y</em> = 10</span><br />
<span class="math inline"><em>x</em> + <em>y</em> = 4</span></p>
<p>上が足の数、下が躰の数です。</p>

<h3 id="連立一次方程式とは行列の割り算である">連立一次方程式とは行列の割り算である➗</h3>
<p>上記の2つの式ですが、この様に変形できます。<br />
(ここで、仮に足の数を本、体の数を体の単位で表してみます)<br />
<br /><span class="math display">$$ \left(\begin{array}{rr} 2本 &amp; 4本 \\\
 1体 &amp; 1体  \end{array}\right) 
\left(\begin{array}{r} x匹 \\\
 y匹 \end{array}\right) = 
\left(\begin{array}{r} 10本 \\\
 4体 \end{array}\right)$$</span><br /></p>
<p>横から縦に掛けるからそうなるのは実際に計算すれば分かると思います。</p>
<h3 id="鶴亀算の高級な解き方">鶴亀算の高級な解き方🚗</h3>
<p>小学生には小学生なりの解き方がありますが、応用を利かすために大学生らしい解き方をします。<br />
鶴亀算の式が上記のように行列で表現できるならば、逆行列を使うことで解を得られます。<br />
ここで、上記の式を以下のように表してみます。</p>
<p><br /><span class="math display">$$A= \left(\begin{array}{rr} 2本 &amp; 4本 \\\
 1体 &amp; 1体  \end{array}\right) $$</span><br /></p>
<p><br /><span class="math display">$$X= \left(\begin{array}{r} x匹 \\\
 y匹 \end{array}\right) $$</span><br /></p>
<p><br /><span class="math display">$$Y=\left(\begin{array}{r} 10本 \\\
 4体 \end{array}\right)$$</span><br /></p>
<p><br /><span class="math display"><em>A</em><em>X</em> = <em>Y</em></span><br /><br />
逆行列を用いて<br />
<br /><span class="math display"><em>X</em> = <em>A</em><sup> − 1</sup><em>Y</em></span><br /></p>
<p>これでXを計算できます。なんと、鶴亀算とは行列の割り算のことでした🐢<br />
ちなみに、これは鶴てんとう虫算とか亀てんとう虫算とかも成立するのですが、<br />
蛇鶴算とか亀猫算は成立しません😺０本足や足の数が同じお友達が入ると難しいのですね🐍<br />
このやり方なら、方程式をコンピュータに自動的に解かせる事が出来ます。</p>
<h3 id="実装python">実装(python🐍)</h3>
<p>では逆行列を作りましょう!今回はプログラミング言語python🐍のnumpyパッケージを使います。<br />
まずは、pythonで割り算のパッケージに、上の行列を入れ込みます。(足と体の数は適当)</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb191-1" title="1"><span class="im">from</span> numpy <span class="im">import</span> linalg, array</a>
<a class="sourceLine" id="cb191-2" title="2">A <span class="op">=</span> [[<span class="dv">2</span>, <span class="dv">4</span>], [<span class="dv">1</span>, <span class="dv">1</span>]]  <span class="co"># それぞれ足と首の数</span></a>
<a class="sourceLine" id="cb191-3" title="3">At <span class="op">=</span> linalg.inv(A)  <span class="co"># 逆行列</span></a>
<a class="sourceLine" id="cb191-4" title="4">Y <span class="op">=</span> array([<span class="dv">10</span>, <span class="dv">3</span>])  <span class="co"># 足が10本、首が3本</span></a></code></pre></div>
<p>逆行列(<span class="math inline"><em>A</em><sup> − 1</sup></span>)が出来たので、あとは「逆元を掛ける」と解が出ます。</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb192-1" title="1">At <span class="op">@</span> Y  <span class="co"># 逆行列の掛け算</span></a>
<a class="sourceLine" id="cb192-2" title="2"><span class="op">&gt;&gt;&gt;</span> array([<span class="fl">1.</span>, <span class="fl">2.</span>])</a></code></pre></div>
<p>答えは鶴1匹と亀2匹ですね。(ここまでが高校数学の範囲)</p>
<h3 id="鶴亀てんとう虫算">鶴亀てんとう虫算🐤🐢🐞</h3>
<p>鶴亀算が出来たので、次は鶴亀てんとう虫算をやってみましょう。<br />
項目を増やしていけば「鶴亀てんとう虫蜘蛛ムカデ」算が出来るようになり、<br />
非常に応用の幅が広がりそうです。(大学数学の範囲)🐤🐢🐞🐜🐛</p>
<p>さて、鶴亀てんとう虫算は下記のような形をしているはずです。<br />
(もういいかなと思うので単位は省略します)</p>
<p><br /><span class="math display">$$ \left(\begin{array}{rrr} 2 &amp; 4 &amp; 6\\\
 1 &amp; 1 &amp; 1 \end{array}\right) 
\left(\begin{array}{r} x \\\
 y  \\\
 z \end{array}\right)= 
\left(\begin{array}{r} a \\\
 b \end{array}\right)$$</span><br /></p>
<h3 id="無限個の解とその解決策">無限個の解とその解決策∞</h3>
<p>実は、鶴亀てんとう虫算は小学校中学校の正攻法では解くことが出来ません。<br />
亀が増えても減っても鶴とてんとう虫で調整できてしまうから、 答えが一つに決まらないのです。<a href="#fn72" class="footnote-ref" id="fnref72"><sup>72</sup></a></p>
<p>では、どういう条件なら解があるのでしょうか？<br />
鶴、亀、てんとう虫と、三種類の動物の数を調べるなら、<br />
足と首の数だけじゃ決まりません。3つの解には3つの式が必要なのです。</p>
<p>鶴亀てんとう虫算にはもう一つの値、羽の数が必要だったのですね🐞<br />
では、それでやってみましょう！<a href="#fn73" class="footnote-ref" id="fnref73"><sup>73</sup></a></p>
<p><br /><span class="math display">$$ \left(\begin{array}{rrr} 2 &amp; 4 &amp; 6\\\
 1 &amp; 1 &amp; 1\\\
 2 &amp; 0 &amp; 4\end{array}\right) 
\left(\begin{array}{r} x \\\
 y  \\\
 z \end{array}\right)= 
\left(\begin{array}{r} a \\\
 b \\\
 c \end{array}\right)$$</span><br /></p>
<div class="sourceCode" id="cb193"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb193-1" title="1"><span class="im">from</span> numpy <span class="im">import</span> linalg, array</a>
<a class="sourceLine" id="cb193-2" title="2">A <span class="op">=</span> array([[<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>], [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], [<span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">4</span>]])</a>
<a class="sourceLine" id="cb193-3" title="3">At <span class="op">=</span> linalg.inv(A)</a>
<a class="sourceLine" id="cb193-4" title="4">Y <span class="op">=</span> array([<span class="dv">10</span>, <span class="dv">4</span>, <span class="dv">6</span>])</a>
<a class="sourceLine" id="cb193-5" title="5">At <span class="op">@</span> Y</a>
<a class="sourceLine" id="cb193-6" title="6"></a>
<a class="sourceLine" id="cb193-7" title="7"><span class="op">&gt;&gt;&gt;</span> array([ <span class="fl">3.</span>, <span class="fl">1.</span>,  <span class="fl">0.</span>])</a></code></pre></div>
<p>計算できました。</p>
<h3 id="逆行列は作れないこともある">逆行列は作れないこともある🐍</h3>
<p>適当にさっきの行列を弄ってみましょう。</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb194-1" title="1"><span class="im">from</span> numpy <span class="im">import</span> linalg, array</a>
<a class="sourceLine" id="cb194-2" title="2">A <span class="op">=</span> array([[<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>], [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">4</span>]])</a>
<a class="sourceLine" id="cb194-3" title="3">At <span class="op">=</span> linalg.inv(A)</a>
<a class="sourceLine" id="cb194-4" title="4"><span class="op">&gt;&gt;&gt;</span> LinAlgError: Singular matrix</a></code></pre></div>
<p>エラーが出ました！💀この行列では逆行列は作れないのでした！こういうこともあります。<br />
うまくいくかどうかの条件はありますが、今回は難しい数学はしません。<a href="#fn74" class="footnote-ref" id="fnref74"><sup>74</sup></a></p>

<h3 id="疑似逆行列">疑似逆行列👻</h3>
<p>足の数と首の数しか無いときは、答えがないので推定するしかありません。<br />
よく使われる方法は<span class="math inline"><em>X</em></span>のL2ノルム<a href="#fn75" class="footnote-ref" id="fnref75"><sup>75</sup></a>が最も小さくなる解を仮の解とする方法です。<br />
無理やり上記の<span class="math inline"><em>A</em><em>X</em> = <em>Y</em></span>を<span class="math inline"><em>X</em> = <em>A</em><sup>†</sup><em>Y</em></span>の形にしてしまいます。<br />
これは疑似逆行列と言います。<a href="#fn76" class="footnote-ref" id="fnref76"><sup>76</sup></a>便利ですね！では実装してみます。</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb195-1" title="1"><span class="im">from</span> numpy <span class="im">import</span> linalg, array</a>
<a class="sourceLine" id="cb195-2" title="2">A <span class="op">=</span> [[<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>], [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>]]  <span class="co"># 足と首の数</span></a>
<a class="sourceLine" id="cb195-3" title="3">At <span class="op">=</span> linalg.pinv(A)  <span class="co"># 擬似逆行列</span></a>
<a class="sourceLine" id="cb195-4" title="4">Y <span class="op">=</span> array([<span class="dv">10</span>, <span class="dv">3</span>])  <span class="co"># 足10本と首3本</span></a>
<a class="sourceLine" id="cb195-5" title="5">At <span class="op">@</span> Y  <span class="co"># 擬似逆行列の掛け算</span></a>
<a class="sourceLine" id="cb195-6" title="6"></a>
<a class="sourceLine" id="cb195-7" title="7"><span class="op">&gt;&gt;&gt;</span> array([<span class="fl">1.5</span>, <span class="fl">1.</span> , <span class="fl">0.5</span>])</a></code></pre></div>
<p>適当に数を決めたら少数が出てきました👻<br />
この割り算は、実は色々なパターンがあるのですが、<br />
代表的なパターンとしては、例えば下記があります。<br />
<br /><span class="math display"><em>X</em> = (<em>A</em><sup><em>T</em></sup><em>A</em>)<sup> − 1</sup><em>A</em><sup><em>T</em></sup><em>Y</em></span><br /></p>
<h2 id="ここまでで学んだ割り算の応用">ここまでで学んだ割り算の応用✏</h2>
<ul>
<li>花の色や大きさから花の種類を推定する(アヤメ分類問題)</li>
<li>fMRIや脳波・脳磁計による脳内活動の推定(SPM/MNE)</li>
<li>多変量解析を用いた研究</li>
<li>以下、無限の応用…</li>
</ul>
<p>カーネル法(極めて強烈な掛け算。本が一冊かける。)を応用すれば、<br />
なんと無限次連立方程式すら解くことが可能！<a href="#fn77" class="footnote-ref" id="fnref77"><sup>77</sup></a></p>

<h3 id="具体的な応用-多変量解析入門">具体的な応用 多変量解析入門</h3>
<p>では、多変量解析に入門してみましょう！しかし、最早入門も終わったも同然です。<br />
ある集団の平均寿命をY(89, 67, 54, 94, 75…)とします。<br />
一人ひとりの飲酒量A1(1, 2, 4, 0, 0…)<br />
一人ひとりの喫煙量A2(0, 10, 20, 0, 10…)<br />
一人ひとりの1日の歩数A3(4000, 7000, 1500, 2000, 3000…)<br />
として集め、(A1, A2, A3)とし、一寸変形します。(転置)<br />
そして、それぞれの生命予後への寄与率をX(a, b, c)とし、式にします。<a href="#fn78" class="footnote-ref" id="fnref78"><sup>78</sup></a><br />
最後に、それぞれの計算でどうしても出てくる誤差をEとします。</p>
<p><br /><span class="math display">$$ \left(\begin{array}{rrr}
1 &amp; 0  &amp; 4000\\\
2 &amp; 10 &amp; 7000\\\
4 &amp; 20 &amp; 1500\\\
0 &amp; 0  &amp; 2000\\\
0 &amp; 10 &amp; 3000 \end{array}\right) 
\left(\begin{array}{r} a\\\
 b\\\
 c\end{array}\right)= 
\left(\begin{array}{r}
89\\\
67\\\
54\\\
94\\\
75\end{array}\right) + E$$</span><br /><br />
<br /><span class="math display"><em>A</em><em>X</em> = <em>Y</em> + <em>E</em></span><br /><br />
ここで、計算の誤差を最小にするXを考えます。<br />
具体的にはEの絶対値が一番小さい時が都合いいです。<br />
<br /><span class="math display">|<em>A</em><em>X</em> − <em>Y</em>| = |<em>E</em>|</span><br /><br />
つまりEが0に近い時<a href="#fn79" class="footnote-ref" id="fnref79"><sup>79</sup></a>こそがXの最適解なので、下記に近似させればいいです。<br />
<br /><span class="math display"><em>A</em><em>X</em> − <em>Y</em> = 0</span><br /></p>
<p>なんと！あからさまに割り算です。なので、コンピュータに解かせられます。<br />
実際は微妙に違うのですが、大まかな理解の一歩としては遠くないはずです。<a href="#fn80" class="footnote-ref" id="fnref80"><sup>80</sup></a></p>

<h3 id="まとめ">まとめ</h3>
<ul>
<li>鶴亀算(連立方程式の一種)とは他ならぬ割り算であった</li>
<li>割り算はコンピュータで解くことが出来る</li>
<li>割り算を応用することで様々なことが分かる(医学への応用も多数)</li>
</ul>
<h3 id="さいごに">さいごに</h3>
<p>君がしている割り算…それを圧倒的に高めたものがeLORETA。</p>

<h1 id="補講">補講</h1>
<p>ここではちょっとした小技、オススメ書籍などを紹介します。</p>
<h2 id="pythonでの高速化のあれこれ">pythonでの高速化のあれこれ</h2>
<p>MNEpythonを使う場合、並列化以外の高速化はあまり考えないでいいです。<br />
理由は、numpyを使っているので十分速いと思われるからです。<br />
しかし、独自のメソッドを実装する時なんかに、処理速度が大事になる事もあります。<br />
その時のやり方をいくつか記しておきます。</p>
<h3 id="for文とリスト内包表記とmap">for文とリスト内包表記とmap</h3>
<p>pythonのfor文は絶望的に遅いため、for文の入れ子はやめましょう…と言われています。<br />
MNE使うときには大差ないし良いんじゃないかと個人的には思いますが。<br />
しかし、ここの所は今後の高速化を学ぶための布石になります。</p>
<p>forの代わりと言ってはアレですが、いくつか良いpython構文があります。</p>
<pre data-frame="single"><code>n = [i + 4 for i in range(5)]</code></pre>
<p>この場合、[4, 5, 6, 7, 8]が帰ってきます。<br />
この書き方はリスト内包表記と言い、広く使われています。詳しくはググってください。</p>
<p>他にmapという関数があります。これも速いです。上と同じ内容をmapで書いてみます。</p>
<pre data-frame="single"><code>def plus4(num: int) -&gt; int:
    return num + 4

n = list(map(plus4, range(5))</code></pre>
<p>どっちが良いとかは特にありません…</p>
<p>一々defで名前付きのを書きたくないならlambda式というので一行で出来ます。<br />
pythonのlambda式、読みにくくて嫌われてるけどね。</p>
<pre data-frame="single"><code>n = list(map(lambda x: x + 4, range(5))</code></pre>
<h3 id="numpy独自のメソッドを実装するときとか">numpy(独自のメソッドを実装するときとか)</h3>
<p>numpyは速いので、重い演算の時は使えるなら使いましょう。<br />
上記のリスト内包とかmapなんかよりnumpyの方が圧倒的に速いです。</p>
<h3 id="並列化これがやりたかった">並列化(これがやりたかった！)</h3>
<p>これ、大事！pythonでの並列化はとても簡単です。<br />
やり方は色々ありますが、Poolというのがお手軽並列化ツールです。</p>
<pre data-frame="single"><code>from multiprocessing import Pool</code></pre>
<p>使い方は、pythonのmap関数に近いものですので、並列化する時は必ず何か関数を定義して下さい。<br />
(ちなみに、poolのmapはlambda式を食べることが出来ません)</p>
<div class="sourceCode" id="cb200" data-frame="single"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb200-1" title="1"><span class="kw">def</span> test(i):</a>
<a class="sourceLine" id="cb200-2" title="2">    <span class="cf">return</span> i <span class="op">*</span> <span class="dv">8</span></a></code></pre></div>
<p>これをwith文を使ってPoolの中にぶちこみます。</p>
<pre data-frame="single"><code>with Pool(4) as pool:
  result = pool.map(test, [1, 2, 3, 4])
print(result)</code></pre>
<p>ね、簡単でしょ？<br />
これ、testという関数が脳波を解析する関数だったら複数人の<br />
脳波解析を同時進行できて爆速です！<br />
(一人分をマルチプロセスするとメモリの取り合いが生じて遅くなる)</p>
<p>ここではmap_asyncという関数を使う方法もあります。<br />
map_asyncはmapよりも頭の良い並列化関数です。<br />
mapは全員一斉にやる感じ、map_asyncは全員でやるけれど、<br />
終わった人は次の課題をし始める感じです。</p>
<pre data-frame="single"><code>with Pool(4) as p:
  result = p.map(test, [1, 2, 3, 4]).get()
print(result)</code></pre>
<p>mapとの違いは、p.map_async(hoge).get()というふうにgetしてあげないと結果が得られないことです。</p>
<p>さて、mapもmap_asyncも今の所引数が1つのものじゃないと無理です。<br />
複数ある場合は、starmapというのがあります。<br />
とりあえず、starmapもstarmap_asyncもあるけど、asyncで書いてみます。</p>
<pre data-frame="single"><code>from multiprocessing import Pool

def test(x, y): return x + y

with Pool(4) as p:
    result=p.map_async(test, [(1, 2), (4, 6)]).get()
print(result)</code></pre>
<p>良いですね！これで君のpythonはコア数に比例するスピードを得たのであります。<a href="#fn81" class="footnote-ref" id="fnref81"><sup>81</sup></a></p>
<h3 id="openmpのオーバーヘッド対策">OPENMPのオーバーヘッド対策</h3>
<p>並列化にも色々あります。numpy内部でも並列化がされているのですが、<br />
並列化自体のオーバーヘッドもあります。numpyで並列化出来ない部分は多いです。<br />
上記のやり方で手動で並列化する場合、<br />
numpy内部で並列化しないほうが速い状況もあるでしょう。<br />
だから、マルチスレッドを切っておく方法を書きます。</p>
<p>bashrcに以下のように書くか</p>
<pre data-frame="single"><code>export OMP_NUM_THREADS=1</code></pre>
<p>pythonで以下のように書くかです。</p>
<pre data-frame="single"><code>from os import environ
environ[&#39;OMP_NUM_THREADS&#39;] = str(1)</code></pre>
<h3 id="mnepythonの並列化">MNEpythonの並列化</h3>
<p>MNEpythonは並列計算に対応しています。凄いですね！<br />
実は、MNEpythonの内部の並列化はもっと別のjoblibという仕組みで動いています。<br />
ですが、MNEpythonは全てを並列化することは出来ません。<br />
例えばmaxwellfilterは並列化されないのです。<br />
それに、大きな行列をわざわざ分割して並列化しているので、<br />
並列化自体にコストがかかります。<br />
並列化したら遅くなることすらあります。駄目じゃん！<br />
複数の人についてガン回しする時は多分、自分で並列化したほうが速いです。<br />
つまり、僕としてはpythonのネイティブな並列化のPool().mapがオススメです。</p>

<h3 id="graph">graph</h3>
<p>グラフ理論をご存知でしょうか？グラフ理論はあれです、ネットワーク図から、<br />
何らかの指標を抜き出してくるアルゴリズム群みたいなものです。<br />
ほら、全脳解析でコネクティビティが出るじゃないですか。<br />
それを数値化してくれる便利なやつです。<br />
(僕の中ではその程度の認識。ただし、多分あってる。)</p>
<p>pythonでgraph理論でなにかやりたい場合はこうです。</p>
<pre data-frame="single"><code>pip install bctpy</code></pre>
<p>これでbctpyがインストールされました。<br />
公式サイトはこれです。<br />
https://github.com/aestrivex/bctpy<br />
コネクティビティの結果である三角行列を突っ込みたいですね。<br />
突っ込みます。</p>
<pre data-frame="single"><code>import bct</code></pre>
<p>例えばconmatというnumpy三角行列があったとして、こいつを放り込むなら<br />
まずは三角行列を普通の行列にしてやるべきでしょう。<br />
(方向ありの行列なら三角行列にはならないのでそのままでいいです)</p>
<pre data-frame="single"><code>dcon = conmat + conmat.T</code></pre>
<p>global efficiencyを重み付けありで計算したいならこうと思います。</p>
<pre data-frame="single"><code>bct.efficiency_wei(dcon)</code></pre>
<p>すると、スカラー値が算出されます。そう、グラフ理論ってのは、基本<br />
「このネットワークを表すスカラー値を出す」的なやつですよ。<br />
中には、閾値を設けて「これ以上の繋がり具合なら繋がってる」とみなして<br />
計算するやつとかもあります、というかそういうのが主じゃないかな？<br />
この記事見て色々遊んでもいいかもですね。<br />
https://qiita.com/maskot1977/items/e1819b7a1053eb9f7d61</p>

<h2 id="おすすめの参考書">おすすめの参考書</h2>
<p>ステルスマーケティングです。</p>
<ul>
<li><p>Analyzing Neural Time Series Data:Theory and Practice<br />
表題見て分かる通り、洋書ですが名著です。英語ですが平易に書かれています。<br />
amazonでも売ってます。どうすれば良いのかわからなくなった時の道標です。<br />
MNE-Pythonはどうすれば良いのか分からなくなる事が多いのです。<br />
買って下さい。</p></li>
<li><p>事象関連電位―事象関連電位と神経情報科学の発展<br />
脳波関連の和書の名著です。なのですが、絶版です。古本を見つけたらすかさず買いましょう。<br />
内容的には凄く難しい数学はなく、実践的です。<br />
通読向けではありますが、やはり手を動かしながらじゃないときついです。</p></li>
<li><p>意味がわかる線形代数<br />
これは異色の本です。多くの線形代数の本は文系や医学生には<br />
冥王星語でも読んでいるように感じるのですが、<br />
これは日本語で書いてあります。意味がわかります！<br />
反面、内容は「分かっている人」からすると薄いでしょう。</p></li>
<li><p>統計的信号処理 信号・ノイズ・推定を理解する<br />
MNEって行列代数なのです。算数の基礎がわかってないと分かりません。<br />
でも、基礎がわかっててもわからない本が普通にあるので悲しい。<br />
この本は基礎がわかったら何とか読めます。凄く親切に書いてある名著です。<br />
アホでも読める感じがしました。買いましょう。(理解できるかは別)</p></li>
<li><p>完全独習ベイズ統計学<br />
ベイズ統計学に関して直感的に分かる本です。<br />
この本は上記「意味がわかる線形代数」と同様、<br />
冥王星語を関西弁くらいまで下ろしてくれます。<br />
やはり入門書はざっくりしたものが一番です。</p></li>
<li><p>Electromagnetic Brain Imaging: A Bayesian Perspective 2015<br />
割りと平易な英語で書いてある応用数学の本です。<br />
MNE, beamformer, dSPM, sLORETA等が載っていて重宝します。<br />
内容は結構噛み砕いてくれていますが、元が僕にとっては難しいものなので大変でした。<br />
算数を理解したいなら買って下さい。</p></li>
<li><p>ゼロから作る　DeepLearning<br />
コラム4参照。ニューラルネットワーク系人工知能本の名著です。<br />
機械学習に興味がお有りなら買ってください。<br />
MNEには役立ちません！<br />
基礎を学ぶには本当に良いです。その後はpytorchだとかtensorflowだとか<br />
触れば良いんじゃないですかね？</p></li>
<li><p>パターン認識と機械学習(上下)<br />
通称ぷるむる。<br />
難しくてとてもつらいですが、機械学習方面では聖書の一つです。<br />
この領域では機械学習を使うこともあるので、必要になればどうでしょう？</p></li>
<li><p>Wavelet10講<br />
直交Waveletの本です。<br />
Wavelet変換のガチ勢になりたければ読むといいです。<br />
リアルタイム解析の世界への展望が開けるかも知れません。</p></li>
<li><p>MNE同人誌<br />
本書。MNE-pythonに関する、多分世界で唯一の和書。</p></li>
</ul>
<h2 id="おすすめサイト">おすすめサイト</h2>
<p><a href="http://mathtrain.jp">高校数学の美しい物語 http://mathtrain.jp</a><br />
高校数学についてのサイトです。高校数学を復習するにあたって、このサイトは素晴らしい。<br />
フーリエ変換とか行列計算とか複素数とか、そういったことを考える時に<br />
辞書みたいにつかってみては如何でしょうか？</p>
<p><a href="https://www.slideshare.net/ryosuketachibana12/ss-42388444">ウェーブレット変換の基礎と応用事例：連続ウェーブレット変換を中心に https://www.slideshare.net/ryosuketachibana12/ss-42388444</a><br />
このウェーブレット変換スライドは素晴らしいです。作者が学生の頃に勉強して作ったのだそうですが、<br />
多くの「分かっている人向けの数学的入門書」と違い、直感的に分かるように書いてあるのです。</p>
<h2 id="おすすめsns">おすすめSNS</h2>
<p><a href="http://qiita.com">qiita http://qiita.com</a><br />
日本のプログラマ用のSNS…というかブログサービスです。<br />
かなり分かりやすい記事が多く、大変重宝します。<br />
反面、コピペプログラマになるのを避ける心がけは大事ですね。<br />
カジュアルな雰囲気漂う気軽なサイトです。</p>
<p><a href="http://twitter.com">twitter http://twitter.com</a><br />
twitterかよ！と思われるかもですが、学者さんのアカウント、雑誌のアカウント<br />
開発者さんのアカウントは極めて有用かつ濃密です。<br />
カジュアルな感じですが、酔っ払って書き込んで炎上させるのには気をつけましょう。</p>
<p><a href="https://github.com">github https://github.com</a><br />
プログラマ用SNSの中でも最も有名なものでしょう。<br />
qiitaはただの記事集ですが、githubは開発ツールです。ただし、学習コストが高いですね。<br />
下記のgitを中心に据えたwebサービスです。<br />
余談ですがマスコットキャラのoctocatが可愛いです。</p>
<h2 id="おすすめソフト">おすすめソフト</h2>
<p>これまで散々色んなソフトを紹介してきましたが、<br />
それ以外のツールも紹介しておきましょう。<br />
当然ながら全てフリーウェアです。</p>
<ul>
<li><p>edfbrowser<br />
edfファイルの変換に使えることがあります。<br />
windows用ですが、コンパイルすればUnix系でも使えます。</p></li>
<li><p>git<br />
バージョン管理ソフトです。プログラム書くときとか、長文書くときとかに<br />
どこをどう修正したのか分からなくなったりしませんか？<br />
また、修正したいけど壊しそうで怖いからコピーとって修正したりしていませんか？<br />
そんな貴方に必要なのはバージョン管理ソフトでしょう。<br />
gitは最も有名なバージョン管理ソフトの一つです。</p></li>
<li><p>pandoc<br />
markdownという形式で書いた文書をあらゆる形式に変換するソフトです。<br />
詳しくはコラム参照。 これの何が嬉しいかというと、markdownで書いたものを<br />
word、LaTeX、PDF、HTML等、あらゆる形式に変換してくれるのです。<br />
つまり、markdownさえかければ、他はいらなかった！<br />
(細かい所の調整はLaTeX書く必要が有ることもありますが…)<br />
何故これを勧めるかって？JupyterやGithubはmarkdownを多用するからだよ。</p></li>
</ul>

<h2 id="mnepython実装時の小技">MNEpython実装時の小技</h2>
<p>一応、実装が苦手な人が読者と思っているので、 ありふれた小技ですが紹介します。<br />
Object指向とか関数型とかは他の本を読んで下さい。得られるものが多いでしょう。</p>
<h3 id="メソッドチェーン">メソッド・チェーン</h3>
<p>今回は超手軽に解析してみましょう！<br />
何度もフィルタ掛けるの面倒くさいから、一気にかけちゃう方法です。<br />
メソッド・チェーンを使います。<br />
メソッド・チェーンとはドットで数珠つなぎに処理をしていく技法です。<br />
MNEpythonではrawオブジェクト辺りで割とできる感じです。実際見てみましょう。</p>
<pre data-frame="single"><code>from mne.io import Raw
Raw(&#39;hoge.fif&#39;).filter(1, 100).notch_filter(60).save(&#39;fuga.fif&#39;)</code></pre>
<p>どんだけ略してんだよ！というくらい略されてますね。<br />
このケースでは、読み込んでフィルタを2つ掛けて保存しています。<br />
まぁ、使いすぎは色々大変になるので良くないです。</p>
<h3 id="変数を減らしてみる">変数を減らしてみる</h3>
<p>rawを弄る時raw.filter関数などを使うとraw自体が書き換わってしまいます。<br />
これ自体は正しい動作なのですが、一寸わかりにくさを感じるかも知れません。<br />
rawはrawとしてどっしり構えてもらって、加工品だけ作って行きたいかも知れません。<br />
そんなときはraw.copy関数がいいです。</p>
<pre data-frame="single"><code>raw2 = raw.copy()
raw3 = raw2.filter(1, 100)
raw4 = raw3.notch_filter(60)</code></pre>
<p>これでrawのcopyが出来ましたね。しかし、どうも変数が多くなります。<br />
raw2, raw3, raw4と作るうちにraw∞とかなって死にます。<br />
それの対策にはメソッドチェーンがいい味を出すと思っています。</p>
<pre data-frame="single"><code>filtered = raw.copy().filter(1, 100).notch_filter(60)</code></pre>
<p>raw2など要らなかった。</p>
<h3 id="mneのapi引数多すぎだろ死ね">MNEのAPI引数多すぎだろ死ね！</h3>
<p>確かにMNEのmethodは引数が多すぎである。<br />
引数が多すぎて毎回引数入れるのがダルいし、ミスも多くなりそうだ。<br />
だが、落ち着いて聞いてほしい。pythonには良い道具があるのだ。</p>
<pre data-frame="single"><code>from functools import partial</code></pre>
<p>こいつは関数を部分的に解いちゃう関数だ。</p>
<p>今君は、複数のepochオブジェクトを作りたいとする。event_idは1､2､3､4､5､6だとする。<br />
その都度入力するのはダルいし、変数が増えすぎると管理も大変だ。そんなときはこのようにすればいい。</p>
<pre data-frame="single"><code>from mne.io import Raw
from mne.epochs import Epochs 
from mne import find_events

raw = Raw(&#39;hoge.fif&#39;, preload=True)
events = find_events(raw)
make_my_epochs = partial(Epochs, raw, events)</code></pre>
<p>これでmake_my_epochsという割と決め打ち的な関数が出来た。以降は例えば</p>
<pre data-frame="single"><code>make_my_epochs(4)</code></pre>
<p>とかでevent_idが4のepochオブジェクトが返る。これで君の怒りが少しでもおさまってくれたら嬉しい。</p>
<h3 id="ここまでのまとめ">ここまでのまとめ</h3>
<p>というわけで、凄く省略すれば、epochingまで下記のように書けるのです。</p>
<pre data-frame="single"><code>from mne.io import Raw
from mne import Epochs
raw = Raw(&#39;hoge&#39;).interpolate_bads().filter(1, 100).notch_filter(60)
make_epochs = partial(Epochs,
                      raw, mne.find_events(raw),
                      tmin=-0.2, tmax=5.0)
epochs = [make_epochs(n) for n in range(1, 7)]</code></pre>
<p>まぁ、ICAとか省いているから本当はもうちょっと長いです。</p>
<h3 id="解析失敗したやつをスキップしたいんだが">解析失敗したやつをスキップしたいんだが</h3>
<p>気持はよく分かる。たまに失敗した実験が紛れてたりするんですよね。<br />
そんな君にはtry文とfilter関数をおすすめしましょう。これにより、だいぶ楽になります。</p>
<h4 id="try文">try文</h4>
<p>やってみて、失敗したらやめるというやつ。</p>
<pre data-frame="single"><code>try:
    raw = Raw(&#39;hoge.fif&#39;)
except FileNotFoundError:
    return None</code></pre>
<p>こんな感じで使います。これで万一どれかで失敗しても処理が止まらない！<br />
エラーの書き方は、まぁ、ググって調べてください。</p>
<h4 id="filter関数">filter関数</h4>
<p>例えば、何らかの理由でepochsを作れなかったrawがあったとします。<br />
(トリガーが入ってなかったとか、色々あると思う)<br />
そんなのが紛れ込んででfor文が動かんくなったら糞面倒くさいです。<br />
ここで、os.pathモジュールのexists関数<a href="#fn82" class="footnote-ref" id="fnref82"><sup>82</sup></a>を<br />
filter関数やlambda式<a href="#fn83" class="footnote-ref" id="fnref83"><sup>83</sup></a>と組み合わせて使うといいです。</p>
<p>filter関数はlistやtupleの中で、条件に合うやつだけを抜き出すものです。<br />
これは高階関数といって、関数を引数に取る関数です。<br />
こんなかんじ。filter(関数, list)<br />
では今回は存在するrawだけを抜き出すという操作をやってみましょう。</p>
<pre data-frame="single"><code>from os.path import exists

file_list = [&#39;hoge&#39;, &#39;fuga&#39;, &#39;piyo&#39;]
fnames = list(filter(exists, file_list))</code></pre>
<p>これで存在するものだけを読み込めます！成功例のみ続けていけますね！<br />
でも、「どれが読み込めたか分からない」って思いましたか？</p>
<p>大丈夫。epochsとかのオブジェクトにはたいていfilename的なメンバー変数が<br />
入っているからそれを参照して下さい。<br />
つまり、こんな感じですね。</p>
<pre data-frame="single"><code>from mne import read_epochs

file = &#39;hoge&#39;
epochs = read_epochs(&#39;file&#39;)
...
print(epochs.filename)
epochs.save(f&#39;modified-{epochs.filename}&#39;)</code></pre>
<p>Rawの場合は連結できたりする関係上、flenamesのようです。</p>
<p>他にmap関数とか、reduce関数も時に有用です。<br />
MNE使う時は割と関数型パラダイムは有効っぽそうです。ただ、気をつけて下さい。<br />
mapとかfilterとかは一度値を取り出すと空っぽになります。<br />
使いまわす場合はlistとかに一々保存したほうが良いでしょうね。</p>
<p>また、上記の方法ではファイルが壊れていた場合に対応できないので、<br />
結局はtry文を使うことになるかと思います。</p>
<h3 id="file名じゃなくてフォルダ名が欲しいん">file名じゃなくてフォルダ名が欲しいん</h3>
<p>概ねこんな感じでゲットできます。</p>
<pre data-frame="single"><code>from pathlib import Path
path = Path(epochs.filename).parent
dirname = str(path)</code></pre>
<p>こういう小技、大事ですよね…いや、工学部の人は良いんだけどさ…</p>

<h1 id="あとがきとお願い">あとがきとお願い</h1>
<h2 id="令和2年2月時点のあとがきだ">令和2年2月時点のあとがきだ</h2>
<p>こんにちは、ニンジャというしがない同人作家です。<br />
この度はこのような分厚い薄い本を読破していただきありがとうございます。<br />
(まぁ、読破はしてないと思うし、その必要もない)<br />
本作は僕の初めての技術系同人誌です。大学院でほぼ独学で頑張った時のメモをベースにしました。<br />
自画自賛しますがマジで力作と思う。ちなみに博士課程5年目ですが博士論文は書けてませんwwwww<br />
まだまだ気が向いたら加筆修正していくつもりで、githubに随時うｐってるので、<br />
「君は古いのを掴まされたんだよ、プギャーwwwwww」と言えなくもない。</p>
<p>この本自体は入門書であり、紹介した機能はごく一部です。もっと色々出来ることがあります。<br />
虎の威を借りますが、MNE-pythonはマジで凄いです。凄いですが、不親切極まりないです。</p>
<p>MNEを使いこなすには修行が必要で、君のMNEライフはこの本を<br />
「は？当たり前のこと書いてんじゃねえよ糞ボケ死ね！<br />
つうか、ここ間違ってるし、作者の脳はチンパンジー以下だな！」<br />
と思うレベルのところから始まるのであります。</p>
<p>出来れば、読者の中の誰かが高名な脳科学者(このワード胡散臭くて好き)になって頂けますと、<br />
一人の落ちこぼれ大学院生が浮かばれます。どうか精進なさってください。</p>
<p>令和2年2月　ニンジャ</p>
<h2 id="令和3年5月時点のあとがきだ">令和3年5月時点のあとがきだ</h2>
<p>この度更新いたしました。致したんですよ?<br />
令和2年の頃の僕は今の僕よりもっとクソザコで、間違いを色々書いていた！<br />
上に書いた通り、チンパンジー以下だと思います。<br />
恥ずかしいです。昔のを持っている人は必ず更新して下さい。<br />
(これを手にしている人は既にしているので無意味土下座)</p>
<p>そんで、僕は今でもクソザコ留年生です。<br />
せめて、読者である君！君が強い脳科学者になるんだよ！<br />
じゃないと浮かばれません。ほんとお願いします。(土下座)</p>
<p>令和3年5月　ニンジャ</p>
<h2 id="令和5年6月時点のあとがき">令和5年6月時点のあとがき</h2>
<p>8年目大学院生のニンジャと名乗るチンパンジーです。<br />
マジ爆発寸前。</p>
<p>この度再改訂致したのは、チンパンジーの本を読んだ人が居たのと、<br />
チンパンジー的に人と情報交換するために必要だったから。<br />
今回、この本を改訂するために見直しましたが、<br />
…やはりチンパンジーが書いた感じではある。<br />
それでもMNE-pythonの為の唯一の和書として本邦の脳科学の<br />
発展に寄与できればうれしいね。</p>
<p>令和5年6月　チンパン・ニンジャ</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Gramfort, M. Luessi, E. Larson, D. Engemann, D. Strohmeier, C. Brodbeck, R. Goj, M. Jas, T. Brooks, L. Parkkonen, M. Hämäläinen, MEG and EEG data analysis with MNE-Python, Frontiers in Neuroscience, Volume 7, 2013, ISSN 1662-453X<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Gramfort, M. Luessi, E. Larson, D. Engemann, D. Strohmeier, C. Brodbeck, L. Parkkonen, M. Hämäläinen, MNE software for processing MEG and EEG data, NeuroImage, Volume 86, 1 February 2014, Pages 446-460, ISSN 1053-8119<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferWiki<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>当初は僕のスキル不足が本書の限界でしたが、MNE-pythonを魔改造しながら使っているくらいなので、流石に自称中級者名乗っていいと思う。MNE-pythonってユーザーのスキルが上がると、自分で魔改造できるんですよ。知ってました？<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>僕は怖いおじさんなのです。<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>日本のプログラマ用のSNSの一つです。<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>脳波は電気信号を捉えますが、脳磁図は磁場を捉えます。電気と違って骨を貫通しやすく拡散しにくいので空間分解能に優れますが、ノイズに弱いです。値段も高いです。http://www.elekta.co.jp/products/functionalmapping.html<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p>動物実験では脳に電極刺す実験はされていますが、人に刺すと警察に捕まります。<a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p>他に脳の活動を調べる方法として磁力を照射するfMRIや赤外線を照射するNIRSなどがあります。fMRIは電気信号ってわけでも無さそうです。NIRSは赤外線で脳血流を捉えるのですが、頭皮の血流をいっぱい拾ってしまうので大変です。<a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p>http://biorxiv.org/content/early/2017/03/29/121764<a href="#fnref10" class="footnote-back">↩</a></p></li>
<li id="fn11"><p>コンピュータ言語の一つ。速度を犠牲にして、読み書きやすさを追求した言語。科学計算の世界では現時点では広く普及しています。MATLABと似ている…とかいう人もいるけど、僕は似てないと思う。無料でオブジェクト指向の汎用言語なので、応用範囲がWebサーバーとか機械の制御にまで及び、習得して損をすることはまずないでしょう。<a href="#fnref11" class="footnote-back">↩</a></p></li>
<li id="fn12"><p>良いところもある…らしいです。使ったことないから分からん。<a href="#fnref12" class="footnote-back">↩</a></p></li>
<li id="fn13"><p>Robert A Sweet, Sarah E Bergen, etal: Pyramidal cell size reduction in schizophrenia: evidence for involvement of auditory feedforward circuits, Biological psychiatry, 55-12:1128–1137,2004<a href="#fnref13" class="footnote-back">↩</a></p></li>
<li id="fn14"><p>Robert A Sweet, Sarah E Bergen, etal: Anatomical evidence of impaired feedforward auditory processing in schizophrenia, Biological Psychiatry, 61-7:854–864,2007<a href="#fnref14" class="footnote-back">↩</a></p></li>
<li id="fn15"><p>Johanna Kissler, Matthias M Muller, etal: MEG gamma band activity in schizophrenia patients and healthy subjects in a mental arithmetic task and at rest, Clinical Neurophysiology, 111-11:2079–2087,2000<a href="#fnref15" class="footnote-back">↩</a></p></li>
<li id="fn16"><p>Kevin M Spencer, Paul G Nestor, etal: Neural synchrony indexes disordered perception and cognition in schizophrenia, Proceedings of the National Academy of Sciences, 101-49:17288–17293,2004<a href="#fnref16" class="footnote-back">↩</a></p></li>
<li id="fn17"><p>Jun Soo Kwon, Brian F O’Donnell, etal: Gamma frequency–range abnormalities to auditory stimulation in schizophrenia, Archives of general psychiatry, 56-11:1001–1005,1999<a href="#fnref17" class="footnote-back">↩</a></p></li>
<li id="fn18"><p>僕の文献管理ソフトの中には山のように入っているけれど、そんなのここにコピペしてもしょうがないでしょ？<a href="#fnref18" class="footnote-back">↩</a></p></li>
<li id="fn19"><p>Shuichi Isomura, Toshiaki Onitsuka, etal: Differentiation between major depressive disorder and bipolar disorder by auditory steady-state responses, Journal of affective disorders, 190:800–806,2016<a href="#fnref19" class="footnote-back">↩</a></p></li>
<li id="fn20"><p>BF O’donnell, JL Vohs, etal: Auditory event-related potential abnormalities in bipolar disorder and schizophrenia, International Journal of Psychophysiology, 53-1:45–55,2004<a href="#fnref20" class="footnote-back">↩</a></p></li>
<li id="fn21"><p>ちなみに、僕は精神科の医者をやってご飯を食べています<a href="#fnref21" class="footnote-back">↩</a></p></li>
<li id="fn22"><p>動物実験でしてる人は居るらしいですが、人間にやると警察に捕まります。<a href="#fnref22" class="footnote-back">↩</a></p></li>
<li id="fn23"><p>厳しすぎない？<a href="#fnref23" class="footnote-back">↩</a></p></li>
<li id="fn24"><p>ハードウェア、ソフトウェア共にオープンソースという夢広がりんぐな脳波計なのですが、使ったこと無いのでどの程度の性能なのかよく知りません。レビュー求む！<a href="#fnref24" class="footnote-back">↩</a></p></li>
<li id="fn25"><p>あくまで本番環境ではの話です。例えばノートを通してサーバーやワークステーションを動かすとか、スクリプトの雛形を作るという用途であればソースベース解析でもノートは実用性に優れています。<a href="#fnref25" class="footnote-back">↩</a></p></li>
<li id="fn26"><p>UBUNTUはCanonical社によって開発されているオープンソースのlinuxディストリビューションであり、人気があります。debianというディストリビューションをベースに作られています。ちなみに、名前は南アフリカの言葉で友愛という意味だそうです。<a href="#fnref26" class="footnote-back">↩</a></p></li>
<li id="fn27"><p>最近流行りの仮想化環境です。性能が高いのが特徴ですが、反面使いこなすのには力が必要です。<a href="#fnref27" class="footnote-back">↩</a></p></li>
<li id="fn28"><p>anacondaとはContinuumAnalytics社で開発されているデータサイエンティスト向けのpythonディストリビューションです。もちろん好みに応じてpipenvなどを使うのもありですが、面倒いので書きません。<a href="#fnref28" class="footnote-back">↩</a></p></li>
<li id="fn29"><p>python標準の仮想環境です。非常にシンプルで、シンプルである故にトラブルが少ないですが、少し煩雑です。<a href="#fnref29" class="footnote-back">↩</a></p></li>
<li id="fn30"><p>昔python公式がオヌヌメしていた仮想環境作りツールです。かなりリッチです。重いのとトラブりやすいのが欠点です。<a href="#fnref30" class="footnote-back">↩</a></p></li>
<li id="fn31"><p>pipenvの代替。pipenvがpython界でメジャーになったのですが、割と不安定なところもあったので、開発されたやつです。速くて安定していて、控えめに言って神なのですが大げさかも？<a href="#fnref31" class="footnote-back">↩</a></p></li>
<li id="fn32"><p>特定言語用の対話型インターフェイスのこと。<a href="#fnref32" class="footnote-back">↩</a></p></li>
<li id="fn33"><p>統合開発環境のこと。<a href="#fnref33" class="footnote-back">↩</a></p></li>
<li id="fn34"><p>圧倒的なテキストエディタの一つ。僕は脳波解析も、同人誌執筆も、すべてvimで行っています。<a href="#fnref34" class="footnote-back">↩</a></p></li>
<li id="fn35"><p>仮想環境にも色々あります。例えば、pipenv、poetryなどです。anacondaも同じ様な感じで使えます。<a href="#fnref35" class="footnote-back">↩</a></p></li>
<li id="fn36"><p>同様に、matlabやC等と連携をすることが簡単なのがjupyterの強みの一つと思います。<a href="#fnref36" class="footnote-back">↩</a></p></li>
<li id="fn37"><p>プログラミング用バージョン管理ソフト。敷居は高いが多機能で超速。GUIクライアントも豊富。<a href="#fnref37" class="footnote-back">↩</a></p></li>
<li id="fn38"><p>昔はsource activateコマンドでしたが、このコマンドはanaconda以外の仮想環境ツールと衝突してクラッシュするという不具合がありました。控えめに言って糞仕様ですね。今後はconda activateコマンドを使うのがいいでしょう。<a href="#fnref38" class="footnote-back">↩</a></p></li>
<li id="fn39"><p>nVidiaのGPUを使った高速な計算ができる開発環境。うまく使いこなせればCPUの10から100倍速いです。<a href="#fnref39" class="footnote-back">↩</a></p></li>
<li id="fn40"><p>MNE pythonはGPUの使い方が下手くそです。<a href="#fnref40" class="footnote-back">↩</a></p></li>
<li id="fn41"><p>理由はopenMPというライブラリを使った並列化だからです。openMPはマルチスレッドを簡単に実装する優れたライブラリなのですが、メモリの位置が近い場合にスレッド同士がメモリ領域の取り合いをしてしまうため速度が頭落ちになるのです。このケースではマルチスレッドよりシングルプロセスをいっぱい並べる方が良いように思います。<a href="#fnref41" class="footnote-back">↩</a></p></li>
<li id="fn42"><p>ちなみに、僕はvimmerなのでvimを使ってshを直書きしています。vimでシェルを扱うときの必殺技があるのです。ですが、本書はvimの本ではないので書きませんｗｗｗｗｗｗ<a href="#fnref42" class="footnote-back">↩</a></p></li>
<li id="fn43"><p>脳に水を流し込むシミレーションをすることで切っていいところと悪い所を分ける処理<a href="#fnref43" class="footnote-back">↩</a></p></li>
<li id="fn44"><p>python用行列計算ライブラリ。科学計算に広く用いられています。<a href="#fnref44" class="footnote-back">↩</a></p></li>
<li id="fn45"><p>信じられないでしょうが、本当です。<a href="#fnref45" class="footnote-back">↩</a></p></li>
<li id="fn46"><p>この同人誌にも、ソースコードを読んで書き換えた所があります。<a href="#fnref46" class="footnote-back">↩</a></p></li>
<li id="fn47"><p>生の波形を見たいときなどにはそのほうが向いてる<a href="#fnref47" class="footnote-back">↩</a></p></li>
<li id="fn48"><p>各周波数ごとの波の強さをあらわしたもの。フーリエ変換の結果算出されるものの1つ。<a href="#fnref48" class="footnote-back">↩</a></p></li>
<li id="fn49"><p>ipython/jupyter独自の単位でcellといいます。通常のプログラミングでは行ごと、関数ごとですが、jupyterでは数行をひと塊りにしてプログラムを書きます。色々悪いところもありますが、解説用コードを書けるのがjupyterの強みです。<a href="#fnref49" class="footnote-back">↩</a></p></li>
<li id="fn50"><p>敢えて除去しない研究者もいます。notchfilterによって、除去する周波数の周辺の信頼性が失われるとのことです。<a href="#fnref50" class="footnote-back">↩</a></p></li>
<li id="fn51"><p>preloadしないと各種処理が出来ないので、ほぼ必須です。何故preloadが標準でFalseなのかはよくわかりませんが、Falseも使いみちがあります。例えば生波形を素早く表示するだけならばpreloadはFalseが軽いです。<a href="#fnref51" class="footnote-back">↩</a></p></li>
<li id="fn52"><p>バンドパスフィルタについては賛否両論と思います。何故なら、時間周波数解析をすると要らない周波数は消えちゃうので、意味が無いという考えがあるからです。詳しくは参考文献のanalyzing neural …を読んで下さい。個人的にはソースレベル解析の場合はした方がいいと思います。<a href="#fnref52" class="footnote-back">↩</a></p></li>
<li id="fn53"><p>notchフィルタもバンドパスフィルタ同様賛否両論です。<a href="#fnref53" class="footnote-back">↩</a></p></li>
<li id="fn54"><p>DeepLearningが今の世の流行りですが、DeepLearningは画像が得意だという点があります。これはCNNという手法があるからですが、波形をCNNに適用する手法もあります。でも、これが筋が良いかと言うと色々意見もあろうかと。<a href="#fnref54" class="footnote-back">↩</a></p></li>
<li id="fn55"><p>もしも完全に消えちゃうのが欲しければ直交Waveletというのもあるのですが、ギザギザしており、解析にはあまり向きません。理屈編で語ります。<a href="#fnref55" class="footnote-back">↩</a></p></li>
<li id="fn56"><p>高校を卒業した事のある人は目をそらさないでいただこうか。<a href="#fnref56" class="footnote-back">↩</a></p></li>
<li id="fn57"><p>ちなみにphase locking valueという全然別のものがあります。これはコネクティビティ用語ですので分野が違います。あとで書きます。<a href="#fnref57" class="footnote-back">↩</a></p></li>
<li id="fn58"><p>これは実質itcと似たようなもの…という考え方もあります。<a href="#fnref58" class="footnote-back">↩</a></p></li>
<li id="fn59"><p>大抵は、の話です。心臓の鼓動と脳波のコネクティビティの研究も一応あります！<a href="#fnref59" class="footnote-back">↩</a></p></li>
<li id="fn60"><p>というか、本当はこんな言葉の使い方は間違ってる気がする。BEMは本当はMethodの名前です。<a href="#fnref60" class="footnote-back">↩</a></p></li>
<li id="fn61"><p>labelを選ばない場合これは激重です。何故なら306チャンネルのMEGからソースに落とし込むと計算方法によっては10000チャンネルくらいになります。ROIを絞ったとしても「人数×タスク×ROIの数×EPOCHの数」回wavelet変換してpowerとitcに落とし込むのですから…途方もない計算量です。labelを選びましょう。<a href="#fnref61" class="footnote-back">↩</a></p></li>
<li id="fn62"><p>僕がソースコードを読んで知ったので、読み損ないはあるかも？<a href="#fnref62" class="footnote-back">↩</a></p></li>
<li id="fn63"><p>工学部生は目をそらさないでいてもらおうか<a href="#fnref63" class="footnote-back">↩</a></p></li>
<li id="fn64"><p>短い時間で解析すると時間的には細かく解析できるけど、周波数の詳しい所が見れなくなります。これをフーリエ変換の不確定性原理と言います。量子力学にも出てくる言葉ですが、実は同じことなのです。<a href="#fnref64" class="footnote-back">↩</a></p></li>
<li id="fn65"><p>ちなみに、<span class="math inline"><em>θ</em></span>が1の場合はオイラーの等式と言います。美しいです。<a href="#fnref65" class="footnote-back">↩</a></p></li>
<li id="fn66"><p>既に作られているものをもう一回作る無駄のことを、業界では「車輪の再発明」と言い、性能が落ちる車輪の再発明のことを「四角い車輪の再発明」といいます。<a href="#fnref66" class="footnote-back">↩</a></p></li>
<li id="fn67"><p>ノルムが小さいということ。中学生風に言うと絶対値。<a href="#fnref67" class="footnote-back">↩</a></p></li>
<li id="fn68"><p>リアル友達欲しいです(´;ω;｀)<a href="#fnref68" class="footnote-back">↩</a></p></li>
<li id="fn69"><p>Tamesh Halder, Siddharth Talwar, Amit Kumar Jaiswal and Arpan Banerjee eNeuro 16 July 2019, 6 (4) ENEURO.0170-19.2019<a href="#fnref69" class="footnote-back">↩</a></p></li>
<li id="fn70"><p>ただし、世代による<a href="#fnref70" class="footnote-back">↩</a></p></li>
<li id="fn71"><p>ここまでが中学数学の範囲<a href="#fnref71" class="footnote-back">↩</a></p></li>
<li id="fn72"><p>無限個の解が存在します。<a href="#fnref72" class="footnote-back">↩</a></p></li>
<li id="fn73"><p>ちなみに、羽が二枚の昆虫はハエとアブと蚊だけです。可愛い虫には羽がたいてい4枚あります。<a href="#fnref73" class="footnote-back">↩</a></p></li>
<li id="fn74"><p>実は、この条件を求めるのは難しいだけじゃなくて僕にとって退屈な作業です。ちなみに、高校数学の範囲内です。<a href="#fnref74" class="footnote-back">↩</a></p></li>
<li id="fn75"><p>数学で言う、大きさの種類の一つ。全ての要素の二乗の合計のルートを取ったもの。<a href="#fnref75" class="footnote-back">↩</a></p></li>
<li id="fn76"><p>別名、ムーアペンローズの逆行列<a href="#fnref76" class="footnote-back">↩</a></p></li>
<li id="fn77"><p>カーネル法を用いたこの方法はサポートベクトルマシンやカーネルPCAと言われる分類器に応用された。これは一世代前の最も成功した人工知能である。<a href="#fnref77" class="footnote-back">↩</a></p></li>
<li id="fn78"><p>ここでは数値はあくまで例なので適当です)<a href="#fnref78" class="footnote-back">↩</a></p></li>
<li id="fn79"><p>完全に0にはならないけれど<a href="#fnref79" class="footnote-back">↩</a></p></li>
<li id="fn80"><p>これには、もうちょっと考えるべきことが入りますが、解や式自体は全く同じになります。<a href="#fnref80" class="footnote-back">↩</a></p></li>
<li id="fn81"><p>実際はオーバーヘッドがあるので比例まではしない。<a href="#fnref81" class="footnote-back">↩</a></p></li>
<li id="fn82"><p>というか、bool型を返してくれるやつなら何でも行ける。<a href="#fnref82" class="footnote-back">↩</a></p></li>
<li id="fn83"><p>無名関数。１行の使い捨てのやつ。<a href="#fnref83" class="footnote-back">↩</a></p></li>
</ol>
</section>
</body>
</html>
